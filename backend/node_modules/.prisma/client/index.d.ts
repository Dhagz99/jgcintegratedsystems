
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model RequestType
 * 
 */
export type RequestType = $Result.DefaultSelection<Prisma.$RequestTypePayload>
/**
 * Model RequestChecker
 * 
 */
export type RequestChecker = $Result.DefaultSelection<Prisma.$RequestCheckerPayload>
/**
 * Model MainRequest
 * 
 */
export type MainRequest = $Result.DefaultSelection<Prisma.$MainRequestPayload>
/**
 * Model FormFundTransfer
 * 
 */
export type FormFundTransfer = $Result.DefaultSelection<Prisma.$FormFundTransferPayload>
/**
 * Model ApprovalTable
 * 
 */
export type ApprovalTable = $Result.DefaultSelection<Prisma.$ApprovalTablePayload>
/**
 * Model RequestLogs
 * 
 */
export type RequestLogs = $Result.DefaultSelection<Prisma.$RequestLogsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Admin: 'Admin',
  User: 'User',
  Branch: 'Branch',
  Coordinator: 'Coordinator',
  Superadmin: 'Superadmin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Statuses: {
  PENDING: 'PENDING',
  INPROGRESS: 'INPROGRESS',
  CANCEL: 'CANCEL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EMPTY: 'EMPTY'
};

export type Statuses = (typeof Statuses)[keyof typeof Statuses]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Statuses = $Enums.Statuses

export const Statuses: typeof $Enums.Statuses

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestType`: Exposes CRUD operations for the **RequestType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestTypes
    * const requestTypes = await prisma.requestType.findMany()
    * ```
    */
  get requestType(): Prisma.RequestTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestChecker`: Exposes CRUD operations for the **RequestChecker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestCheckers
    * const requestCheckers = await prisma.requestChecker.findMany()
    * ```
    */
  get requestChecker(): Prisma.RequestCheckerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mainRequest`: Exposes CRUD operations for the **MainRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainRequests
    * const mainRequests = await prisma.mainRequest.findMany()
    * ```
    */
  get mainRequest(): Prisma.MainRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formFundTransfer`: Exposes CRUD operations for the **FormFundTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormFundTransfers
    * const formFundTransfers = await prisma.formFundTransfer.findMany()
    * ```
    */
  get formFundTransfer(): Prisma.FormFundTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvalTable`: Exposes CRUD operations for the **ApprovalTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalTables
    * const approvalTables = await prisma.approvalTable.findMany()
    * ```
    */
  get approvalTable(): Prisma.ApprovalTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestLogs`: Exposes CRUD operations for the **RequestLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestLogs
    * const requestLogs = await prisma.requestLogs.findMany()
    * ```
    */
  get requestLogs(): Prisma.RequestLogsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Branch: 'Branch',
    RequestType: 'RequestType',
    RequestChecker: 'RequestChecker',
    MainRequest: 'MainRequest',
    FormFundTransfer: 'FormFundTransfer',
    ApprovalTable: 'ApprovalTable',
    RequestLogs: 'RequestLogs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "branch" | "requestType" | "requestChecker" | "mainRequest" | "formFundTransfer" | "approvalTable" | "requestLogs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      RequestType: {
        payload: Prisma.$RequestTypePayload<ExtArgs>
        fields: Prisma.RequestTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          findFirst: {
            args: Prisma.RequestTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          findMany: {
            args: Prisma.RequestTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          create: {
            args: Prisma.RequestTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          createMany: {
            args: Prisma.RequestTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          delete: {
            args: Prisma.RequestTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          update: {
            args: Prisma.RequestTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          deleteMany: {
            args: Prisma.RequestTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          upsert: {
            args: Prisma.RequestTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          aggregate: {
            args: Prisma.RequestTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestType>
          }
          groupBy: {
            args: Prisma.RequestTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RequestTypeCountAggregateOutputType> | number
          }
        }
      }
      RequestChecker: {
        payload: Prisma.$RequestCheckerPayload<ExtArgs>
        fields: Prisma.RequestCheckerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestCheckerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestCheckerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          findFirst: {
            args: Prisma.RequestCheckerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestCheckerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          findMany: {
            args: Prisma.RequestCheckerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>[]
          }
          create: {
            args: Prisma.RequestCheckerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          createMany: {
            args: Prisma.RequestCheckerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCheckerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>[]
          }
          delete: {
            args: Prisma.RequestCheckerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          update: {
            args: Prisma.RequestCheckerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          deleteMany: {
            args: Prisma.RequestCheckerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestCheckerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestCheckerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>[]
          }
          upsert: {
            args: Prisma.RequestCheckerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCheckerPayload>
          }
          aggregate: {
            args: Prisma.RequestCheckerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestChecker>
          }
          groupBy: {
            args: Prisma.RequestCheckerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestCheckerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCheckerCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCheckerCountAggregateOutputType> | number
          }
        }
      }
      MainRequest: {
        payload: Prisma.$MainRequestPayload<ExtArgs>
        fields: Prisma.MainRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MainRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MainRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          findFirst: {
            args: Prisma.MainRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MainRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          findMany: {
            args: Prisma.MainRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          create: {
            args: Prisma.MainRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          createMany: {
            args: Prisma.MainRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MainRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          delete: {
            args: Prisma.MainRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          update: {
            args: Prisma.MainRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          deleteMany: {
            args: Prisma.MainRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MainRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MainRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          upsert: {
            args: Prisma.MainRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          aggregate: {
            args: Prisma.MainRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMainRequest>
          }
          groupBy: {
            args: Prisma.MainRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MainRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MainRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MainRequestCountAggregateOutputType> | number
          }
        }
      }
      FormFundTransfer: {
        payload: Prisma.$FormFundTransferPayload<ExtArgs>
        fields: Prisma.FormFundTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFundTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFundTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          findFirst: {
            args: Prisma.FormFundTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFundTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          findMany: {
            args: Prisma.FormFundTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          create: {
            args: Prisma.FormFundTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          createMany: {
            args: Prisma.FormFundTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormFundTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          delete: {
            args: Prisma.FormFundTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          update: {
            args: Prisma.FormFundTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          deleteMany: {
            args: Prisma.FormFundTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormFundTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormFundTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          upsert: {
            args: Prisma.FormFundTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          aggregate: {
            args: Prisma.FormFundTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormFundTransfer>
          }
          groupBy: {
            args: Prisma.FormFundTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormFundTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormFundTransferCountArgs<ExtArgs>
            result: $Utils.Optional<FormFundTransferCountAggregateOutputType> | number
          }
        }
      }
      ApprovalTable: {
        payload: Prisma.$ApprovalTablePayload<ExtArgs>
        fields: Prisma.ApprovalTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          findFirst: {
            args: Prisma.ApprovalTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          findMany: {
            args: Prisma.ApprovalTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          create: {
            args: Prisma.ApprovalTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          createMany: {
            args: Prisma.ApprovalTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          delete: {
            args: Prisma.ApprovalTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          update: {
            args: Prisma.ApprovalTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          deleteMany: {
            args: Prisma.ApprovalTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          upsert: {
            args: Prisma.ApprovalTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          aggregate: {
            args: Prisma.ApprovalTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalTable>
          }
          groupBy: {
            args: Prisma.ApprovalTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalTableCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTableCountAggregateOutputType> | number
          }
        }
      }
      RequestLogs: {
        payload: Prisma.$RequestLogsPayload<ExtArgs>
        fields: Prisma.RequestLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          findFirst: {
            args: Prisma.RequestLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          findMany: {
            args: Prisma.RequestLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          create: {
            args: Prisma.RequestLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          createMany: {
            args: Prisma.RequestLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestLogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          delete: {
            args: Prisma.RequestLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          update: {
            args: Prisma.RequestLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          deleteMany: {
            args: Prisma.RequestLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestLogsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          upsert: {
            args: Prisma.RequestLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          aggregate: {
            args: Prisma.RequestLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestLogs>
          }
          groupBy: {
            args: Prisma.RequestLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestLogsCountArgs<ExtArgs>
            result: $Utils.Optional<RequestLogsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    branch?: BranchOmit
    requestType?: RequestTypeOmit
    requestChecker?: RequestCheckerOmit
    mainRequest?: MainRequestOmit
    formFundTransfer?: FormFundTransferOmit
    approvalTable?: ApprovalTableOmit
    requestLogs?: RequestLogsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    checker: number
    mainForm: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checker?: boolean | UserCountOutputTypeCountCheckerArgs
    mainForm?: boolean | UserCountOutputTypeCountMainFormArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestCheckerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    users: number
    main: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    main?: boolean | BranchCountOutputTypeCountMainArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type RequestTypeCountOutputType
   */

  export type RequestTypeCountOutputType = {
    mainRequests: number
  }

  export type RequestTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequests?: boolean | RequestTypeCountOutputTypeCountMainRequestsArgs
  }

  // Custom InputTypes
  /**
   * RequestTypeCountOutputType without action
   */
  export type RequestTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestTypeCountOutputType
     */
    select?: RequestTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestTypeCountOutputType without action
   */
  export type RequestTypeCountOutputTypeCountMainRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type RequestCheckerCountOutputType
   */

  export type RequestCheckerCountOutputType = {
    notedByForTypes: number
    checkedByForTypes: number
    checkedBy2ForTypes: number
    recomApprovalForTypes: number
    recomApproval2ForTypes: number
    approveByForTypes: number
    formRequestFundTo: number
    requestLogs: number
  }

  export type RequestCheckerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedByForTypes?: boolean | RequestCheckerCountOutputTypeCountNotedByForTypesArgs
    checkedByForTypes?: boolean | RequestCheckerCountOutputTypeCountCheckedByForTypesArgs
    checkedBy2ForTypes?: boolean | RequestCheckerCountOutputTypeCountCheckedBy2ForTypesArgs
    recomApprovalForTypes?: boolean | RequestCheckerCountOutputTypeCountRecomApprovalForTypesArgs
    recomApproval2ForTypes?: boolean | RequestCheckerCountOutputTypeCountRecomApproval2ForTypesArgs
    approveByForTypes?: boolean | RequestCheckerCountOutputTypeCountApproveByForTypesArgs
    formRequestFundTo?: boolean | RequestCheckerCountOutputTypeCountFormRequestFundToArgs
    requestLogs?: boolean | RequestCheckerCountOutputTypeCountRequestLogsArgs
  }

  // Custom InputTypes
  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCheckerCountOutputType
     */
    select?: RequestCheckerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountNotedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountCheckedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountCheckedBy2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountRecomApprovalForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountRecomApproval2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountApproveByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountFormRequestFundToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFundTransferWhereInput
  }

  /**
   * RequestCheckerCountOutputType without action
   */
  export type RequestCheckerCountOutputTypeCountRequestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
  }


  /**
   * Count Type MainRequestCountOutputType
   */

  export type MainRequestCountOutputType = {
    approval: number
  }

  export type MainRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | MainRequestCountOutputTypeCountApprovalArgs
  }

  // Custom InputTypes
  /**
   * MainRequestCountOutputType without action
   */
  export type MainRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequestCountOutputType
     */
    select?: MainRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MainRequestCountOutputType without action
   */
  export type MainRequestCountOutputTypeCountApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTableWhereInput
  }


  /**
   * Count Type ApprovalTableCountOutputType
   */

  export type ApprovalTableCountOutputType = {
    requestLogs: number
  }

  export type ApprovalTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestLogs?: boolean | ApprovalTableCountOutputTypeCountRequestLogsArgs
  }

  // Custom InputTypes
  /**
   * ApprovalTableCountOutputType without action
   */
  export type ApprovalTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTableCountOutputType
     */
    select?: ApprovalTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalTableCountOutputType without action
   */
  export type ApprovalTableCountOutputTypeCountRequestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    branchId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    branchId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    username: number
    password: number
    role: number
    branchId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    username: string
    password: string
    role: $Enums.Role
    branchId: number | null
    createdAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    checker?: boolean | User$checkerArgs<ExtArgs>
    mainForm?: boolean | User$mainFormArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "username" | "password" | "role" | "branchId" | "createdAt" | "updateAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    checker?: boolean | User$checkerArgs<ExtArgs>
    mainForm?: boolean | User$mainFormArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      checker: Prisma.$RequestCheckerPayload<ExtArgs>[]
      mainForm: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      username: string
      password: string
      role: $Enums.Role
      branchId: number | null
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checker<T extends User$checkerArgs<ExtArgs> = {}>(args?: Subset<T, User$checkerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mainForm<T extends User$mainFormArgs<ExtArgs> = {}>(args?: Subset<T, User$mainFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updateAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.checker
   */
  export type User$checkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
    orderBy?: RequestCheckerOrderByWithRelationInput | RequestCheckerOrderByWithRelationInput[]
    cursor?: RequestCheckerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestCheckerScalarFieldEnum | RequestCheckerScalarFieldEnum[]
  }

  /**
   * User.mainForm
   */
  export type User$mainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    branchCode: string | null
    branchName: string | null
    bom: string | null
    faa: string | null
    telephone: string | null
    address: string | null
    companyName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    branchCode: string | null
    branchName: string | null
    bom: string | null
    faa: string | null
    telephone: string | null
    address: string | null
    companyName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    branchCode: number
    branchName: number
    bom: number
    faa: number
    telephone: number
    address: number
    companyName: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt: Date
    updateAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
    users?: boolean | Branch$usersArgs<ExtArgs>
    main?: boolean | Branch$mainArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branchCode" | "branchName" | "bom" | "faa" | "telephone" | "address" | "companyName" | "createdAt" | "updateAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Branch$usersArgs<ExtArgs>
    main?: boolean | Branch$mainArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      main: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchCode: string
      branchName: string
      bom: string
      faa: string
      telephone: string
      address: string
      companyName: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    main<T extends Branch$mainArgs<ExtArgs> = {}>(args?: Subset<T, Branch$mainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly branchCode: FieldRef<"Branch", 'String'>
    readonly branchName: FieldRef<"Branch", 'String'>
    readonly bom: FieldRef<"Branch", 'String'>
    readonly faa: FieldRef<"Branch", 'String'>
    readonly telephone: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly companyName: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updateAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.main
   */
  export type Branch$mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model RequestType
   */

  export type AggregateRequestType = {
    _count: RequestTypeCountAggregateOutputType | null
    _avg: RequestTypeAvgAggregateOutputType | null
    _sum: RequestTypeSumAggregateOutputType | null
    _min: RequestTypeMinAggregateOutputType | null
    _max: RequestTypeMaxAggregateOutputType | null
  }

  export type RequestTypeAvgAggregateOutputType = {
    id: number | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
  }

  export type RequestTypeSumAggregateOutputType = {
    id: number | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
  }

  export type RequestTypeMinAggregateOutputType = {
    id: number | null
    requestName: string | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type RequestTypeMaxAggregateOutputType = {
    id: number | null
    requestName: string | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type RequestTypeCountAggregateOutputType = {
    id: number
    requestName: number
    notedById: number
    checkedById: number
    checkedBy2Id: number
    recomApprovalId: number
    recomApproval2Id: number
    approveById: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type RequestTypeAvgAggregateInputType = {
    id?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
  }

  export type RequestTypeSumAggregateInputType = {
    id?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
  }

  export type RequestTypeMinAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
  }

  export type RequestTypeMaxAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
  }

  export type RequestTypeCountAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type RequestTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestType to aggregate.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestTypes
    **/
    _count?: true | RequestTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestTypeMaxAggregateInputType
  }

  export type GetRequestTypeAggregateType<T extends RequestTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestType[P]>
      : GetScalarType<T[P], AggregateRequestType[P]>
  }




  export type RequestTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithAggregationInput | RequestTypeOrderByWithAggregationInput[]
    by: RequestTypeScalarFieldEnum[] | RequestTypeScalarFieldEnum
    having?: RequestTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestTypeCountAggregateInputType | true
    _avg?: RequestTypeAvgAggregateInputType
    _sum?: RequestTypeSumAggregateInputType
    _min?: RequestTypeMinAggregateInputType
    _max?: RequestTypeMaxAggregateInputType
  }

  export type RequestTypeGroupByOutputType = {
    id: number
    requestName: string
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date
    updateAt: Date
    _count: RequestTypeCountAggregateOutputType | null
    _avg: RequestTypeAvgAggregateOutputType | null
    _sum: RequestTypeSumAggregateOutputType | null
    _min: RequestTypeMinAggregateOutputType | null
    _max: RequestTypeMaxAggregateOutputType | null
  }

  type GetRequestTypeGroupByPayload<T extends RequestTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RequestTypeGroupByOutputType[P]>
        }
      >
    >


  export type RequestTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
    mainRequests?: boolean | RequestType$mainRequestsArgs<ExtArgs>
    _count?: boolean | RequestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectScalar = {
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type RequestTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestName" | "notedById" | "checkedById" | "checkedBy2Id" | "recomApprovalId" | "recomApproval2Id" | "approveById" | "createdAt" | "updateAt", ExtArgs["result"]["requestType"]>
  export type RequestTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
    mainRequests?: boolean | RequestType$mainRequestsArgs<ExtArgs>
    _count?: boolean | RequestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }
  export type RequestTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }

  export type $RequestTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestType"
    objects: {
      notedBy: Prisma.$RequestCheckerPayload<ExtArgs> | null
      checkedBy: Prisma.$RequestCheckerPayload<ExtArgs> | null
      checkedBy2: Prisma.$RequestCheckerPayload<ExtArgs> | null
      recomApproval: Prisma.$RequestCheckerPayload<ExtArgs> | null
      recomApproval2: Prisma.$RequestCheckerPayload<ExtArgs> | null
      approveBy: Prisma.$RequestCheckerPayload<ExtArgs> | null
      mainRequests: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestName: string
      notedById: number | null
      checkedById: number | null
      checkedBy2Id: number | null
      recomApprovalId: number | null
      recomApproval2Id: number | null
      approveById: number | null
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["requestType"]>
    composites: {}
  }

  type RequestTypeGetPayload<S extends boolean | null | undefined | RequestTypeDefaultArgs> = $Result.GetResult<Prisma.$RequestTypePayload, S>

  type RequestTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestTypeCountAggregateInputType | true
    }

  export interface RequestTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestType'], meta: { name: 'RequestType' } }
    /**
     * Find zero or one RequestType that matches the filter.
     * @param {RequestTypeFindUniqueArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestTypeFindUniqueArgs>(args: SelectSubset<T, RequestTypeFindUniqueArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestTypeFindUniqueOrThrowArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindFirstArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestTypeFindFirstArgs>(args?: SelectSubset<T, RequestTypeFindFirstArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindFirstOrThrowArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestTypes
     * const requestTypes = await prisma.requestType.findMany()
     * 
     * // Get first 10 RequestTypes
     * const requestTypes = await prisma.requestType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestTypeFindManyArgs>(args?: SelectSubset<T, RequestTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestType.
     * @param {RequestTypeCreateArgs} args - Arguments to create a RequestType.
     * @example
     * // Create one RequestType
     * const RequestType = await prisma.requestType.create({
     *   data: {
     *     // ... data to create a RequestType
     *   }
     * })
     * 
     */
    create<T extends RequestTypeCreateArgs>(args: SelectSubset<T, RequestTypeCreateArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestTypes.
     * @param {RequestTypeCreateManyArgs} args - Arguments to create many RequestTypes.
     * @example
     * // Create many RequestTypes
     * const requestType = await prisma.requestType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestTypeCreateManyArgs>(args?: SelectSubset<T, RequestTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestTypes and returns the data saved in the database.
     * @param {RequestTypeCreateManyAndReturnArgs} args - Arguments to create many RequestTypes.
     * @example
     * // Create many RequestTypes
     * const requestType = await prisma.requestType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestTypes and only return the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestType.
     * @param {RequestTypeDeleteArgs} args - Arguments to delete one RequestType.
     * @example
     * // Delete one RequestType
     * const RequestType = await prisma.requestType.delete({
     *   where: {
     *     // ... filter to delete one RequestType
     *   }
     * })
     * 
     */
    delete<T extends RequestTypeDeleteArgs>(args: SelectSubset<T, RequestTypeDeleteArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestType.
     * @param {RequestTypeUpdateArgs} args - Arguments to update one RequestType.
     * @example
     * // Update one RequestType
     * const requestType = await prisma.requestType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestTypeUpdateArgs>(args: SelectSubset<T, RequestTypeUpdateArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestTypes.
     * @param {RequestTypeDeleteManyArgs} args - Arguments to filter RequestTypes to delete.
     * @example
     * // Delete a few RequestTypes
     * const { count } = await prisma.requestType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestTypeDeleteManyArgs>(args?: SelectSubset<T, RequestTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestTypes
     * const requestType = await prisma.requestType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestTypeUpdateManyArgs>(args: SelectSubset<T, RequestTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestTypes and returns the data updated in the database.
     * @param {RequestTypeUpdateManyAndReturnArgs} args - Arguments to update many RequestTypes.
     * @example
     * // Update many RequestTypes
     * const requestType = await prisma.requestType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestTypes and only return the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestType.
     * @param {RequestTypeUpsertArgs} args - Arguments to update or create a RequestType.
     * @example
     * // Update or create a RequestType
     * const requestType = await prisma.requestType.upsert({
     *   create: {
     *     // ... data to create a RequestType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestType we want to update
     *   }
     * })
     */
    upsert<T extends RequestTypeUpsertArgs>(args: SelectSubset<T, RequestTypeUpsertArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeCountArgs} args - Arguments to filter RequestTypes to count.
     * @example
     * // Count the number of RequestTypes
     * const count = await prisma.requestType.count({
     *   where: {
     *     // ... the filter for the RequestTypes we want to count
     *   }
     * })
    **/
    count<T extends RequestTypeCountArgs>(
      args?: Subset<T, RequestTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestTypeAggregateArgs>(args: Subset<T, RequestTypeAggregateArgs>): Prisma.PrismaPromise<GetRequestTypeAggregateType<T>>

    /**
     * Group by RequestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestTypeGroupByArgs['orderBy'] }
        : { orderBy?: RequestTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestType model
   */
  readonly fields: RequestTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notedBy<T extends RequestType$notedByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$notedByArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checkedBy<T extends RequestType$checkedByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$checkedByArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checkedBy2<T extends RequestType$checkedBy2Args<ExtArgs> = {}>(args?: Subset<T, RequestType$checkedBy2Args<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recomApproval<T extends RequestType$recomApprovalArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$recomApprovalArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recomApproval2<T extends RequestType$recomApproval2Args<ExtArgs> = {}>(args?: Subset<T, RequestType$recomApproval2Args<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approveBy<T extends RequestType$approveByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$approveByArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mainRequests<T extends RequestType$mainRequestsArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$mainRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestType model
   */
  interface RequestTypeFieldRefs {
    readonly id: FieldRef<"RequestType", 'Int'>
    readonly requestName: FieldRef<"RequestType", 'String'>
    readonly notedById: FieldRef<"RequestType", 'Int'>
    readonly checkedById: FieldRef<"RequestType", 'Int'>
    readonly checkedBy2Id: FieldRef<"RequestType", 'Int'>
    readonly recomApprovalId: FieldRef<"RequestType", 'Int'>
    readonly recomApproval2Id: FieldRef<"RequestType", 'Int'>
    readonly approveById: FieldRef<"RequestType", 'Int'>
    readonly createdAt: FieldRef<"RequestType", 'DateTime'>
    readonly updateAt: FieldRef<"RequestType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestType findUnique
   */
  export type RequestTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType findUniqueOrThrow
   */
  export type RequestTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType findFirst
   */
  export type RequestTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestTypes.
     */
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType findFirstOrThrow
   */
  export type RequestTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestTypes.
     */
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType findMany
   */
  export type RequestTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestTypes to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType create
   */
  export type RequestTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestType.
     */
    data: XOR<RequestTypeCreateInput, RequestTypeUncheckedCreateInput>
  }

  /**
   * RequestType createMany
   */
  export type RequestTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestTypes.
     */
    data: RequestTypeCreateManyInput | RequestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestType createManyAndReturn
   */
  export type RequestTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * The data used to create many RequestTypes.
     */
    data: RequestTypeCreateManyInput | RequestTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestType update
   */
  export type RequestTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestType.
     */
    data: XOR<RequestTypeUpdateInput, RequestTypeUncheckedUpdateInput>
    /**
     * Choose, which RequestType to update.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType updateMany
   */
  export type RequestTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestTypes.
     */
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyInput>
    /**
     * Filter which RequestTypes to update
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to update.
     */
    limit?: number
  }

  /**
   * RequestType updateManyAndReturn
   */
  export type RequestTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * The data used to update RequestTypes.
     */
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyInput>
    /**
     * Filter which RequestTypes to update
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestType upsert
   */
  export type RequestTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestType to update in case it exists.
     */
    where: RequestTypeWhereUniqueInput
    /**
     * In case the RequestType found by the `where` argument doesn't exist, create a new RequestType with this data.
     */
    create: XOR<RequestTypeCreateInput, RequestTypeUncheckedCreateInput>
    /**
     * In case the RequestType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestTypeUpdateInput, RequestTypeUncheckedUpdateInput>
  }

  /**
   * RequestType delete
   */
  export type RequestTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter which RequestType to delete.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType deleteMany
   */
  export type RequestTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestTypes to delete
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to delete.
     */
    limit?: number
  }

  /**
   * RequestType.notedBy
   */
  export type RequestType$notedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.checkedBy
   */
  export type RequestType$checkedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.checkedBy2
   */
  export type RequestType$checkedBy2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.recomApproval
   */
  export type RequestType$recomApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.recomApproval2
   */
  export type RequestType$recomApproval2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.approveBy
   */
  export type RequestType$approveByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestType.mainRequests
   */
  export type RequestType$mainRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * RequestType without action
   */
  export type RequestTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
  }


  /**
   * Model RequestChecker
   */

  export type AggregateRequestChecker = {
    _count: RequestCheckerCountAggregateOutputType | null
    _avg: RequestCheckerAvgAggregateOutputType | null
    _sum: RequestCheckerSumAggregateOutputType | null
    _min: RequestCheckerMinAggregateOutputType | null
    _max: RequestCheckerMaxAggregateOutputType | null
  }

  export type RequestCheckerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RequestCheckerSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RequestCheckerMinAggregateOutputType = {
    id: number | null
    userId: number | null
    position: string | null
    initial: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCheckerMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    position: string | null
    initial: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCheckerCountAggregateOutputType = {
    id: number
    userId: number
    position: number
    initial: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestCheckerAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RequestCheckerSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RequestCheckerMinAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    initial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCheckerMaxAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    initial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCheckerCountAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    initial?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestCheckerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestChecker to aggregate.
     */
    where?: RequestCheckerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCheckers to fetch.
     */
    orderBy?: RequestCheckerOrderByWithRelationInput | RequestCheckerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestCheckerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCheckers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCheckers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestCheckers
    **/
    _count?: true | RequestCheckerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestCheckerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestCheckerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestCheckerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestCheckerMaxAggregateInputType
  }

  export type GetRequestCheckerAggregateType<T extends RequestCheckerAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestChecker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestChecker[P]>
      : GetScalarType<T[P], AggregateRequestChecker[P]>
  }




  export type RequestCheckerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestCheckerWhereInput
    orderBy?: RequestCheckerOrderByWithAggregationInput | RequestCheckerOrderByWithAggregationInput[]
    by: RequestCheckerScalarFieldEnum[] | RequestCheckerScalarFieldEnum
    having?: RequestCheckerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCheckerCountAggregateInputType | true
    _avg?: RequestCheckerAvgAggregateInputType
    _sum?: RequestCheckerSumAggregateInputType
    _min?: RequestCheckerMinAggregateInputType
    _max?: RequestCheckerMaxAggregateInputType
  }

  export type RequestCheckerGroupByOutputType = {
    id: number
    userId: number | null
    position: string
    initial: string
    createdAt: Date
    updatedAt: Date
    _count: RequestCheckerCountAggregateOutputType | null
    _avg: RequestCheckerAvgAggregateOutputType | null
    _sum: RequestCheckerSumAggregateOutputType | null
    _min: RequestCheckerMinAggregateOutputType | null
    _max: RequestCheckerMaxAggregateOutputType | null
  }

  type GetRequestCheckerGroupByPayload<T extends RequestCheckerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestCheckerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestCheckerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestCheckerGroupByOutputType[P]>
            : GetScalarType<T[P], RequestCheckerGroupByOutputType[P]>
        }
      >
    >


  export type RequestCheckerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    position?: boolean
    initial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
    notedByForTypes?: boolean | RequestChecker$notedByForTypesArgs<ExtArgs>
    checkedByForTypes?: boolean | RequestChecker$checkedByForTypesArgs<ExtArgs>
    checkedBy2ForTypes?: boolean | RequestChecker$checkedBy2ForTypesArgs<ExtArgs>
    recomApprovalForTypes?: boolean | RequestChecker$recomApprovalForTypesArgs<ExtArgs>
    recomApproval2ForTypes?: boolean | RequestChecker$recomApproval2ForTypesArgs<ExtArgs>
    approveByForTypes?: boolean | RequestChecker$approveByForTypesArgs<ExtArgs>
    formRequestFundTo?: boolean | RequestChecker$formRequestFundToArgs<ExtArgs>
    requestLogs?: boolean | RequestChecker$requestLogsArgs<ExtArgs>
    _count?: boolean | RequestCheckerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestChecker"]>

  export type RequestCheckerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    position?: boolean
    initial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
  }, ExtArgs["result"]["requestChecker"]>

  export type RequestCheckerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    position?: boolean
    initial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
  }, ExtArgs["result"]["requestChecker"]>

  export type RequestCheckerSelectScalar = {
    id?: boolean
    userId?: boolean
    position?: boolean
    initial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequestCheckerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "position" | "initial" | "createdAt" | "updatedAt", ExtArgs["result"]["requestChecker"]>
  export type RequestCheckerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
    notedByForTypes?: boolean | RequestChecker$notedByForTypesArgs<ExtArgs>
    checkedByForTypes?: boolean | RequestChecker$checkedByForTypesArgs<ExtArgs>
    checkedBy2ForTypes?: boolean | RequestChecker$checkedBy2ForTypesArgs<ExtArgs>
    recomApprovalForTypes?: boolean | RequestChecker$recomApprovalForTypesArgs<ExtArgs>
    recomApproval2ForTypes?: boolean | RequestChecker$recomApproval2ForTypesArgs<ExtArgs>
    approveByForTypes?: boolean | RequestChecker$approveByForTypesArgs<ExtArgs>
    formRequestFundTo?: boolean | RequestChecker$formRequestFundToArgs<ExtArgs>
    requestLogs?: boolean | RequestChecker$requestLogsArgs<ExtArgs>
    _count?: boolean | RequestCheckerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestCheckerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
  }
  export type RequestCheckerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkerName?: boolean | RequestChecker$checkerNameArgs<ExtArgs>
  }

  export type $RequestCheckerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestChecker"
    objects: {
      checkerName: Prisma.$UserPayload<ExtArgs> | null
      notedByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      checkedByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      checkedBy2ForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      recomApprovalForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      recomApproval2ForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      approveByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      formRequestFundTo: Prisma.$FormFundTransferPayload<ExtArgs>[]
      requestLogs: Prisma.$RequestLogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      position: string
      initial: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requestChecker"]>
    composites: {}
  }

  type RequestCheckerGetPayload<S extends boolean | null | undefined | RequestCheckerDefaultArgs> = $Result.GetResult<Prisma.$RequestCheckerPayload, S>

  type RequestCheckerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestCheckerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCheckerCountAggregateInputType | true
    }

  export interface RequestCheckerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestChecker'], meta: { name: 'RequestChecker' } }
    /**
     * Find zero or one RequestChecker that matches the filter.
     * @param {RequestCheckerFindUniqueArgs} args - Arguments to find a RequestChecker
     * @example
     * // Get one RequestChecker
     * const requestChecker = await prisma.requestChecker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestCheckerFindUniqueArgs>(args: SelectSubset<T, RequestCheckerFindUniqueArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestChecker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestCheckerFindUniqueOrThrowArgs} args - Arguments to find a RequestChecker
     * @example
     * // Get one RequestChecker
     * const requestChecker = await prisma.requestChecker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestCheckerFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestCheckerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestChecker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerFindFirstArgs} args - Arguments to find a RequestChecker
     * @example
     * // Get one RequestChecker
     * const requestChecker = await prisma.requestChecker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestCheckerFindFirstArgs>(args?: SelectSubset<T, RequestCheckerFindFirstArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestChecker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerFindFirstOrThrowArgs} args - Arguments to find a RequestChecker
     * @example
     * // Get one RequestChecker
     * const requestChecker = await prisma.requestChecker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestCheckerFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestCheckerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestCheckers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestCheckers
     * const requestCheckers = await prisma.requestChecker.findMany()
     * 
     * // Get first 10 RequestCheckers
     * const requestCheckers = await prisma.requestChecker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestCheckerWithIdOnly = await prisma.requestChecker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestCheckerFindManyArgs>(args?: SelectSubset<T, RequestCheckerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestChecker.
     * @param {RequestCheckerCreateArgs} args - Arguments to create a RequestChecker.
     * @example
     * // Create one RequestChecker
     * const RequestChecker = await prisma.requestChecker.create({
     *   data: {
     *     // ... data to create a RequestChecker
     *   }
     * })
     * 
     */
    create<T extends RequestCheckerCreateArgs>(args: SelectSubset<T, RequestCheckerCreateArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestCheckers.
     * @param {RequestCheckerCreateManyArgs} args - Arguments to create many RequestCheckers.
     * @example
     * // Create many RequestCheckers
     * const requestChecker = await prisma.requestChecker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCheckerCreateManyArgs>(args?: SelectSubset<T, RequestCheckerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestCheckers and returns the data saved in the database.
     * @param {RequestCheckerCreateManyAndReturnArgs} args - Arguments to create many RequestCheckers.
     * @example
     * // Create many RequestCheckers
     * const requestChecker = await prisma.requestChecker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestCheckers and only return the `id`
     * const requestCheckerWithIdOnly = await prisma.requestChecker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCheckerCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCheckerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestChecker.
     * @param {RequestCheckerDeleteArgs} args - Arguments to delete one RequestChecker.
     * @example
     * // Delete one RequestChecker
     * const RequestChecker = await prisma.requestChecker.delete({
     *   where: {
     *     // ... filter to delete one RequestChecker
     *   }
     * })
     * 
     */
    delete<T extends RequestCheckerDeleteArgs>(args: SelectSubset<T, RequestCheckerDeleteArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestChecker.
     * @param {RequestCheckerUpdateArgs} args - Arguments to update one RequestChecker.
     * @example
     * // Update one RequestChecker
     * const requestChecker = await prisma.requestChecker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestCheckerUpdateArgs>(args: SelectSubset<T, RequestCheckerUpdateArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestCheckers.
     * @param {RequestCheckerDeleteManyArgs} args - Arguments to filter RequestCheckers to delete.
     * @example
     * // Delete a few RequestCheckers
     * const { count } = await prisma.requestChecker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestCheckerDeleteManyArgs>(args?: SelectSubset<T, RequestCheckerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestCheckers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestCheckers
     * const requestChecker = await prisma.requestChecker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestCheckerUpdateManyArgs>(args: SelectSubset<T, RequestCheckerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestCheckers and returns the data updated in the database.
     * @param {RequestCheckerUpdateManyAndReturnArgs} args - Arguments to update many RequestCheckers.
     * @example
     * // Update many RequestCheckers
     * const requestChecker = await prisma.requestChecker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestCheckers and only return the `id`
     * const requestCheckerWithIdOnly = await prisma.requestChecker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestCheckerUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestCheckerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestChecker.
     * @param {RequestCheckerUpsertArgs} args - Arguments to update or create a RequestChecker.
     * @example
     * // Update or create a RequestChecker
     * const requestChecker = await prisma.requestChecker.upsert({
     *   create: {
     *     // ... data to create a RequestChecker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestChecker we want to update
     *   }
     * })
     */
    upsert<T extends RequestCheckerUpsertArgs>(args: SelectSubset<T, RequestCheckerUpsertArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestCheckers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerCountArgs} args - Arguments to filter RequestCheckers to count.
     * @example
     * // Count the number of RequestCheckers
     * const count = await prisma.requestChecker.count({
     *   where: {
     *     // ... the filter for the RequestCheckers we want to count
     *   }
     * })
    **/
    count<T extends RequestCheckerCountArgs>(
      args?: Subset<T, RequestCheckerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCheckerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestChecker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestCheckerAggregateArgs>(args: Subset<T, RequestCheckerAggregateArgs>): Prisma.PrismaPromise<GetRequestCheckerAggregateType<T>>

    /**
     * Group by RequestChecker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCheckerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestCheckerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestCheckerGroupByArgs['orderBy'] }
        : { orderBy?: RequestCheckerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestCheckerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestCheckerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestChecker model
   */
  readonly fields: RequestCheckerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestChecker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestCheckerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkerName<T extends RequestChecker$checkerNameArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$checkerNameArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notedByForTypes<T extends RequestChecker$notedByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$notedByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkedByForTypes<T extends RequestChecker$checkedByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$checkedByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkedBy2ForTypes<T extends RequestChecker$checkedBy2ForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$checkedBy2ForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recomApprovalForTypes<T extends RequestChecker$recomApprovalForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$recomApprovalForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recomApproval2ForTypes<T extends RequestChecker$recomApproval2ForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$recomApproval2ForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approveByForTypes<T extends RequestChecker$approveByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$approveByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formRequestFundTo<T extends RequestChecker$formRequestFundToArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$formRequestFundToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestLogs<T extends RequestChecker$requestLogsArgs<ExtArgs> = {}>(args?: Subset<T, RequestChecker$requestLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestChecker model
   */
  interface RequestCheckerFieldRefs {
    readonly id: FieldRef<"RequestChecker", 'Int'>
    readonly userId: FieldRef<"RequestChecker", 'Int'>
    readonly position: FieldRef<"RequestChecker", 'String'>
    readonly initial: FieldRef<"RequestChecker", 'String'>
    readonly createdAt: FieldRef<"RequestChecker", 'DateTime'>
    readonly updatedAt: FieldRef<"RequestChecker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestChecker findUnique
   */
  export type RequestCheckerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter, which RequestChecker to fetch.
     */
    where: RequestCheckerWhereUniqueInput
  }

  /**
   * RequestChecker findUniqueOrThrow
   */
  export type RequestCheckerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter, which RequestChecker to fetch.
     */
    where: RequestCheckerWhereUniqueInput
  }

  /**
   * RequestChecker findFirst
   */
  export type RequestCheckerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter, which RequestChecker to fetch.
     */
    where?: RequestCheckerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCheckers to fetch.
     */
    orderBy?: RequestCheckerOrderByWithRelationInput | RequestCheckerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestCheckers.
     */
    cursor?: RequestCheckerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCheckers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCheckers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestCheckers.
     */
    distinct?: RequestCheckerScalarFieldEnum | RequestCheckerScalarFieldEnum[]
  }

  /**
   * RequestChecker findFirstOrThrow
   */
  export type RequestCheckerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter, which RequestChecker to fetch.
     */
    where?: RequestCheckerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCheckers to fetch.
     */
    orderBy?: RequestCheckerOrderByWithRelationInput | RequestCheckerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestCheckers.
     */
    cursor?: RequestCheckerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCheckers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCheckers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestCheckers.
     */
    distinct?: RequestCheckerScalarFieldEnum | RequestCheckerScalarFieldEnum[]
  }

  /**
   * RequestChecker findMany
   */
  export type RequestCheckerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter, which RequestCheckers to fetch.
     */
    where?: RequestCheckerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCheckers to fetch.
     */
    orderBy?: RequestCheckerOrderByWithRelationInput | RequestCheckerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestCheckers.
     */
    cursor?: RequestCheckerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCheckers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCheckers.
     */
    skip?: number
    distinct?: RequestCheckerScalarFieldEnum | RequestCheckerScalarFieldEnum[]
  }

  /**
   * RequestChecker create
   */
  export type RequestCheckerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestChecker.
     */
    data: XOR<RequestCheckerCreateInput, RequestCheckerUncheckedCreateInput>
  }

  /**
   * RequestChecker createMany
   */
  export type RequestCheckerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestCheckers.
     */
    data: RequestCheckerCreateManyInput | RequestCheckerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestChecker createManyAndReturn
   */
  export type RequestCheckerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * The data used to create many RequestCheckers.
     */
    data: RequestCheckerCreateManyInput | RequestCheckerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestChecker update
   */
  export type RequestCheckerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestChecker.
     */
    data: XOR<RequestCheckerUpdateInput, RequestCheckerUncheckedUpdateInput>
    /**
     * Choose, which RequestChecker to update.
     */
    where: RequestCheckerWhereUniqueInput
  }

  /**
   * RequestChecker updateMany
   */
  export type RequestCheckerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestCheckers.
     */
    data: XOR<RequestCheckerUpdateManyMutationInput, RequestCheckerUncheckedUpdateManyInput>
    /**
     * Filter which RequestCheckers to update
     */
    where?: RequestCheckerWhereInput
    /**
     * Limit how many RequestCheckers to update.
     */
    limit?: number
  }

  /**
   * RequestChecker updateManyAndReturn
   */
  export type RequestCheckerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * The data used to update RequestCheckers.
     */
    data: XOR<RequestCheckerUpdateManyMutationInput, RequestCheckerUncheckedUpdateManyInput>
    /**
     * Filter which RequestCheckers to update
     */
    where?: RequestCheckerWhereInput
    /**
     * Limit how many RequestCheckers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestChecker upsert
   */
  export type RequestCheckerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestChecker to update in case it exists.
     */
    where: RequestCheckerWhereUniqueInput
    /**
     * In case the RequestChecker found by the `where` argument doesn't exist, create a new RequestChecker with this data.
     */
    create: XOR<RequestCheckerCreateInput, RequestCheckerUncheckedCreateInput>
    /**
     * In case the RequestChecker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestCheckerUpdateInput, RequestCheckerUncheckedUpdateInput>
  }

  /**
   * RequestChecker delete
   */
  export type RequestCheckerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    /**
     * Filter which RequestChecker to delete.
     */
    where: RequestCheckerWhereUniqueInput
  }

  /**
   * RequestChecker deleteMany
   */
  export type RequestCheckerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestCheckers to delete
     */
    where?: RequestCheckerWhereInput
    /**
     * Limit how many RequestCheckers to delete.
     */
    limit?: number
  }

  /**
   * RequestChecker.checkerName
   */
  export type RequestChecker$checkerNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestChecker.notedByForTypes
   */
  export type RequestChecker$notedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.checkedByForTypes
   */
  export type RequestChecker$checkedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.checkedBy2ForTypes
   */
  export type RequestChecker$checkedBy2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.recomApprovalForTypes
   */
  export type RequestChecker$recomApprovalForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.recomApproval2ForTypes
   */
  export type RequestChecker$recomApproval2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.approveByForTypes
   */
  export type RequestChecker$approveByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestChecker.formRequestFundTo
   */
  export type RequestChecker$formRequestFundToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    where?: FormFundTransferWhereInput
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    cursor?: FormFundTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * RequestChecker.requestLogs
   */
  export type RequestChecker$requestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    cursor?: RequestLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestChecker without action
   */
  export type RequestCheckerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
  }


  /**
   * Model MainRequest
   */

  export type AggregateMainRequest = {
    _count: MainRequestCountAggregateOutputType | null
    _avg: MainRequestAvgAggregateOutputType | null
    _sum: MainRequestSumAggregateOutputType | null
    _min: MainRequestMinAggregateOutputType | null
    _max: MainRequestMaxAggregateOutputType | null
  }

  export type MainRequestAvgAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
  }

  export type MainRequestSumAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
  }

  export type MainRequestMinAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses | null
    requestDate: Date | null
    remarks: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MainRequestMaxAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses | null
    requestDate: Date | null
    remarks: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MainRequestCountAggregateOutputType = {
    id: number
    requestTypeId: number
    requestById: number
    requestFromId: number
    status: number
    requestDate: number
    remarks: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type MainRequestAvgAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
  }

  export type MainRequestSumAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
  }

  export type MainRequestMinAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
  }

  export type MainRequestMaxAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
  }

  export type MainRequestCountAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type MainRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainRequest to aggregate.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainRequests
    **/
    _count?: true | MainRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainRequestMaxAggregateInputType
  }

  export type GetMainRequestAggregateType<T extends MainRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMainRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainRequest[P]>
      : GetScalarType<T[P], AggregateMainRequest[P]>
  }




  export type MainRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithAggregationInput | MainRequestOrderByWithAggregationInput[]
    by: MainRequestScalarFieldEnum[] | MainRequestScalarFieldEnum
    having?: MainRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainRequestCountAggregateInputType | true
    _avg?: MainRequestAvgAggregateInputType
    _sum?: MainRequestSumAggregateInputType
    _min?: MainRequestMinAggregateInputType
    _max?: MainRequestMaxAggregateInputType
  }

  export type MainRequestGroupByOutputType = {
    id: number
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses
    requestDate: Date
    remarks: string | null
    createdAt: Date
    updateAt: Date
    _count: MainRequestCountAggregateOutputType | null
    _avg: MainRequestAvgAggregateOutputType | null
    _sum: MainRequestSumAggregateOutputType | null
    _min: MainRequestMinAggregateOutputType | null
    _max: MainRequestMaxAggregateOutputType | null
  }

  type GetMainRequestGroupByPayload<T extends MainRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MainRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MainRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MainRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MainRequestGroupByOutputType[P]>
        }
      >
    >


  export type MainRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    fundTransfer?: boolean | MainRequest$fundTransferArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
    approval?: boolean | MainRequest$approvalArgs<ExtArgs>
    _count?: boolean | MainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectScalar = {
    id?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type MainRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestTypeId" | "requestById" | "requestFromId" | "status" | "requestDate" | "remarks" | "createdAt" | "updateAt", ExtArgs["result"]["mainRequest"]>
  export type MainRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    fundTransfer?: boolean | MainRequest$fundTransferArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
    approval?: boolean | MainRequest$approvalArgs<ExtArgs>
    _count?: boolean | MainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MainRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }
  export type MainRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }

  export type $MainRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MainRequest"
    objects: {
      requestType: Prisma.$RequestTypePayload<ExtArgs> | null
      fundTransfer: Prisma.$FormFundTransferPayload<ExtArgs> | null
      requestBy: Prisma.$UserPayload<ExtArgs> | null
      requestFrom: Prisma.$BranchPayload<ExtArgs> | null
      approval: Prisma.$ApprovalTablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestTypeId: number | null
      requestById: number | null
      requestFromId: number | null
      status: $Enums.Statuses
      requestDate: Date
      remarks: string | null
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["mainRequest"]>
    composites: {}
  }

  type MainRequestGetPayload<S extends boolean | null | undefined | MainRequestDefaultArgs> = $Result.GetResult<Prisma.$MainRequestPayload, S>

  type MainRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MainRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MainRequestCountAggregateInputType | true
    }

  export interface MainRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MainRequest'], meta: { name: 'MainRequest' } }
    /**
     * Find zero or one MainRequest that matches the filter.
     * @param {MainRequestFindUniqueArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MainRequestFindUniqueArgs>(args: SelectSubset<T, MainRequestFindUniqueArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MainRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MainRequestFindUniqueOrThrowArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MainRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MainRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindFirstArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MainRequestFindFirstArgs>(args?: SelectSubset<T, MainRequestFindFirstArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindFirstOrThrowArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MainRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MainRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MainRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainRequests
     * const mainRequests = await prisma.mainRequest.findMany()
     * 
     * // Get first 10 MainRequests
     * const mainRequests = await prisma.mainRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MainRequestFindManyArgs>(args?: SelectSubset<T, MainRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MainRequest.
     * @param {MainRequestCreateArgs} args - Arguments to create a MainRequest.
     * @example
     * // Create one MainRequest
     * const MainRequest = await prisma.mainRequest.create({
     *   data: {
     *     // ... data to create a MainRequest
     *   }
     * })
     * 
     */
    create<T extends MainRequestCreateArgs>(args: SelectSubset<T, MainRequestCreateArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MainRequests.
     * @param {MainRequestCreateManyArgs} args - Arguments to create many MainRequests.
     * @example
     * // Create many MainRequests
     * const mainRequest = await prisma.mainRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MainRequestCreateManyArgs>(args?: SelectSubset<T, MainRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MainRequests and returns the data saved in the database.
     * @param {MainRequestCreateManyAndReturnArgs} args - Arguments to create many MainRequests.
     * @example
     * // Create many MainRequests
     * const mainRequest = await prisma.mainRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MainRequests and only return the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MainRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MainRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MainRequest.
     * @param {MainRequestDeleteArgs} args - Arguments to delete one MainRequest.
     * @example
     * // Delete one MainRequest
     * const MainRequest = await prisma.mainRequest.delete({
     *   where: {
     *     // ... filter to delete one MainRequest
     *   }
     * })
     * 
     */
    delete<T extends MainRequestDeleteArgs>(args: SelectSubset<T, MainRequestDeleteArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MainRequest.
     * @param {MainRequestUpdateArgs} args - Arguments to update one MainRequest.
     * @example
     * // Update one MainRequest
     * const mainRequest = await prisma.mainRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MainRequestUpdateArgs>(args: SelectSubset<T, MainRequestUpdateArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MainRequests.
     * @param {MainRequestDeleteManyArgs} args - Arguments to filter MainRequests to delete.
     * @example
     * // Delete a few MainRequests
     * const { count } = await prisma.mainRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MainRequestDeleteManyArgs>(args?: SelectSubset<T, MainRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainRequests
     * const mainRequest = await prisma.mainRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MainRequestUpdateManyArgs>(args: SelectSubset<T, MainRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainRequests and returns the data updated in the database.
     * @param {MainRequestUpdateManyAndReturnArgs} args - Arguments to update many MainRequests.
     * @example
     * // Update many MainRequests
     * const mainRequest = await prisma.mainRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MainRequests and only return the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MainRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MainRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MainRequest.
     * @param {MainRequestUpsertArgs} args - Arguments to update or create a MainRequest.
     * @example
     * // Update or create a MainRequest
     * const mainRequest = await prisma.mainRequest.upsert({
     *   create: {
     *     // ... data to create a MainRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainRequest we want to update
     *   }
     * })
     */
    upsert<T extends MainRequestUpsertArgs>(args: SelectSubset<T, MainRequestUpsertArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestCountArgs} args - Arguments to filter MainRequests to count.
     * @example
     * // Count the number of MainRequests
     * const count = await prisma.mainRequest.count({
     *   where: {
     *     // ... the filter for the MainRequests we want to count
     *   }
     * })
    **/
    count<T extends MainRequestCountArgs>(
      args?: Subset<T, MainRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainRequestAggregateArgs>(args: Subset<T, MainRequestAggregateArgs>): Prisma.PrismaPromise<GetMainRequestAggregateType<T>>

    /**
     * Group by MainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainRequestGroupByArgs['orderBy'] }
        : { orderBy?: MainRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MainRequest model
   */
  readonly fields: MainRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MainRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MainRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestType<T extends MainRequest$requestTypeArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestTypeArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fundTransfer<T extends MainRequest$fundTransferArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$fundTransferArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestBy<T extends MainRequest$requestByArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestFrom<T extends MainRequest$requestFromArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestFromArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approval<T extends MainRequest$approvalArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$approvalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MainRequest model
   */
  interface MainRequestFieldRefs {
    readonly id: FieldRef<"MainRequest", 'Int'>
    readonly requestTypeId: FieldRef<"MainRequest", 'Int'>
    readonly requestById: FieldRef<"MainRequest", 'Int'>
    readonly requestFromId: FieldRef<"MainRequest", 'Int'>
    readonly status: FieldRef<"MainRequest", 'Statuses'>
    readonly requestDate: FieldRef<"MainRequest", 'DateTime'>
    readonly remarks: FieldRef<"MainRequest", 'String'>
    readonly createdAt: FieldRef<"MainRequest", 'DateTime'>
    readonly updateAt: FieldRef<"MainRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MainRequest findUnique
   */
  export type MainRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest findUniqueOrThrow
   */
  export type MainRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest findFirst
   */
  export type MainRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainRequests.
     */
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest findFirstOrThrow
   */
  export type MainRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainRequests.
     */
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest findMany
   */
  export type MainRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequests to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest create
   */
  export type MainRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MainRequest.
     */
    data: XOR<MainRequestCreateInput, MainRequestUncheckedCreateInput>
  }

  /**
   * MainRequest createMany
   */
  export type MainRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MainRequests.
     */
    data: MainRequestCreateManyInput | MainRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MainRequest createManyAndReturn
   */
  export type MainRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MainRequests.
     */
    data: MainRequestCreateManyInput | MainRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainRequest update
   */
  export type MainRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MainRequest.
     */
    data: XOR<MainRequestUpdateInput, MainRequestUncheckedUpdateInput>
    /**
     * Choose, which MainRequest to update.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest updateMany
   */
  export type MainRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MainRequests.
     */
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyInput>
    /**
     * Filter which MainRequests to update
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to update.
     */
    limit?: number
  }

  /**
   * MainRequest updateManyAndReturn
   */
  export type MainRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * The data used to update MainRequests.
     */
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyInput>
    /**
     * Filter which MainRequests to update
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainRequest upsert
   */
  export type MainRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MainRequest to update in case it exists.
     */
    where: MainRequestWhereUniqueInput
    /**
     * In case the MainRequest found by the `where` argument doesn't exist, create a new MainRequest with this data.
     */
    create: XOR<MainRequestCreateInput, MainRequestUncheckedCreateInput>
    /**
     * In case the MainRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MainRequestUpdateInput, MainRequestUncheckedUpdateInput>
  }

  /**
   * MainRequest delete
   */
  export type MainRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter which MainRequest to delete.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest deleteMany
   */
  export type MainRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainRequests to delete
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to delete.
     */
    limit?: number
  }

  /**
   * MainRequest.requestType
   */
  export type MainRequest$requestTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
  }

  /**
   * MainRequest.fundTransfer
   */
  export type MainRequest$fundTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    where?: FormFundTransferWhereInput
  }

  /**
   * MainRequest.requestBy
   */
  export type MainRequest$requestByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MainRequest.requestFrom
   */
  export type MainRequest$requestFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MainRequest.approval
   */
  export type MainRequest$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    where?: ApprovalTableWhereInput
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    cursor?: ApprovalTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * MainRequest without action
   */
  export type MainRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
  }


  /**
   * Model FormFundTransfer
   */

  export type AggregateFormFundTransfer = {
    _count: FormFundTransferCountAggregateOutputType | null
    _avg: FormFundTransferAvgAggregateOutputType | null
    _sum: FormFundTransferSumAggregateOutputType | null
    _min: FormFundTransferMinAggregateOutputType | null
    _max: FormFundTransferMaxAggregateOutputType | null
  }

  export type FormFundTransferAvgAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
  }

  export type FormFundTransferSumAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
  }

  export type FormFundTransferMinAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FormFundTransferMaxAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FormFundTransferCountAggregateOutputType = {
    id: number
    mainRequestID: number
    requestToId: number
    requestContent: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type FormFundTransferAvgAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
  }

  export type FormFundTransferSumAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
  }

  export type FormFundTransferMinAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
  }

  export type FormFundTransferMaxAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
  }

  export type FormFundTransferCountAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type FormFundTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFundTransfer to aggregate.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormFundTransfers
    **/
    _count?: true | FormFundTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormFundTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormFundTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormFundTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormFundTransferMaxAggregateInputType
  }

  export type GetFormFundTransferAggregateType<T extends FormFundTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateFormFundTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormFundTransfer[P]>
      : GetScalarType<T[P], AggregateFormFundTransfer[P]>
  }




  export type FormFundTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFundTransferWhereInput
    orderBy?: FormFundTransferOrderByWithAggregationInput | FormFundTransferOrderByWithAggregationInput[]
    by: FormFundTransferScalarFieldEnum[] | FormFundTransferScalarFieldEnum
    having?: FormFundTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormFundTransferCountAggregateInputType | true
    _avg?: FormFundTransferAvgAggregateInputType
    _sum?: FormFundTransferSumAggregateInputType
    _min?: FormFundTransferMinAggregateInputType
    _max?: FormFundTransferMaxAggregateInputType
  }

  export type FormFundTransferGroupByOutputType = {
    id: number
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string
    createdAt: Date
    updateAt: Date
    _count: FormFundTransferCountAggregateOutputType | null
    _avg: FormFundTransferAvgAggregateOutputType | null
    _sum: FormFundTransferSumAggregateOutputType | null
    _min: FormFundTransferMinAggregateOutputType | null
    _max: FormFundTransferMaxAggregateOutputType | null
  }

  type GetFormFundTransferGroupByPayload<T extends FormFundTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormFundTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormFundTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormFundTransferGroupByOutputType[P]>
            : GetScalarType<T[P], FormFundTransferGroupByOutputType[P]>
        }
      >
    >


  export type FormFundTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectScalar = {
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type FormFundTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mainRequestID" | "requestToId" | "requestContent" | "createdAt" | "updateAt", ExtArgs["result"]["formFundTransfer"]>
  export type FormFundTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }
  export type FormFundTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }
  export type FormFundTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }

  export type $FormFundTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormFundTransfer"
    objects: {
      mainRequest: Prisma.$MainRequestPayload<ExtArgs> | null
      requestTo: Prisma.$RequestCheckerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mainRequestID: number | null
      requestToId: number | null
      requestContent: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["formFundTransfer"]>
    composites: {}
  }

  type FormFundTransferGetPayload<S extends boolean | null | undefined | FormFundTransferDefaultArgs> = $Result.GetResult<Prisma.$FormFundTransferPayload, S>

  type FormFundTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFundTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormFundTransferCountAggregateInputType | true
    }

  export interface FormFundTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormFundTransfer'], meta: { name: 'FormFundTransfer' } }
    /**
     * Find zero or one FormFundTransfer that matches the filter.
     * @param {FormFundTransferFindUniqueArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFundTransferFindUniqueArgs>(args: SelectSubset<T, FormFundTransferFindUniqueArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormFundTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFundTransferFindUniqueOrThrowArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFundTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFundTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFundTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindFirstArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFundTransferFindFirstArgs>(args?: SelectSubset<T, FormFundTransferFindFirstArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFundTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindFirstOrThrowArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFundTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFundTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormFundTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormFundTransfers
     * const formFundTransfers = await prisma.formFundTransfer.findMany()
     * 
     * // Get first 10 FormFundTransfers
     * const formFundTransfers = await prisma.formFundTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFundTransferFindManyArgs>(args?: SelectSubset<T, FormFundTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormFundTransfer.
     * @param {FormFundTransferCreateArgs} args - Arguments to create a FormFundTransfer.
     * @example
     * // Create one FormFundTransfer
     * const FormFundTransfer = await prisma.formFundTransfer.create({
     *   data: {
     *     // ... data to create a FormFundTransfer
     *   }
     * })
     * 
     */
    create<T extends FormFundTransferCreateArgs>(args: SelectSubset<T, FormFundTransferCreateArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormFundTransfers.
     * @param {FormFundTransferCreateManyArgs} args - Arguments to create many FormFundTransfers.
     * @example
     * // Create many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormFundTransferCreateManyArgs>(args?: SelectSubset<T, FormFundTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormFundTransfers and returns the data saved in the database.
     * @param {FormFundTransferCreateManyAndReturnArgs} args - Arguments to create many FormFundTransfers.
     * @example
     * // Create many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormFundTransfers and only return the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormFundTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, FormFundTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormFundTransfer.
     * @param {FormFundTransferDeleteArgs} args - Arguments to delete one FormFundTransfer.
     * @example
     * // Delete one FormFundTransfer
     * const FormFundTransfer = await prisma.formFundTransfer.delete({
     *   where: {
     *     // ... filter to delete one FormFundTransfer
     *   }
     * })
     * 
     */
    delete<T extends FormFundTransferDeleteArgs>(args: SelectSubset<T, FormFundTransferDeleteArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormFundTransfer.
     * @param {FormFundTransferUpdateArgs} args - Arguments to update one FormFundTransfer.
     * @example
     * // Update one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormFundTransferUpdateArgs>(args: SelectSubset<T, FormFundTransferUpdateArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormFundTransfers.
     * @param {FormFundTransferDeleteManyArgs} args - Arguments to filter FormFundTransfers to delete.
     * @example
     * // Delete a few FormFundTransfers
     * const { count } = await prisma.formFundTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormFundTransferDeleteManyArgs>(args?: SelectSubset<T, FormFundTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFundTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormFundTransferUpdateManyArgs>(args: SelectSubset<T, FormFundTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFundTransfers and returns the data updated in the database.
     * @param {FormFundTransferUpdateManyAndReturnArgs} args - Arguments to update many FormFundTransfers.
     * @example
     * // Update many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormFundTransfers and only return the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormFundTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, FormFundTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormFundTransfer.
     * @param {FormFundTransferUpsertArgs} args - Arguments to update or create a FormFundTransfer.
     * @example
     * // Update or create a FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.upsert({
     *   create: {
     *     // ... data to create a FormFundTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormFundTransfer we want to update
     *   }
     * })
     */
    upsert<T extends FormFundTransferUpsertArgs>(args: SelectSubset<T, FormFundTransferUpsertArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormFundTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferCountArgs} args - Arguments to filter FormFundTransfers to count.
     * @example
     * // Count the number of FormFundTransfers
     * const count = await prisma.formFundTransfer.count({
     *   where: {
     *     // ... the filter for the FormFundTransfers we want to count
     *   }
     * })
    **/
    count<T extends FormFundTransferCountArgs>(
      args?: Subset<T, FormFundTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormFundTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormFundTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormFundTransferAggregateArgs>(args: Subset<T, FormFundTransferAggregateArgs>): Prisma.PrismaPromise<GetFormFundTransferAggregateType<T>>

    /**
     * Group by FormFundTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormFundTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormFundTransferGroupByArgs['orderBy'] }
        : { orderBy?: FormFundTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormFundTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormFundTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormFundTransfer model
   */
  readonly fields: FormFundTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormFundTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormFundTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainRequest<T extends FormFundTransfer$mainRequestArgs<ExtArgs> = {}>(args?: Subset<T, FormFundTransfer$mainRequestArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestTo<T extends FormFundTransfer$requestToArgs<ExtArgs> = {}>(args?: Subset<T, FormFundTransfer$requestToArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormFundTransfer model
   */
  interface FormFundTransferFieldRefs {
    readonly id: FieldRef<"FormFundTransfer", 'Int'>
    readonly mainRequestID: FieldRef<"FormFundTransfer", 'Int'>
    readonly requestToId: FieldRef<"FormFundTransfer", 'Int'>
    readonly requestContent: FieldRef<"FormFundTransfer", 'String'>
    readonly createdAt: FieldRef<"FormFundTransfer", 'DateTime'>
    readonly updateAt: FieldRef<"FormFundTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormFundTransfer findUnique
   */
  export type FormFundTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer findUniqueOrThrow
   */
  export type FormFundTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer findFirst
   */
  export type FormFundTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFundTransfers.
     */
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer findFirstOrThrow
   */
  export type FormFundTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFundTransfers.
     */
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer findMany
   */
  export type FormFundTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfers to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer create
   */
  export type FormFundTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a FormFundTransfer.
     */
    data: XOR<FormFundTransferCreateInput, FormFundTransferUncheckedCreateInput>
  }

  /**
   * FormFundTransfer createMany
   */
  export type FormFundTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormFundTransfers.
     */
    data: FormFundTransferCreateManyInput | FormFundTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormFundTransfer createManyAndReturn
   */
  export type FormFundTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * The data used to create many FormFundTransfers.
     */
    data: FormFundTransferCreateManyInput | FormFundTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFundTransfer update
   */
  export type FormFundTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a FormFundTransfer.
     */
    data: XOR<FormFundTransferUpdateInput, FormFundTransferUncheckedUpdateInput>
    /**
     * Choose, which FormFundTransfer to update.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer updateMany
   */
  export type FormFundTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormFundTransfers.
     */
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyInput>
    /**
     * Filter which FormFundTransfers to update
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to update.
     */
    limit?: number
  }

  /**
   * FormFundTransfer updateManyAndReturn
   */
  export type FormFundTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * The data used to update FormFundTransfers.
     */
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyInput>
    /**
     * Filter which FormFundTransfers to update
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFundTransfer upsert
   */
  export type FormFundTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the FormFundTransfer to update in case it exists.
     */
    where: FormFundTransferWhereUniqueInput
    /**
     * In case the FormFundTransfer found by the `where` argument doesn't exist, create a new FormFundTransfer with this data.
     */
    create: XOR<FormFundTransferCreateInput, FormFundTransferUncheckedCreateInput>
    /**
     * In case the FormFundTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormFundTransferUpdateInput, FormFundTransferUncheckedUpdateInput>
  }

  /**
   * FormFundTransfer delete
   */
  export type FormFundTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter which FormFundTransfer to delete.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer deleteMany
   */
  export type FormFundTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFundTransfers to delete
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to delete.
     */
    limit?: number
  }

  /**
   * FormFundTransfer.mainRequest
   */
  export type FormFundTransfer$mainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * FormFundTransfer.requestTo
   */
  export type FormFundTransfer$requestToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * FormFundTransfer without action
   */
  export type FormFundTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalTable
   */

  export type AggregateApprovalTable = {
    _count: ApprovalTableCountAggregateOutputType | null
    _avg: ApprovalTableAvgAggregateOutputType | null
    _sum: ApprovalTableSumAggregateOutputType | null
    _min: ApprovalTableMinAggregateOutputType | null
    _max: ApprovalTableMaxAggregateOutputType | null
  }

  export type ApprovalTableAvgAggregateOutputType = {
    id: number | null
    mainFormId: number | null
  }

  export type ApprovalTableSumAggregateOutputType = {
    id: number | null
    mainFormId: number | null
  }

  export type ApprovalTableMinAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    notedBy: $Enums.Statuses | null
    checkedBy: $Enums.Statuses | null
    checkedBy2: $Enums.Statuses | null
    recomApproval: $Enums.Statuses | null
    recomApproval2: $Enums.Statuses | null
    approveBy: $Enums.Statuses | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ApprovalTableMaxAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    notedBy: $Enums.Statuses | null
    checkedBy: $Enums.Statuses | null
    checkedBy2: $Enums.Statuses | null
    recomApproval: $Enums.Statuses | null
    recomApproval2: $Enums.Statuses | null
    approveBy: $Enums.Statuses | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ApprovalTableCountAggregateOutputType = {
    id: number
    mainFormId: number
    notedBy: number
    checkedBy: number
    checkedBy2: number
    recomApproval: number
    recomApproval2: number
    approveBy: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type ApprovalTableAvgAggregateInputType = {
    id?: true
    mainFormId?: true
  }

  export type ApprovalTableSumAggregateInputType = {
    id?: true
    mainFormId?: true
  }

  export type ApprovalTableMinAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
  }

  export type ApprovalTableMaxAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
  }

  export type ApprovalTableCountAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type ApprovalTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTable to aggregate.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalTables
    **/
    _count?: true | ApprovalTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalTableMaxAggregateInputType
  }

  export type GetApprovalTableAggregateType<T extends ApprovalTableAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalTable[P]>
      : GetScalarType<T[P], AggregateApprovalTable[P]>
  }




  export type ApprovalTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTableWhereInput
    orderBy?: ApprovalTableOrderByWithAggregationInput | ApprovalTableOrderByWithAggregationInput[]
    by: ApprovalTableScalarFieldEnum[] | ApprovalTableScalarFieldEnum
    having?: ApprovalTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalTableCountAggregateInputType | true
    _avg?: ApprovalTableAvgAggregateInputType
    _sum?: ApprovalTableSumAggregateInputType
    _min?: ApprovalTableMinAggregateInputType
    _max?: ApprovalTableMaxAggregateInputType
  }

  export type ApprovalTableGroupByOutputType = {
    id: number
    mainFormId: number | null
    notedBy: $Enums.Statuses
    checkedBy: $Enums.Statuses
    checkedBy2: $Enums.Statuses
    recomApproval: $Enums.Statuses
    recomApproval2: $Enums.Statuses
    approveBy: $Enums.Statuses
    createdAt: Date
    updateAt: Date
    _count: ApprovalTableCountAggregateOutputType | null
    _avg: ApprovalTableAvgAggregateOutputType | null
    _sum: ApprovalTableSumAggregateOutputType | null
    _min: ApprovalTableMinAggregateOutputType | null
    _max: ApprovalTableMaxAggregateOutputType | null
  }

  type GetApprovalTableGroupByPayload<T extends ApprovalTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalTableGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalTableGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
    requestLogs?: boolean | ApprovalTable$requestLogsArgs<ExtArgs>
    _count?: boolean | ApprovalTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectScalar = {
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type ApprovalTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mainFormId" | "notedBy" | "checkedBy" | "checkedBy2" | "recomApproval" | "recomApproval2" | "approveBy" | "createdAt" | "updateAt", ExtArgs["result"]["approvalTable"]>
  export type ApprovalTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
    requestLogs?: boolean | ApprovalTable$requestLogsArgs<ExtArgs>
    _count?: boolean | ApprovalTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }
  export type ApprovalTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }

  export type $ApprovalTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalTable"
    objects: {
      mainRequest: Prisma.$MainRequestPayload<ExtArgs> | null
      requestLogs: Prisma.$RequestLogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mainFormId: number | null
      notedBy: $Enums.Statuses
      checkedBy: $Enums.Statuses
      checkedBy2: $Enums.Statuses
      recomApproval: $Enums.Statuses
      recomApproval2: $Enums.Statuses
      approveBy: $Enums.Statuses
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["approvalTable"]>
    composites: {}
  }

  type ApprovalTableGetPayload<S extends boolean | null | undefined | ApprovalTableDefaultArgs> = $Result.GetResult<Prisma.$ApprovalTablePayload, S>

  type ApprovalTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalTableCountAggregateInputType | true
    }

  export interface ApprovalTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalTable'], meta: { name: 'ApprovalTable' } }
    /**
     * Find zero or one ApprovalTable that matches the filter.
     * @param {ApprovalTableFindUniqueArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalTableFindUniqueArgs>(args: SelectSubset<T, ApprovalTableFindUniqueArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovalTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalTableFindUniqueOrThrowArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalTableFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindFirstArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalTableFindFirstArgs>(args?: SelectSubset<T, ApprovalTableFindFirstArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindFirstOrThrowArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalTableFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovalTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalTables
     * const approvalTables = await prisma.approvalTable.findMany()
     * 
     * // Get first 10 ApprovalTables
     * const approvalTables = await prisma.approvalTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalTableFindManyArgs>(args?: SelectSubset<T, ApprovalTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovalTable.
     * @param {ApprovalTableCreateArgs} args - Arguments to create a ApprovalTable.
     * @example
     * // Create one ApprovalTable
     * const ApprovalTable = await prisma.approvalTable.create({
     *   data: {
     *     // ... data to create a ApprovalTable
     *   }
     * })
     * 
     */
    create<T extends ApprovalTableCreateArgs>(args: SelectSubset<T, ApprovalTableCreateArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovalTables.
     * @param {ApprovalTableCreateManyArgs} args - Arguments to create many ApprovalTables.
     * @example
     * // Create many ApprovalTables
     * const approvalTable = await prisma.approvalTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalTableCreateManyArgs>(args?: SelectSubset<T, ApprovalTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalTables and returns the data saved in the database.
     * @param {ApprovalTableCreateManyAndReturnArgs} args - Arguments to create many ApprovalTables.
     * @example
     * // Create many ApprovalTables
     * const approvalTable = await prisma.approvalTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalTables and only return the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalTableCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApprovalTable.
     * @param {ApprovalTableDeleteArgs} args - Arguments to delete one ApprovalTable.
     * @example
     * // Delete one ApprovalTable
     * const ApprovalTable = await prisma.approvalTable.delete({
     *   where: {
     *     // ... filter to delete one ApprovalTable
     *   }
     * })
     * 
     */
    delete<T extends ApprovalTableDeleteArgs>(args: SelectSubset<T, ApprovalTableDeleteArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovalTable.
     * @param {ApprovalTableUpdateArgs} args - Arguments to update one ApprovalTable.
     * @example
     * // Update one ApprovalTable
     * const approvalTable = await prisma.approvalTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalTableUpdateArgs>(args: SelectSubset<T, ApprovalTableUpdateArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovalTables.
     * @param {ApprovalTableDeleteManyArgs} args - Arguments to filter ApprovalTables to delete.
     * @example
     * // Delete a few ApprovalTables
     * const { count } = await prisma.approvalTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalTableDeleteManyArgs>(args?: SelectSubset<T, ApprovalTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalTables
     * const approvalTable = await prisma.approvalTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalTableUpdateManyArgs>(args: SelectSubset<T, ApprovalTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTables and returns the data updated in the database.
     * @param {ApprovalTableUpdateManyAndReturnArgs} args - Arguments to update many ApprovalTables.
     * @example
     * // Update many ApprovalTables
     * const approvalTable = await prisma.approvalTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApprovalTables and only return the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalTableUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApprovalTable.
     * @param {ApprovalTableUpsertArgs} args - Arguments to update or create a ApprovalTable.
     * @example
     * // Update or create a ApprovalTable
     * const approvalTable = await prisma.approvalTable.upsert({
     *   create: {
     *     // ... data to create a ApprovalTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalTable we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalTableUpsertArgs>(args: SelectSubset<T, ApprovalTableUpsertArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApprovalTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableCountArgs} args - Arguments to filter ApprovalTables to count.
     * @example
     * // Count the number of ApprovalTables
     * const count = await prisma.approvalTable.count({
     *   where: {
     *     // ... the filter for the ApprovalTables we want to count
     *   }
     * })
    **/
    count<T extends ApprovalTableCountArgs>(
      args?: Subset<T, ApprovalTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalTableAggregateArgs>(args: Subset<T, ApprovalTableAggregateArgs>): Prisma.PrismaPromise<GetApprovalTableAggregateType<T>>

    /**
     * Group by ApprovalTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalTableGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalTable model
   */
  readonly fields: ApprovalTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainRequest<T extends ApprovalTable$mainRequestArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTable$mainRequestArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestLogs<T extends ApprovalTable$requestLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTable$requestLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalTable model
   */
  interface ApprovalTableFieldRefs {
    readonly id: FieldRef<"ApprovalTable", 'Int'>
    readonly mainFormId: FieldRef<"ApprovalTable", 'Int'>
    readonly notedBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly checkedBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly checkedBy2: FieldRef<"ApprovalTable", 'Statuses'>
    readonly recomApproval: FieldRef<"ApprovalTable", 'Statuses'>
    readonly recomApproval2: FieldRef<"ApprovalTable", 'Statuses'>
    readonly approveBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly createdAt: FieldRef<"ApprovalTable", 'DateTime'>
    readonly updateAt: FieldRef<"ApprovalTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalTable findUnique
   */
  export type ApprovalTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable findUniqueOrThrow
   */
  export type ApprovalTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable findFirst
   */
  export type ApprovalTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTables.
     */
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable findFirstOrThrow
   */
  export type ApprovalTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTables.
     */
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable findMany
   */
  export type ApprovalTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTables to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable create
   */
  export type ApprovalTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalTable.
     */
    data: XOR<ApprovalTableCreateInput, ApprovalTableUncheckedCreateInput>
  }

  /**
   * ApprovalTable createMany
   */
  export type ApprovalTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalTables.
     */
    data: ApprovalTableCreateManyInput | ApprovalTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalTable createManyAndReturn
   */
  export type ApprovalTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * The data used to create many ApprovalTables.
     */
    data: ApprovalTableCreateManyInput | ApprovalTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTable update
   */
  export type ApprovalTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalTable.
     */
    data: XOR<ApprovalTableUpdateInput, ApprovalTableUncheckedUpdateInput>
    /**
     * Choose, which ApprovalTable to update.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable updateMany
   */
  export type ApprovalTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalTables.
     */
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTables to update
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to update.
     */
    limit?: number
  }

  /**
   * ApprovalTable updateManyAndReturn
   */
  export type ApprovalTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * The data used to update ApprovalTables.
     */
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTables to update
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTable upsert
   */
  export type ApprovalTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalTable to update in case it exists.
     */
    where: ApprovalTableWhereUniqueInput
    /**
     * In case the ApprovalTable found by the `where` argument doesn't exist, create a new ApprovalTable with this data.
     */
    create: XOR<ApprovalTableCreateInput, ApprovalTableUncheckedCreateInput>
    /**
     * In case the ApprovalTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalTableUpdateInput, ApprovalTableUncheckedUpdateInput>
  }

  /**
   * ApprovalTable delete
   */
  export type ApprovalTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter which ApprovalTable to delete.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable deleteMany
   */
  export type ApprovalTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTables to delete
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to delete.
     */
    limit?: number
  }

  /**
   * ApprovalTable.mainRequest
   */
  export type ApprovalTable$mainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * ApprovalTable.requestLogs
   */
  export type ApprovalTable$requestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    cursor?: RequestLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * ApprovalTable without action
   */
  export type ApprovalTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
  }


  /**
   * Model RequestLogs
   */

  export type AggregateRequestLogs = {
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  export type RequestLogsAvgAggregateOutputType = {
    id: number | null
    approvalId: number | null
    approverId: number | null
  }

  export type RequestLogsSumAggregateOutputType = {
    id: number | null
    approvalId: number | null
    approverId: number | null
  }

  export type RequestLogsMinAggregateOutputType = {
    id: number | null
    approvalId: number | null
    checkerType: string | null
    approverId: number | null
    createdAt: Date | null
  }

  export type RequestLogsMaxAggregateOutputType = {
    id: number | null
    approvalId: number | null
    checkerType: string | null
    approverId: number | null
    createdAt: Date | null
  }

  export type RequestLogsCountAggregateOutputType = {
    id: number
    approvalId: number
    checkerType: number
    approverId: number
    createdAt: number
    _all: number
  }


  export type RequestLogsAvgAggregateInputType = {
    id?: true
    approvalId?: true
    approverId?: true
  }

  export type RequestLogsSumAggregateInputType = {
    id?: true
    approvalId?: true
    approverId?: true
  }

  export type RequestLogsMinAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    createdAt?: true
  }

  export type RequestLogsMaxAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    createdAt?: true
  }

  export type RequestLogsCountAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    createdAt?: true
    _all?: true
  }

  export type RequestLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestLogs to aggregate.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestLogs
    **/
    _count?: true | RequestLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestLogsMaxAggregateInputType
  }

  export type GetRequestLogsAggregateType<T extends RequestLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestLogs[P]>
      : GetScalarType<T[P], AggregateRequestLogs[P]>
  }




  export type RequestLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithAggregationInput | RequestLogsOrderByWithAggregationInput[]
    by: RequestLogsScalarFieldEnum[] | RequestLogsScalarFieldEnum
    having?: RequestLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestLogsCountAggregateInputType | true
    _avg?: RequestLogsAvgAggregateInputType
    _sum?: RequestLogsSumAggregateInputType
    _min?: RequestLogsMinAggregateInputType
    _max?: RequestLogsMaxAggregateInputType
  }

  export type RequestLogsGroupByOutputType = {
    id: number
    approvalId: number | null
    checkerType: string
    approverId: number | null
    createdAt: Date
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  type GetRequestLogsGroupByPayload<T extends RequestLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
        }
      >
    >


  export type RequestLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectScalar = {
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    createdAt?: boolean
  }

  export type RequestLogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "approvalId" | "checkerType" | "approverId" | "createdAt", ExtArgs["result"]["requestLogs"]>
  export type RequestLogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }
  export type RequestLogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }
  export type RequestLogsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }

  export type $RequestLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestLogs"
    objects: {
      approval: Prisma.$ApprovalTablePayload<ExtArgs> | null
      approver: Prisma.$RequestCheckerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      approvalId: number | null
      checkerType: string
      approverId: number | null
      createdAt: Date
    }, ExtArgs["result"]["requestLogs"]>
    composites: {}
  }

  type RequestLogsGetPayload<S extends boolean | null | undefined | RequestLogsDefaultArgs> = $Result.GetResult<Prisma.$RequestLogsPayload, S>

  type RequestLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestLogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestLogsCountAggregateInputType | true
    }

  export interface RequestLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestLogs'], meta: { name: 'RequestLogs' } }
    /**
     * Find zero or one RequestLogs that matches the filter.
     * @param {RequestLogsFindUniqueArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestLogsFindUniqueArgs>(args: SelectSubset<T, RequestLogsFindUniqueArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestLogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestLogsFindUniqueOrThrowArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindFirstArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestLogsFindFirstArgs>(args?: SelectSubset<T, RequestLogsFindFirstArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindFirstOrThrowArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany()
     * 
     * // Get first 10 RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestLogsFindManyArgs>(args?: SelectSubset<T, RequestLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestLogs.
     * @param {RequestLogsCreateArgs} args - Arguments to create a RequestLogs.
     * @example
     * // Create one RequestLogs
     * const RequestLogs = await prisma.requestLogs.create({
     *   data: {
     *     // ... data to create a RequestLogs
     *   }
     * })
     * 
     */
    create<T extends RequestLogsCreateArgs>(args: SelectSubset<T, RequestLogsCreateArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestLogs.
     * @param {RequestLogsCreateManyArgs} args - Arguments to create many RequestLogs.
     * @example
     * // Create many RequestLogs
     * const requestLogs = await prisma.requestLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestLogsCreateManyArgs>(args?: SelectSubset<T, RequestLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestLogs and returns the data saved in the database.
     * @param {RequestLogsCreateManyAndReturnArgs} args - Arguments to create many RequestLogs.
     * @example
     * // Create many RequestLogs
     * const requestLogs = await prisma.requestLogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestLogs and only return the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestLogsCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestLogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestLogs.
     * @param {RequestLogsDeleteArgs} args - Arguments to delete one RequestLogs.
     * @example
     * // Delete one RequestLogs
     * const RequestLogs = await prisma.requestLogs.delete({
     *   where: {
     *     // ... filter to delete one RequestLogs
     *   }
     * })
     * 
     */
    delete<T extends RequestLogsDeleteArgs>(args: SelectSubset<T, RequestLogsDeleteArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestLogs.
     * @param {RequestLogsUpdateArgs} args - Arguments to update one RequestLogs.
     * @example
     * // Update one RequestLogs
     * const requestLogs = await prisma.requestLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestLogsUpdateArgs>(args: SelectSubset<T, RequestLogsUpdateArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestLogs.
     * @param {RequestLogsDeleteManyArgs} args - Arguments to filter RequestLogs to delete.
     * @example
     * // Delete a few RequestLogs
     * const { count } = await prisma.requestLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestLogsDeleteManyArgs>(args?: SelectSubset<T, RequestLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestLogs
     * const requestLogs = await prisma.requestLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestLogsUpdateManyArgs>(args: SelectSubset<T, RequestLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestLogs and returns the data updated in the database.
     * @param {RequestLogsUpdateManyAndReturnArgs} args - Arguments to update many RequestLogs.
     * @example
     * // Update many RequestLogs
     * const requestLogs = await prisma.requestLogs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestLogs and only return the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestLogsUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestLogsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestLogs.
     * @param {RequestLogsUpsertArgs} args - Arguments to update or create a RequestLogs.
     * @example
     * // Update or create a RequestLogs
     * const requestLogs = await prisma.requestLogs.upsert({
     *   create: {
     *     // ... data to create a RequestLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestLogs we want to update
     *   }
     * })
     */
    upsert<T extends RequestLogsUpsertArgs>(args: SelectSubset<T, RequestLogsUpsertArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsCountArgs} args - Arguments to filter RequestLogs to count.
     * @example
     * // Count the number of RequestLogs
     * const count = await prisma.requestLogs.count({
     *   where: {
     *     // ... the filter for the RequestLogs we want to count
     *   }
     * })
    **/
    count<T extends RequestLogsCountArgs>(
      args?: Subset<T, RequestLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestLogsAggregateArgs>(args: Subset<T, RequestLogsAggregateArgs>): Prisma.PrismaPromise<GetRequestLogsAggregateType<T>>

    /**
     * Group by RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestLogsGroupByArgs['orderBy'] }
        : { orderBy?: RequestLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestLogs model
   */
  readonly fields: RequestLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approval<T extends RequestLogs$approvalArgs<ExtArgs> = {}>(args?: Subset<T, RequestLogs$approvalArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approver<T extends RequestLogs$approverArgs<ExtArgs> = {}>(args?: Subset<T, RequestLogs$approverArgs<ExtArgs>>): Prisma__RequestCheckerClient<$Result.GetResult<Prisma.$RequestCheckerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestLogs model
   */
  interface RequestLogsFieldRefs {
    readonly id: FieldRef<"RequestLogs", 'Int'>
    readonly approvalId: FieldRef<"RequestLogs", 'Int'>
    readonly checkerType: FieldRef<"RequestLogs", 'String'>
    readonly approverId: FieldRef<"RequestLogs", 'Int'>
    readonly createdAt: FieldRef<"RequestLogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestLogs findUnique
   */
  export type RequestLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs findUniqueOrThrow
   */
  export type RequestLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs findFirst
   */
  export type RequestLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestLogs.
     */
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs findFirstOrThrow
   */
  export type RequestLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestLogs.
     */
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs findMany
   */
  export type RequestLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs create
   */
  export type RequestLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestLogs.
     */
    data: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
  }

  /**
   * RequestLogs createMany
   */
  export type RequestLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestLogs.
     */
    data: RequestLogsCreateManyInput | RequestLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestLogs createManyAndReturn
   */
  export type RequestLogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * The data used to create many RequestLogs.
     */
    data: RequestLogsCreateManyInput | RequestLogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestLogs update
   */
  export type RequestLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestLogs.
     */
    data: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
    /**
     * Choose, which RequestLogs to update.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs updateMany
   */
  export type RequestLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestLogs.
     */
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyInput>
    /**
     * Filter which RequestLogs to update
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to update.
     */
    limit?: number
  }

  /**
   * RequestLogs updateManyAndReturn
   */
  export type RequestLogsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * The data used to update RequestLogs.
     */
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyInput>
    /**
     * Filter which RequestLogs to update
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestLogs upsert
   */
  export type RequestLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestLogs to update in case it exists.
     */
    where: RequestLogsWhereUniqueInput
    /**
     * In case the RequestLogs found by the `where` argument doesn't exist, create a new RequestLogs with this data.
     */
    create: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
    /**
     * In case the RequestLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
  }

  /**
   * RequestLogs delete
   */
  export type RequestLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter which RequestLogs to delete.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs deleteMany
   */
  export type RequestLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestLogs to delete
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to delete.
     */
    limit?: number
  }

  /**
   * RequestLogs.approval
   */
  export type RequestLogs$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    where?: ApprovalTableWhereInput
  }

  /**
   * RequestLogs.approver
   */
  export type RequestLogs$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestChecker
     */
    select?: RequestCheckerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestChecker
     */
    omit?: RequestCheckerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCheckerInclude<ExtArgs> | null
    where?: RequestCheckerWhereInput
  }

  /**
   * RequestLogs without action
   */
  export type RequestLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    branchCode: 'branchCode',
    branchName: 'branchName',
    bom: 'bom',
    faa: 'faa',
    telephone: 'telephone',
    address: 'address',
    companyName: 'companyName',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const RequestTypeScalarFieldEnum: {
    id: 'id',
    requestName: 'requestName',
    notedById: 'notedById',
    checkedById: 'checkedById',
    checkedBy2Id: 'checkedBy2Id',
    recomApprovalId: 'recomApprovalId',
    recomApproval2Id: 'recomApproval2Id',
    approveById: 'approveById',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type RequestTypeScalarFieldEnum = (typeof RequestTypeScalarFieldEnum)[keyof typeof RequestTypeScalarFieldEnum]


  export const RequestCheckerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    position: 'position',
    initial: 'initial',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestCheckerScalarFieldEnum = (typeof RequestCheckerScalarFieldEnum)[keyof typeof RequestCheckerScalarFieldEnum]


  export const MainRequestScalarFieldEnum: {
    id: 'id',
    requestTypeId: 'requestTypeId',
    requestById: 'requestById',
    requestFromId: 'requestFromId',
    status: 'status',
    requestDate: 'requestDate',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type MainRequestScalarFieldEnum = (typeof MainRequestScalarFieldEnum)[keyof typeof MainRequestScalarFieldEnum]


  export const FormFundTransferScalarFieldEnum: {
    id: 'id',
    mainRequestID: 'mainRequestID',
    requestToId: 'requestToId',
    requestContent: 'requestContent',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type FormFundTransferScalarFieldEnum = (typeof FormFundTransferScalarFieldEnum)[keyof typeof FormFundTransferScalarFieldEnum]


  export const ApprovalTableScalarFieldEnum: {
    id: 'id',
    mainFormId: 'mainFormId',
    notedBy: 'notedBy',
    checkedBy: 'checkedBy',
    checkedBy2: 'checkedBy2',
    recomApproval: 'recomApproval',
    recomApproval2: 'recomApproval2',
    approveBy: 'approveBy',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type ApprovalTableScalarFieldEnum = (typeof ApprovalTableScalarFieldEnum)[keyof typeof ApprovalTableScalarFieldEnum]


  export const RequestLogsScalarFieldEnum: {
    id: 'id',
    approvalId: 'approvalId',
    checkerType: 'checkerType',
    approverId: 'approverId',
    createdAt: 'createdAt'
  };

  export type RequestLogsScalarFieldEnum = (typeof RequestLogsScalarFieldEnum)[keyof typeof RequestLogsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Statuses'
   */
  export type EnumStatusesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Statuses'>
    


  /**
   * Reference to a field of type 'Statuses[]'
   */
  export type ListEnumStatusesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Statuses[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    checker?: RequestCheckerListRelationFilter
    mainForm?: MainRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    checker?: RequestCheckerOrderByRelationAggregateInput
    mainForm?: MainRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    checker?: RequestCheckerListRelationFilter
    mainForm?: MainRequestListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    branchCode?: StringFilter<"Branch"> | string
    branchName?: StringFilter<"Branch"> | string
    bom?: StringFilter<"Branch"> | string
    faa?: StringFilter<"Branch"> | string
    telephone?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    companyName?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updateAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    main?: MainRequestListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    main?: MainRequestOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    branchCode?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    branchName?: StringFilter<"Branch"> | string
    bom?: StringFilter<"Branch"> | string
    faa?: StringFilter<"Branch"> | string
    telephone?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    companyName?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updateAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    main?: MainRequestListRelationFilter
  }, "id" | "branchCode">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    branchCode?: StringWithAggregatesFilter<"Branch"> | string
    branchName?: StringWithAggregatesFilter<"Branch"> | string
    bom?: StringWithAggregatesFilter<"Branch"> | string
    faa?: StringWithAggregatesFilter<"Branch"> | string
    telephone?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringWithAggregatesFilter<"Branch"> | string
    companyName?: StringWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type RequestTypeWhereInput = {
    AND?: RequestTypeWhereInput | RequestTypeWhereInput[]
    OR?: RequestTypeWhereInput[]
    NOT?: RequestTypeWhereInput | RequestTypeWhereInput[]
    id?: IntFilter<"RequestType"> | number
    requestName?: StringFilter<"RequestType"> | string
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
    notedBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    checkedBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    checkedBy2?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    recomApproval?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    recomApproval2?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    approveBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    mainRequests?: MainRequestListRelationFilter
  }

  export type RequestTypeOrderByWithRelationInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    checkedBy2Id?: SortOrderInput | SortOrder
    recomApprovalId?: SortOrderInput | SortOrder
    recomApproval2Id?: SortOrderInput | SortOrder
    approveById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    notedBy?: RequestCheckerOrderByWithRelationInput
    checkedBy?: RequestCheckerOrderByWithRelationInput
    checkedBy2?: RequestCheckerOrderByWithRelationInput
    recomApproval?: RequestCheckerOrderByWithRelationInput
    recomApproval2?: RequestCheckerOrderByWithRelationInput
    approveBy?: RequestCheckerOrderByWithRelationInput
    mainRequests?: MainRequestOrderByRelationAggregateInput
  }

  export type RequestTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    requestName?: string
    AND?: RequestTypeWhereInput | RequestTypeWhereInput[]
    OR?: RequestTypeWhereInput[]
    NOT?: RequestTypeWhereInput | RequestTypeWhereInput[]
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
    notedBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    checkedBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    checkedBy2?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    recomApproval?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    recomApproval2?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    approveBy?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
    mainRequests?: MainRequestListRelationFilter
  }, "id" | "requestName">

  export type RequestTypeOrderByWithAggregationInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    checkedBy2Id?: SortOrderInput | SortOrder
    recomApprovalId?: SortOrderInput | SortOrder
    recomApproval2Id?: SortOrderInput | SortOrder
    approveById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: RequestTypeCountOrderByAggregateInput
    _avg?: RequestTypeAvgOrderByAggregateInput
    _max?: RequestTypeMaxOrderByAggregateInput
    _min?: RequestTypeMinOrderByAggregateInput
    _sum?: RequestTypeSumOrderByAggregateInput
  }

  export type RequestTypeScalarWhereWithAggregatesInput = {
    AND?: RequestTypeScalarWhereWithAggregatesInput | RequestTypeScalarWhereWithAggregatesInput[]
    OR?: RequestTypeScalarWhereWithAggregatesInput[]
    NOT?: RequestTypeScalarWhereWithAggregatesInput | RequestTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestType"> | number
    requestName?: StringWithAggregatesFilter<"RequestType"> | string
    notedById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    checkedById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    approveById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RequestType"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"RequestType"> | Date | string
  }

  export type RequestCheckerWhereInput = {
    AND?: RequestCheckerWhereInput | RequestCheckerWhereInput[]
    OR?: RequestCheckerWhereInput[]
    NOT?: RequestCheckerWhereInput | RequestCheckerWhereInput[]
    id?: IntFilter<"RequestChecker"> | number
    userId?: IntNullableFilter<"RequestChecker"> | number | null
    position?: StringFilter<"RequestChecker"> | string
    initial?: StringFilter<"RequestChecker"> | string
    createdAt?: DateTimeFilter<"RequestChecker"> | Date | string
    updatedAt?: DateTimeFilter<"RequestChecker"> | Date | string
    checkerName?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    notedByForTypes?: RequestTypeListRelationFilter
    checkedByForTypes?: RequestTypeListRelationFilter
    checkedBy2ForTypes?: RequestTypeListRelationFilter
    recomApprovalForTypes?: RequestTypeListRelationFilter
    recomApproval2ForTypes?: RequestTypeListRelationFilter
    approveByForTypes?: RequestTypeListRelationFilter
    formRequestFundTo?: FormFundTransferListRelationFilter
    requestLogs?: RequestLogsListRelationFilter
  }

  export type RequestCheckerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    position?: SortOrder
    initial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkerName?: UserOrderByWithRelationInput
    notedByForTypes?: RequestTypeOrderByRelationAggregateInput
    checkedByForTypes?: RequestTypeOrderByRelationAggregateInput
    checkedBy2ForTypes?: RequestTypeOrderByRelationAggregateInput
    recomApprovalForTypes?: RequestTypeOrderByRelationAggregateInput
    recomApproval2ForTypes?: RequestTypeOrderByRelationAggregateInput
    approveByForTypes?: RequestTypeOrderByRelationAggregateInput
    formRequestFundTo?: FormFundTransferOrderByRelationAggregateInput
    requestLogs?: RequestLogsOrderByRelationAggregateInput
  }

  export type RequestCheckerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: RequestCheckerWhereInput | RequestCheckerWhereInput[]
    OR?: RequestCheckerWhereInput[]
    NOT?: RequestCheckerWhereInput | RequestCheckerWhereInput[]
    position?: StringFilter<"RequestChecker"> | string
    initial?: StringFilter<"RequestChecker"> | string
    createdAt?: DateTimeFilter<"RequestChecker"> | Date | string
    updatedAt?: DateTimeFilter<"RequestChecker"> | Date | string
    checkerName?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    notedByForTypes?: RequestTypeListRelationFilter
    checkedByForTypes?: RequestTypeListRelationFilter
    checkedBy2ForTypes?: RequestTypeListRelationFilter
    recomApprovalForTypes?: RequestTypeListRelationFilter
    recomApproval2ForTypes?: RequestTypeListRelationFilter
    approveByForTypes?: RequestTypeListRelationFilter
    formRequestFundTo?: FormFundTransferListRelationFilter
    requestLogs?: RequestLogsListRelationFilter
  }, "id" | "userId">

  export type RequestCheckerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    position?: SortOrder
    initial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCheckerCountOrderByAggregateInput
    _avg?: RequestCheckerAvgOrderByAggregateInput
    _max?: RequestCheckerMaxOrderByAggregateInput
    _min?: RequestCheckerMinOrderByAggregateInput
    _sum?: RequestCheckerSumOrderByAggregateInput
  }

  export type RequestCheckerScalarWhereWithAggregatesInput = {
    AND?: RequestCheckerScalarWhereWithAggregatesInput | RequestCheckerScalarWhereWithAggregatesInput[]
    OR?: RequestCheckerScalarWhereWithAggregatesInput[]
    NOT?: RequestCheckerScalarWhereWithAggregatesInput | RequestCheckerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestChecker"> | number
    userId?: IntNullableWithAggregatesFilter<"RequestChecker"> | number | null
    position?: StringWithAggregatesFilter<"RequestChecker"> | string
    initial?: StringWithAggregatesFilter<"RequestChecker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequestChecker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RequestChecker"> | Date | string
  }

  export type MainRequestWhereInput = {
    AND?: MainRequestWhereInput | MainRequestWhereInput[]
    OR?: MainRequestWhereInput[]
    NOT?: MainRequestWhereInput | MainRequestWhereInput[]
    id?: IntFilter<"MainRequest"> | number
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
    requestType?: XOR<RequestTypeNullableScalarRelationFilter, RequestTypeWhereInput> | null
    fundTransfer?: XOR<FormFundTransferNullableScalarRelationFilter, FormFundTransferWhereInput> | null
    requestBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestFrom?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    approval?: ApprovalTableListRelationFilter
  }

  export type MainRequestOrderByWithRelationInput = {
    id?: SortOrder
    requestTypeId?: SortOrderInput | SortOrder
    requestById?: SortOrderInput | SortOrder
    requestFromId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    requestType?: RequestTypeOrderByWithRelationInput
    fundTransfer?: FormFundTransferOrderByWithRelationInput
    requestBy?: UserOrderByWithRelationInput
    requestFrom?: BranchOrderByWithRelationInput
    approval?: ApprovalTableOrderByRelationAggregateInput
  }

  export type MainRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MainRequestWhereInput | MainRequestWhereInput[]
    OR?: MainRequestWhereInput[]
    NOT?: MainRequestWhereInput | MainRequestWhereInput[]
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
    requestType?: XOR<RequestTypeNullableScalarRelationFilter, RequestTypeWhereInput> | null
    fundTransfer?: XOR<FormFundTransferNullableScalarRelationFilter, FormFundTransferWhereInput> | null
    requestBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestFrom?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    approval?: ApprovalTableListRelationFilter
  }, "id">

  export type MainRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requestTypeId?: SortOrderInput | SortOrder
    requestById?: SortOrderInput | SortOrder
    requestFromId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: MainRequestCountOrderByAggregateInput
    _avg?: MainRequestAvgOrderByAggregateInput
    _max?: MainRequestMaxOrderByAggregateInput
    _min?: MainRequestMinOrderByAggregateInput
    _sum?: MainRequestSumOrderByAggregateInput
  }

  export type MainRequestScalarWhereWithAggregatesInput = {
    AND?: MainRequestScalarWhereWithAggregatesInput | MainRequestScalarWhereWithAggregatesInput[]
    OR?: MainRequestScalarWhereWithAggregatesInput[]
    NOT?: MainRequestScalarWhereWithAggregatesInput | MainRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MainRequest"> | number
    requestTypeId?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    requestById?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    status?: EnumStatusesWithAggregatesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"MainRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
  }

  export type FormFundTransferWhereInput = {
    AND?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    OR?: FormFundTransferWhereInput[]
    NOT?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    id?: IntFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestTo?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
  }

  export type FormFundTransferOrderByWithRelationInput = {
    id?: SortOrder
    mainRequestID?: SortOrderInput | SortOrder
    requestToId?: SortOrderInput | SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    mainRequest?: MainRequestOrderByWithRelationInput
    requestTo?: RequestCheckerOrderByWithRelationInput
  }

  export type FormFundTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainRequestID?: number
    AND?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    OR?: FormFundTransferWhereInput[]
    NOT?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestTo?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
  }, "id" | "mainRequestID">

  export type FormFundTransferOrderByWithAggregationInput = {
    id?: SortOrder
    mainRequestID?: SortOrderInput | SortOrder
    requestToId?: SortOrderInput | SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: FormFundTransferCountOrderByAggregateInput
    _avg?: FormFundTransferAvgOrderByAggregateInput
    _max?: FormFundTransferMaxOrderByAggregateInput
    _min?: FormFundTransferMinOrderByAggregateInput
    _sum?: FormFundTransferSumOrderByAggregateInput
  }

  export type FormFundTransferScalarWhereWithAggregatesInput = {
    AND?: FormFundTransferScalarWhereWithAggregatesInput | FormFundTransferScalarWhereWithAggregatesInput[]
    OR?: FormFundTransferScalarWhereWithAggregatesInput[]
    NOT?: FormFundTransferScalarWhereWithAggregatesInput | FormFundTransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableWithAggregatesFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableWithAggregatesFilter<"FormFundTransfer"> | number | null
    requestContent?: StringWithAggregatesFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"FormFundTransfer"> | Date | string
  }

  export type ApprovalTableWhereInput = {
    AND?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    OR?: ApprovalTableWhereInput[]
    NOT?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    id?: IntFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestLogs?: RequestLogsListRelationFilter
  }

  export type ApprovalTableOrderByWithRelationInput = {
    id?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    mainRequest?: MainRequestOrderByWithRelationInput
    requestLogs?: RequestLogsOrderByRelationAggregateInput
  }

  export type ApprovalTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    OR?: ApprovalTableWhereInput[]
    NOT?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestLogs?: RequestLogsListRelationFilter
  }, "id" | "mainFormId">

  export type ApprovalTableOrderByWithAggregationInput = {
    id?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: ApprovalTableCountOrderByAggregateInput
    _avg?: ApprovalTableAvgOrderByAggregateInput
    _max?: ApprovalTableMaxOrderByAggregateInput
    _min?: ApprovalTableMinOrderByAggregateInput
    _sum?: ApprovalTableSumOrderByAggregateInput
  }

  export type ApprovalTableScalarWhereWithAggregatesInput = {
    AND?: ApprovalTableScalarWhereWithAggregatesInput | ApprovalTableScalarWhereWithAggregatesInput[]
    OR?: ApprovalTableScalarWhereWithAggregatesInput[]
    NOT?: ApprovalTableScalarWhereWithAggregatesInput | ApprovalTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableWithAggregatesFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"ApprovalTable"> | Date | string
  }

  export type RequestLogsWhereInput = {
    AND?: RequestLogsWhereInput | RequestLogsWhereInput[]
    OR?: RequestLogsWhereInput[]
    NOT?: RequestLogsWhereInput | RequestLogsWhereInput[]
    id?: IntFilter<"RequestLogs"> | number
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
    approval?: XOR<ApprovalTableNullableScalarRelationFilter, ApprovalTableWhereInput> | null
    approver?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
  }

  export type RequestLogsOrderByWithRelationInput = {
    id?: SortOrder
    approvalId?: SortOrderInput | SortOrder
    checkerType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approval?: ApprovalTableOrderByWithRelationInput
    approver?: RequestCheckerOrderByWithRelationInput
  }

  export type RequestLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestLogsWhereInput | RequestLogsWhereInput[]
    OR?: RequestLogsWhereInput[]
    NOT?: RequestLogsWhereInput | RequestLogsWhereInput[]
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
    approval?: XOR<ApprovalTableNullableScalarRelationFilter, ApprovalTableWhereInput> | null
    approver?: XOR<RequestCheckerNullableScalarRelationFilter, RequestCheckerWhereInput> | null
  }, "id">

  export type RequestLogsOrderByWithAggregationInput = {
    id?: SortOrder
    approvalId?: SortOrderInput | SortOrder
    checkerType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RequestLogsCountOrderByAggregateInput
    _avg?: RequestLogsAvgOrderByAggregateInput
    _max?: RequestLogsMaxOrderByAggregateInput
    _min?: RequestLogsMinOrderByAggregateInput
    _sum?: RequestLogsSumOrderByAggregateInput
  }

  export type RequestLogsScalarWhereWithAggregatesInput = {
    AND?: RequestLogsScalarWhereWithAggregatesInput | RequestLogsScalarWhereWithAggregatesInput[]
    OR?: RequestLogsScalarWhereWithAggregatesInput[]
    NOT?: RequestLogsScalarWhereWithAggregatesInput | RequestLogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestLogs"> | number
    approvalId?: IntNullableWithAggregatesFilter<"RequestLogs"> | number | null
    checkerType?: StringWithAggregatesFilter<"RequestLogs"> | string
    approverId?: IntNullableWithAggregatesFilter<"RequestLogs"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RequestLogs"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    checker?: RequestCheckerCreateNestedManyWithoutCheckerNameInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    checker?: RequestCheckerUncheckedCreateNestedManyWithoutCheckerNameInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    checker?: RequestCheckerUpdateManyWithoutCheckerNameNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checker?: RequestCheckerUncheckedUpdateManyWithoutCheckerNameNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    main?: MainRequestCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    main?: MainRequestUncheckedCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUpdateInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    main?: MainRequestUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    main?: MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeCreateInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUpdateInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeCreateManyInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeUpdateManyMutationInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCheckerCreateInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUpdateInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerCreateManyInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCheckerUpdateManyMutationInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCheckerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestCreateInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUncheckedCreateInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUpdateInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestCreateManyInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestUpdateManyMutationInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferCreateInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutFundTransferInput
    requestTo?: RequestCheckerCreateNestedOneWithoutFormRequestFundToInput
  }

  export type FormFundTransferUncheckedCreateInput = {
    id?: number
    mainRequestID?: number | null
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferUpdateInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutFundTransferNestedInput
    requestTo?: RequestCheckerUpdateOneWithoutFormRequestFundToNestedInput
  }

  export type FormFundTransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferCreateManyInput = {
    id?: number
    mainRequestID?: number | null
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferUpdateManyMutationInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableCreateInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutApprovalInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUpdateInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutApprovalNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableCreateManyInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovalTableUpdateManyMutationInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateInput = {
    checkerType: string
    createdAt?: Date | string
    approval?: ApprovalTableCreateNestedOneWithoutRequestLogsInput
    approver?: RequestCheckerCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    approverId?: number | null
    createdAt?: Date | string
  }

  export type RequestLogsUpdateInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUpdateOneWithoutRequestLogsNestedInput
    approver?: RequestCheckerUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateManyInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    approverId?: number | null
    createdAt?: Date | string
  }

  export type RequestLogsUpdateManyMutationInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type RequestCheckerListRelationFilter = {
    every?: RequestCheckerWhereInput
    some?: RequestCheckerWhereInput
    none?: RequestCheckerWhereInput
  }

  export type MainRequestListRelationFilter = {
    every?: MainRequestWhereInput
    some?: MainRequestWhereInput
    none?: MainRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RequestCheckerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestCheckerNullableScalarRelationFilter = {
    is?: RequestCheckerWhereInput | null
    isNot?: RequestCheckerWhereInput | null
  }

  export type RequestTypeCountOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
  }

  export type RequestTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeMinOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeSumOrderByAggregateInput = {
    id?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RequestTypeListRelationFilter = {
    every?: RequestTypeWhereInput
    some?: RequestTypeWhereInput
    none?: RequestTypeWhereInput
  }

  export type FormFundTransferListRelationFilter = {
    every?: FormFundTransferWhereInput
    some?: FormFundTransferWhereInput
    none?: FormFundTransferWhereInput
  }

  export type RequestLogsListRelationFilter = {
    every?: RequestLogsWhereInput
    some?: RequestLogsWhereInput
    none?: RequestLogsWhereInput
  }

  export type RequestTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormFundTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestCheckerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCheckerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RequestCheckerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCheckerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCheckerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumStatusesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesFilter<$PrismaModel> | $Enums.Statuses
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RequestTypeNullableScalarRelationFilter = {
    is?: RequestTypeWhereInput | null
    isNot?: RequestTypeWhereInput | null
  }

  export type FormFundTransferNullableScalarRelationFilter = {
    is?: FormFundTransferWhereInput | null
    isNot?: FormFundTransferWhereInput | null
  }

  export type ApprovalTableListRelationFilter = {
    every?: ApprovalTableWhereInput
    some?: ApprovalTableWhereInput
    none?: ApprovalTableWhereInput
  }

  export type ApprovalTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
  }

  export type MainRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestSumOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
  }

  export type EnumStatusesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesWithAggregatesFilter<$PrismaModel> | $Enums.Statuses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusesFilter<$PrismaModel>
    _max?: NestedEnumStatusesFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MainRequestNullableScalarRelationFilter = {
    is?: MainRequestWhereInput | null
    isNot?: MainRequestWhereInput | null
  }

  export type FormFundTransferCountOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferAvgOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
  }

  export type FormFundTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferMinOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferSumOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
  }

  export type ApprovalTableCountOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableAvgOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
  }

  export type ApprovalTableMaxOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableMinOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableSumOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
  }

  export type ApprovalTableNullableScalarRelationFilter = {
    is?: ApprovalTableWhereInput | null
    isNot?: ApprovalTableWhereInput | null
  }

  export type RequestLogsCountOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    approverId?: SortOrder
  }

  export type RequestLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsMinOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsSumOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    approverId?: SortOrder
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type RequestCheckerCreateNestedManyWithoutCheckerNameInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput> | RequestCheckerCreateWithoutCheckerNameInput[] | RequestCheckerUncheckedCreateWithoutCheckerNameInput[]
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckerNameInput | RequestCheckerCreateOrConnectWithoutCheckerNameInput[]
    createMany?: RequestCheckerCreateManyCheckerNameInputEnvelope
    connect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
  }

  export type MainRequestCreateNestedManyWithoutRequestByInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type RequestCheckerUncheckedCreateNestedManyWithoutCheckerNameInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput> | RequestCheckerCreateWithoutCheckerNameInput[] | RequestCheckerUncheckedCreateWithoutCheckerNameInput[]
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckerNameInput | RequestCheckerCreateOrConnectWithoutCheckerNameInput[]
    createMany?: RequestCheckerCreateManyCheckerNameInputEnvelope
    connect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestByInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type RequestCheckerUpdateManyWithoutCheckerNameNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput> | RequestCheckerCreateWithoutCheckerNameInput[] | RequestCheckerUncheckedCreateWithoutCheckerNameInput[]
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckerNameInput | RequestCheckerCreateOrConnectWithoutCheckerNameInput[]
    upsert?: RequestCheckerUpsertWithWhereUniqueWithoutCheckerNameInput | RequestCheckerUpsertWithWhereUniqueWithoutCheckerNameInput[]
    createMany?: RequestCheckerCreateManyCheckerNameInputEnvelope
    set?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    disconnect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    delete?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    connect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    update?: RequestCheckerUpdateWithWhereUniqueWithoutCheckerNameInput | RequestCheckerUpdateWithWhereUniqueWithoutCheckerNameInput[]
    updateMany?: RequestCheckerUpdateManyWithWhereWithoutCheckerNameInput | RequestCheckerUpdateManyWithWhereWithoutCheckerNameInput[]
    deleteMany?: RequestCheckerScalarWhereInput | RequestCheckerScalarWhereInput[]
  }

  export type MainRequestUpdateManyWithoutRequestByNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestByInput | MainRequestUpsertWithWhereUniqueWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestByInput | MainRequestUpdateWithWhereUniqueWithoutRequestByInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestByInput | MainRequestUpdateManyWithWhereWithoutRequestByInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RequestCheckerUncheckedUpdateManyWithoutCheckerNameNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput> | RequestCheckerCreateWithoutCheckerNameInput[] | RequestCheckerUncheckedCreateWithoutCheckerNameInput[]
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckerNameInput | RequestCheckerCreateOrConnectWithoutCheckerNameInput[]
    upsert?: RequestCheckerUpsertWithWhereUniqueWithoutCheckerNameInput | RequestCheckerUpsertWithWhereUniqueWithoutCheckerNameInput[]
    createMany?: RequestCheckerCreateManyCheckerNameInputEnvelope
    set?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    disconnect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    delete?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    connect?: RequestCheckerWhereUniqueInput | RequestCheckerWhereUniqueInput[]
    update?: RequestCheckerUpdateWithWhereUniqueWithoutCheckerNameInput | RequestCheckerUpdateWithWhereUniqueWithoutCheckerNameInput[]
    updateMany?: RequestCheckerUpdateManyWithWhereWithoutCheckerNameInput | RequestCheckerUpdateManyWithWhereWithoutCheckerNameInput[]
    deleteMany?: RequestCheckerScalarWhereInput | RequestCheckerScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestByNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestByInput | MainRequestUpsertWithWhereUniqueWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestByInput | MainRequestUpdateWithWhereUniqueWithoutRequestByInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestByInput | MainRequestUpdateManyWithWhereWithoutRequestByInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MainRequestCreateNestedManyWithoutRequestFromInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestFromInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MainRequestUpdateManyWithoutRequestFromNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestFromInput | MainRequestUpsertWithWhereUniqueWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestFromInput | MainRequestUpdateWithWhereUniqueWithoutRequestFromInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestFromInput | MainRequestUpdateManyWithWhereWithoutRequestFromInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestFromInput | MainRequestUpsertWithWhereUniqueWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestFromInput | MainRequestUpdateWithWhereUniqueWithoutRequestFromInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestFromInput | MainRequestUpdateManyWithWhereWithoutRequestFromInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type RequestCheckerCreateNestedOneWithoutNotedByForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutNotedByForTypesInput, RequestCheckerUncheckedCreateWithoutNotedByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutNotedByForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckedByForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckedByForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedBy2ForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckedBy2ForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApprovalForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRecomApprovalForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApproval2ForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRecomApproval2ForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutApproveByForTypesInput = {
    create?: XOR<RequestCheckerCreateWithoutApproveByForTypesInput, RequestCheckerUncheckedCreateWithoutApproveByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutApproveByForTypesInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type MainRequestCreateNestedManyWithoutRequestTypeInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutNotedByForTypesInput, RequestCheckerUncheckedCreateWithoutNotedByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutNotedByForTypesInput
    upsert?: RequestCheckerUpsertWithoutNotedByForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutNotedByForTypesInput, RequestCheckerUpdateWithoutNotedByForTypesInput>, RequestCheckerUncheckedUpdateWithoutNotedByForTypesInput>
  }

  export type RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckedByForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckedByForTypesInput
    upsert?: RequestCheckerUpsertWithoutCheckedByForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutCheckedByForTypesInput, RequestCheckerUpdateWithoutCheckedByForTypesInput>, RequestCheckerUncheckedUpdateWithoutCheckedByForTypesInput>
  }

  export type RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedBy2ForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutCheckedBy2ForTypesInput
    upsert?: RequestCheckerUpsertWithoutCheckedBy2ForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutCheckedBy2ForTypesInput, RequestCheckerUpdateWithoutCheckedBy2ForTypesInput>, RequestCheckerUncheckedUpdateWithoutCheckedBy2ForTypesInput>
  }

  export type RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApprovalForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRecomApprovalForTypesInput
    upsert?: RequestCheckerUpsertWithoutRecomApprovalForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutRecomApprovalForTypesInput, RequestCheckerUpdateWithoutRecomApprovalForTypesInput>, RequestCheckerUncheckedUpdateWithoutRecomApprovalForTypesInput>
  }

  export type RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApproval2ForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRecomApproval2ForTypesInput
    upsert?: RequestCheckerUpsertWithoutRecomApproval2ForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutRecomApproval2ForTypesInput, RequestCheckerUpdateWithoutRecomApproval2ForTypesInput>, RequestCheckerUncheckedUpdateWithoutRecomApproval2ForTypesInput>
  }

  export type RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutApproveByForTypesInput, RequestCheckerUncheckedCreateWithoutApproveByForTypesInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutApproveByForTypesInput
    upsert?: RequestCheckerUpsertWithoutApproveByForTypesInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutApproveByForTypesInput, RequestCheckerUpdateWithoutApproveByForTypesInput>, RequestCheckerUncheckedUpdateWithoutApproveByForTypesInput>
  }

  export type MainRequestUpdateManyWithoutRequestTypeNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput | MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput | MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestTypeInput | MainRequestUpdateManyWithWhereWithoutRequestTypeInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput | MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput | MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestTypeInput | MainRequestUpdateManyWithWhereWithoutRequestTypeInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCheckerInput = {
    create?: XOR<UserCreateWithoutCheckerInput, UserUncheckedCreateWithoutCheckerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckerInput
    connect?: UserWhereUniqueInput
  }

  export type RequestTypeCreateNestedManyWithoutNotedByInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutCheckedBy2Input = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutRecomApprovalInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutRecomApproval2Input = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutApproveByInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type FormFundTransferCreateNestedManyWithoutRequestToInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
  }

  export type RequestLogsCreateNestedManyWithoutApproverInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutNotedByInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutApproveByInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
  }

  export type RequestLogsUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCheckerNestedInput = {
    create?: XOR<UserCreateWithoutCheckerInput, UserUncheckedCreateWithoutCheckerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckerInput
    upsert?: UserUpsertWithoutCheckerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckerInput, UserUpdateWithoutCheckerInput>, UserUncheckedUpdateWithoutCheckerInput>
  }

  export type RequestTypeUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutNotedByInput | RequestTypeUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutNotedByInput | RequestTypeUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutNotedByInput | RequestTypeUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput | RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput | RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedByInput | RequestTypeUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutCheckedBy2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input | RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutRecomApprovalNestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput | RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutRecomApproval2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input | RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutApproveByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutApproveByInput | RequestTypeUpsertWithWhereUniqueWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutApproveByInput | RequestTypeUpdateWithWhereUniqueWithoutApproveByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutApproveByInput | RequestTypeUpdateManyWithWhereWithoutApproveByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type FormFundTransferUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    upsert?: FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput | FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    set?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    disconnect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    delete?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    update?: FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput | FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: FormFundTransferUpdateManyWithWhereWithoutRequestToInput | FormFundTransferUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
  }

  export type RequestLogsUpdateManyWithoutApproverNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApproverInput | RequestLogsUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApproverInput | RequestLogsUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApproverInput | RequestLogsUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutNotedByInput | RequestTypeUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutNotedByInput | RequestTypeUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutNotedByInput | RequestTypeUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput | RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput | RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedByInput | RequestTypeUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input | RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput | RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input | RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutApproveByInput | RequestTypeUpsertWithWhereUniqueWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutApproveByInput | RequestTypeUpdateWithWhereUniqueWithoutApproveByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutApproveByInput | RequestTypeUpdateManyWithWhereWithoutApproveByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    upsert?: FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput | FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    set?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    disconnect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    delete?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    update?: FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput | FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: FormFundTransferUpdateManyWithWhereWithoutRequestToInput | FormFundTransferUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
  }

  export type RequestLogsUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApproverInput | RequestLogsUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApproverInput | RequestLogsUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApproverInput | RequestLogsUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type RequestTypeCreateNestedOneWithoutMainRequestsInput = {
    create?: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    connectOrCreate?: RequestTypeCreateOrConnectWithoutMainRequestsInput
    connect?: RequestTypeWhereUniqueInput
  }

  export type FormFundTransferCreateNestedOneWithoutMainRequestInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    connect?: FormFundTransferWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMainFormInput = {
    create?: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: UserCreateOrConnectWithoutMainFormInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutMainInput = {
    create?: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMainInput
    connect?: BranchWhereUniqueInput
  }

  export type ApprovalTableCreateNestedManyWithoutMainRequestInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
  }

  export type FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    connect?: FormFundTransferWhereUniqueInput
  }

  export type ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
  }

  export type EnumStatusesFieldUpdateOperationsInput = {
    set?: $Enums.Statuses
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RequestTypeUpdateOneWithoutMainRequestsNestedInput = {
    create?: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    connectOrCreate?: RequestTypeCreateOrConnectWithoutMainRequestsInput
    upsert?: RequestTypeUpsertWithoutMainRequestsInput
    disconnect?: RequestTypeWhereInput | boolean
    delete?: RequestTypeWhereInput | boolean
    connect?: RequestTypeWhereUniqueInput
    update?: XOR<XOR<RequestTypeUpdateToOneWithWhereWithoutMainRequestsInput, RequestTypeUpdateWithoutMainRequestsInput>, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
  }

  export type FormFundTransferUpdateOneWithoutMainRequestNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    upsert?: FormFundTransferUpsertWithoutMainRequestInput
    disconnect?: FormFundTransferWhereInput | boolean
    delete?: FormFundTransferWhereInput | boolean
    connect?: FormFundTransferWhereUniqueInput
    update?: XOR<XOR<FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput, FormFundTransferUpdateWithoutMainRequestInput>, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type UserUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: UserCreateOrConnectWithoutMainFormInput
    upsert?: UserUpsertWithoutMainFormInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMainFormInput, UserUpdateWithoutMainFormInput>, UserUncheckedUpdateWithoutMainFormInput>
  }

  export type BranchUpdateOneWithoutMainNestedInput = {
    create?: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMainInput
    upsert?: BranchUpsertWithoutMainInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMainInput, BranchUpdateWithoutMainInput>, BranchUncheckedUpdateWithoutMainInput>
  }

  export type ApprovalTableUpdateManyWithoutMainRequestNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    upsert?: ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    set?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    disconnect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    delete?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    update?: ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput[]
    updateMany?: ApprovalTableUpdateManyWithWhereWithoutMainRequestInput | ApprovalTableUpdateManyWithWhereWithoutMainRequestInput[]
    deleteMany?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
  }

  export type FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    upsert?: FormFundTransferUpsertWithoutMainRequestInput
    disconnect?: FormFundTransferWhereInput | boolean
    delete?: FormFundTransferWhereInput | boolean
    connect?: FormFundTransferWhereUniqueInput
    update?: XOR<XOR<FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput, FormFundTransferUpdateWithoutMainRequestInput>, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    upsert?: ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    set?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    disconnect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    delete?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    update?: ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput[]
    updateMany?: ApprovalTableUpdateManyWithWhereWithoutMainRequestInput | ApprovalTableUpdateManyWithWhereWithoutMainRequestInput[]
    deleteMany?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
  }

  export type MainRequestCreateNestedOneWithoutFundTransferInput = {
    create?: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutFundTransferInput
    connect?: MainRequestWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutFormRequestFundToInput = {
    create?: XOR<RequestCheckerCreateWithoutFormRequestFundToInput, RequestCheckerUncheckedCreateWithoutFormRequestFundToInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutFormRequestFundToInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type MainRequestUpdateOneWithoutFundTransferNestedInput = {
    create?: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutFundTransferInput
    upsert?: MainRequestUpsertWithoutFundTransferInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutFundTransferInput, MainRequestUpdateWithoutFundTransferInput>, MainRequestUncheckedUpdateWithoutFundTransferInput>
  }

  export type RequestCheckerUpdateOneWithoutFormRequestFundToNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutFormRequestFundToInput, RequestCheckerUncheckedCreateWithoutFormRequestFundToInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutFormRequestFundToInput
    upsert?: RequestCheckerUpsertWithoutFormRequestFundToInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutFormRequestFundToInput, RequestCheckerUpdateWithoutFormRequestFundToInput>, RequestCheckerUncheckedUpdateWithoutFormRequestFundToInput>
  }

  export type MainRequestCreateNestedOneWithoutApprovalInput = {
    create?: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutApprovalInput
    connect?: MainRequestWhereUniqueInput
  }

  export type RequestLogsCreateNestedManyWithoutApprovalInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type RequestLogsUncheckedCreateNestedManyWithoutApprovalInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type MainRequestUpdateOneWithoutApprovalNestedInput = {
    create?: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutApprovalInput
    upsert?: MainRequestUpsertWithoutApprovalInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutApprovalInput, MainRequestUpdateWithoutApprovalInput>, MainRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type RequestLogsUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApprovalInput | RequestLogsUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApprovalInput | RequestLogsUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApprovalInput | RequestLogsUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApprovalInput | RequestLogsUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApprovalInput | RequestLogsUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApprovalInput | RequestLogsUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type ApprovalTableCreateNestedOneWithoutRequestLogsInput = {
    create?: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutRequestLogsInput
    connect?: ApprovalTableWhereUniqueInput
  }

  export type RequestCheckerCreateNestedOneWithoutRequestLogsInput = {
    create?: XOR<RequestCheckerCreateWithoutRequestLogsInput, RequestCheckerUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRequestLogsInput
    connect?: RequestCheckerWhereUniqueInput
  }

  export type ApprovalTableUpdateOneWithoutRequestLogsNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutRequestLogsInput
    upsert?: ApprovalTableUpsertWithoutRequestLogsInput
    disconnect?: ApprovalTableWhereInput | boolean
    delete?: ApprovalTableWhereInput | boolean
    connect?: ApprovalTableWhereUniqueInput
    update?: XOR<XOR<ApprovalTableUpdateToOneWithWhereWithoutRequestLogsInput, ApprovalTableUpdateWithoutRequestLogsInput>, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
  }

  export type RequestCheckerUpdateOneWithoutRequestLogsNestedInput = {
    create?: XOR<RequestCheckerCreateWithoutRequestLogsInput, RequestCheckerUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: RequestCheckerCreateOrConnectWithoutRequestLogsInput
    upsert?: RequestCheckerUpsertWithoutRequestLogsInput
    disconnect?: RequestCheckerWhereInput | boolean
    delete?: RequestCheckerWhereInput | boolean
    connect?: RequestCheckerWhereUniqueInput
    update?: XOR<XOR<RequestCheckerUpdateToOneWithWhereWithoutRequestLogsInput, RequestCheckerUpdateWithoutRequestLogsInput>, RequestCheckerUncheckedUpdateWithoutRequestLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesFilter<$PrismaModel> | $Enums.Statuses
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumStatusesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesWithAggregatesFilter<$PrismaModel> | $Enums.Statuses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusesFilter<$PrismaModel>
    _max?: NestedEnumStatusesFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BranchCreateWithoutUsersInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    main?: MainRequestCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    main?: MainRequestUncheckedCreateNestedManyWithoutRequestFromInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type RequestCheckerCreateWithoutCheckerNameInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutCheckerNameInput = {
    id?: number
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutCheckerNameInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput>
  }

  export type RequestCheckerCreateManyCheckerNameInputEnvelope = {
    data: RequestCheckerCreateManyCheckerNameInput | RequestCheckerCreateManyCheckerNameInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestCreateWithoutRequestByInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUncheckedCreateWithoutRequestByInput = {
    id?: number
    requestTypeId?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestCreateOrConnectWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput>
  }

  export type MainRequestCreateManyRequestByInputEnvelope = {
    data: MainRequestCreateManyRequestByInput | MainRequestCreateManyRequestByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    main?: MainRequestUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    main?: MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput
  }

  export type RequestCheckerUpsertWithWhereUniqueWithoutCheckerNameInput = {
    where: RequestCheckerWhereUniqueInput
    update: XOR<RequestCheckerUpdateWithoutCheckerNameInput, RequestCheckerUncheckedUpdateWithoutCheckerNameInput>
    create: XOR<RequestCheckerCreateWithoutCheckerNameInput, RequestCheckerUncheckedCreateWithoutCheckerNameInput>
  }

  export type RequestCheckerUpdateWithWhereUniqueWithoutCheckerNameInput = {
    where: RequestCheckerWhereUniqueInput
    data: XOR<RequestCheckerUpdateWithoutCheckerNameInput, RequestCheckerUncheckedUpdateWithoutCheckerNameInput>
  }

  export type RequestCheckerUpdateManyWithWhereWithoutCheckerNameInput = {
    where: RequestCheckerScalarWhereInput
    data: XOR<RequestCheckerUpdateManyMutationInput, RequestCheckerUncheckedUpdateManyWithoutCheckerNameInput>
  }

  export type RequestCheckerScalarWhereInput = {
    AND?: RequestCheckerScalarWhereInput | RequestCheckerScalarWhereInput[]
    OR?: RequestCheckerScalarWhereInput[]
    NOT?: RequestCheckerScalarWhereInput | RequestCheckerScalarWhereInput[]
    id?: IntFilter<"RequestChecker"> | number
    userId?: IntNullableFilter<"RequestChecker"> | number | null
    position?: StringFilter<"RequestChecker"> | string
    initial?: StringFilter<"RequestChecker"> | string
    createdAt?: DateTimeFilter<"RequestChecker"> | Date | string
    updatedAt?: DateTimeFilter<"RequestChecker"> | Date | string
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestByInput, MainRequestUncheckedUpdateWithoutRequestByInput>
    create: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestByInput, MainRequestUncheckedUpdateWithoutRequestByInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestByInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestByInput>
  }

  export type MainRequestScalarWhereInput = {
    AND?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
    OR?: MainRequestScalarWhereInput[]
    NOT?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
    id?: IntFilter<"MainRequest"> | number
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
  }

  export type UserCreateWithoutBranchInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
    checker?: RequestCheckerCreateNestedManyWithoutCheckerNameInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
    checker?: RequestCheckerUncheckedCreateNestedManyWithoutCheckerNameInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestCreateWithoutRequestFromInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUncheckedCreateWithoutRequestFromInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestCreateOrConnectWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput>
  }

  export type MainRequestCreateManyRequestFromInputEnvelope = {
    data: MainRequestCreateManyRequestFromInput | MainRequestCreateManyRequestFromInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestFromInput, MainRequestUncheckedUpdateWithoutRequestFromInput>
    create: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestFromInput, MainRequestUncheckedUpdateWithoutRequestFromInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestFromInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestFromInput>
  }

  export type RequestCheckerCreateWithoutNotedByForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutNotedByForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutNotedByForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutNotedByForTypesInput, RequestCheckerUncheckedCreateWithoutNotedByForTypesInput>
  }

  export type RequestCheckerCreateWithoutCheckedByForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutCheckedByForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutCheckedByForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutCheckedByForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedByForTypesInput>
  }

  export type RequestCheckerCreateWithoutCheckedBy2ForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutCheckedBy2ForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutCheckedBy2ForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedBy2ForTypesInput>
  }

  export type RequestCheckerCreateWithoutRecomApprovalForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutRecomApprovalForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutRecomApprovalForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApprovalForTypesInput>
  }

  export type RequestCheckerCreateWithoutRecomApproval2ForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutRecomApproval2ForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutRecomApproval2ForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApproval2ForTypesInput>
  }

  export type RequestCheckerCreateWithoutApproveByForTypesInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutApproveByForTypesInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutApproveByForTypesInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutApproveByForTypesInput, RequestCheckerUncheckedCreateWithoutApproveByForTypesInput>
  }

  export type MainRequestCreateWithoutRequestTypeInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUncheckedCreateWithoutRequestTypeInput = {
    id?: number
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestCreateOrConnectWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput>
  }

  export type MainRequestCreateManyRequestTypeInputEnvelope = {
    data: MainRequestCreateManyRequestTypeInput | MainRequestCreateManyRequestTypeInput[]
    skipDuplicates?: boolean
  }

  export type RequestCheckerUpsertWithoutNotedByForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutNotedByForTypesInput, RequestCheckerUncheckedUpdateWithoutNotedByForTypesInput>
    create: XOR<RequestCheckerCreateWithoutNotedByForTypesInput, RequestCheckerUncheckedCreateWithoutNotedByForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutNotedByForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutNotedByForTypesInput, RequestCheckerUncheckedUpdateWithoutNotedByForTypesInput>
  }

  export type RequestCheckerUpdateWithoutNotedByForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutNotedByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUpsertWithoutCheckedByForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutCheckedByForTypesInput, RequestCheckerUncheckedUpdateWithoutCheckedByForTypesInput>
    create: XOR<RequestCheckerCreateWithoutCheckedByForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedByForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutCheckedByForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutCheckedByForTypesInput, RequestCheckerUncheckedUpdateWithoutCheckedByForTypesInput>
  }

  export type RequestCheckerUpdateWithoutCheckedByForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutCheckedByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUpsertWithoutCheckedBy2ForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedUpdateWithoutCheckedBy2ForTypesInput>
    create: XOR<RequestCheckerCreateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedCreateWithoutCheckedBy2ForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutCheckedBy2ForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutCheckedBy2ForTypesInput, RequestCheckerUncheckedUpdateWithoutCheckedBy2ForTypesInput>
  }

  export type RequestCheckerUpdateWithoutCheckedBy2ForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutCheckedBy2ForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUpsertWithoutRecomApprovalForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedUpdateWithoutRecomApprovalForTypesInput>
    create: XOR<RequestCheckerCreateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApprovalForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutRecomApprovalForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutRecomApprovalForTypesInput, RequestCheckerUncheckedUpdateWithoutRecomApprovalForTypesInput>
  }

  export type RequestCheckerUpdateWithoutRecomApprovalForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutRecomApprovalForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUpsertWithoutRecomApproval2ForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedUpdateWithoutRecomApproval2ForTypesInput>
    create: XOR<RequestCheckerCreateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedCreateWithoutRecomApproval2ForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutRecomApproval2ForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutRecomApproval2ForTypesInput, RequestCheckerUncheckedUpdateWithoutRecomApproval2ForTypesInput>
  }

  export type RequestCheckerUpdateWithoutRecomApproval2ForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutRecomApproval2ForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUpsertWithoutApproveByForTypesInput = {
    update: XOR<RequestCheckerUpdateWithoutApproveByForTypesInput, RequestCheckerUncheckedUpdateWithoutApproveByForTypesInput>
    create: XOR<RequestCheckerCreateWithoutApproveByForTypesInput, RequestCheckerUncheckedCreateWithoutApproveByForTypesInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutApproveByForTypesInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutApproveByForTypesInput, RequestCheckerUncheckedUpdateWithoutApproveByForTypesInput>
  }

  export type RequestCheckerUpdateWithoutApproveByForTypesInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutApproveByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestTypeInput, MainRequestUncheckedUpdateWithoutRequestTypeInput>
    create: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestTypeInput, MainRequestUncheckedUpdateWithoutRequestTypeInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestTypeInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestTypeInput>
  }

  export type UserCreateWithoutCheckerInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutCheckerInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutCheckerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckerInput, UserUncheckedCreateWithoutCheckerInput>
  }

  export type RequestTypeCreateWithoutNotedByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutNotedByInput = {
    id?: number
    requestName: string
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput>
  }

  export type RequestTypeCreateManyNotedByInputEnvelope = {
    data: RequestTypeCreateManyNotedByInput | RequestTypeCreateManyNotedByInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutCheckedByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutCheckedByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput>
  }

  export type RequestTypeCreateManyCheckedByInputEnvelope = {
    data: RequestTypeCreateManyCheckedByInput | RequestTypeCreateManyCheckedByInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutCheckedBy2Input = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutCheckedBy2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input>
  }

  export type RequestTypeCreateManyCheckedBy2InputEnvelope = {
    data: RequestTypeCreateManyCheckedBy2Input | RequestTypeCreateManyCheckedBy2Input[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutRecomApprovalInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutRecomApprovalInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput>
  }

  export type RequestTypeCreateManyRecomApprovalInputEnvelope = {
    data: RequestTypeCreateManyRecomApprovalInput | RequestTypeCreateManyRecomApprovalInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutRecomApproval2Input = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutRecomApproval2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input>
  }

  export type RequestTypeCreateManyRecomApproval2InputEnvelope = {
    data: RequestTypeCreateManyRecomApproval2Input | RequestTypeCreateManyRecomApproval2Input[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutApproveByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutApproveByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput>
  }

  export type RequestTypeCreateManyApproveByInputEnvelope = {
    data: RequestTypeCreateManyApproveByInput | RequestTypeCreateManyApproveByInput[]
    skipDuplicates?: boolean
  }

  export type FormFundTransferCreateWithoutRequestToInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutFundTransferInput
  }

  export type FormFundTransferUncheckedCreateWithoutRequestToInput = {
    id?: number
    mainRequestID?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateOrConnectWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    create: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput>
  }

  export type FormFundTransferCreateManyRequestToInputEnvelope = {
    data: FormFundTransferCreateManyRequestToInput | FormFundTransferCreateManyRequestToInput[]
    skipDuplicates?: boolean
  }

  export type RequestLogsCreateWithoutApproverInput = {
    checkerType: string
    createdAt?: Date | string
    approval?: ApprovalTableCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateWithoutApproverInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    createdAt?: Date | string
  }

  export type RequestLogsCreateOrConnectWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    create: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput>
  }

  export type RequestLogsCreateManyApproverInputEnvelope = {
    data: RequestLogsCreateManyApproverInput | RequestLogsCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCheckerInput = {
    update: XOR<UserUpdateWithoutCheckerInput, UserUncheckedUpdateWithoutCheckerInput>
    create: XOR<UserCreateWithoutCheckerInput, UserUncheckedCreateWithoutCheckerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckerInput, UserUncheckedUpdateWithoutCheckerInput>
  }

  export type UserUpdateWithoutCheckerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutNotedByInput, RequestTypeUncheckedUpdateWithoutNotedByInput>
    create: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutNotedByInput, RequestTypeUncheckedUpdateWithoutNotedByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutNotedByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutNotedByInput>
  }

  export type RequestTypeScalarWhereInput = {
    AND?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
    OR?: RequestTypeScalarWhereInput[]
    NOT?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
    id?: IntFilter<"RequestType"> | number
    requestName?: StringFilter<"RequestType"> | string
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutCheckedByInput, RequestTypeUncheckedUpdateWithoutCheckedByInput>
    create: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutCheckedByInput, RequestTypeUncheckedUpdateWithoutCheckedByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutCheckedByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutCheckedByInput>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutCheckedBy2Input, RequestTypeUncheckedUpdateWithoutCheckedBy2Input>
    create: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutCheckedBy2Input, RequestTypeUncheckedUpdateWithoutCheckedBy2Input>
  }

  export type RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutCheckedBy2Input>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutRecomApprovalInput, RequestTypeUncheckedUpdateWithoutRecomApprovalInput>
    create: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutRecomApprovalInput, RequestTypeUncheckedUpdateWithoutRecomApprovalInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutRecomApprovalInput>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutRecomApproval2Input, RequestTypeUncheckedUpdateWithoutRecomApproval2Input>
    create: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutRecomApproval2Input, RequestTypeUncheckedUpdateWithoutRecomApproval2Input>
  }

  export type RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutRecomApproval2Input>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutApproveByInput, RequestTypeUncheckedUpdateWithoutApproveByInput>
    create: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutApproveByInput, RequestTypeUncheckedUpdateWithoutApproveByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutApproveByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutApproveByInput>
  }

  export type FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    update: XOR<FormFundTransferUpdateWithoutRequestToInput, FormFundTransferUncheckedUpdateWithoutRequestToInput>
    create: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput>
  }

  export type FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    data: XOR<FormFundTransferUpdateWithoutRequestToInput, FormFundTransferUncheckedUpdateWithoutRequestToInput>
  }

  export type FormFundTransferUpdateManyWithWhereWithoutRequestToInput = {
    where: FormFundTransferScalarWhereInput
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyWithoutRequestToInput>
  }

  export type FormFundTransferScalarWhereInput = {
    AND?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
    OR?: FormFundTransferScalarWhereInput[]
    NOT?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
    id?: IntFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
  }

  export type RequestLogsUpsertWithWhereUniqueWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    update: XOR<RequestLogsUpdateWithoutApproverInput, RequestLogsUncheckedUpdateWithoutApproverInput>
    create: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput>
  }

  export type RequestLogsUpdateWithWhereUniqueWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    data: XOR<RequestLogsUpdateWithoutApproverInput, RequestLogsUncheckedUpdateWithoutApproverInput>
  }

  export type RequestLogsUpdateManyWithWhereWithoutApproverInput = {
    where: RequestLogsScalarWhereInput
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyWithoutApproverInput>
  }

  export type RequestLogsScalarWhereInput = {
    AND?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
    OR?: RequestLogsScalarWhereInput[]
    NOT?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
    id?: IntFilter<"RequestLogs"> | number
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
  }

  export type RequestTypeCreateWithoutMainRequestsInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: RequestCheckerCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: RequestCheckerCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: RequestCheckerCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: RequestCheckerCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: RequestCheckerCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: RequestCheckerCreateNestedOneWithoutApproveByForTypesInput
  }

  export type RequestTypeUncheckedCreateWithoutMainRequestsInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateOrConnectWithoutMainRequestsInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
  }

  export type FormFundTransferCreateWithoutMainRequestInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    requestTo?: RequestCheckerCreateNestedOneWithoutFormRequestFundToInput
  }

  export type FormFundTransferUncheckedCreateWithoutMainRequestInput = {
    id?: number
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateOrConnectWithoutMainRequestInput = {
    where: FormFundTransferWhereUniqueInput
    create: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
  }

  export type UserCreateWithoutMainFormInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    checker?: RequestCheckerCreateNestedManyWithoutCheckerNameInput
  }

  export type UserUncheckedCreateWithoutMainFormInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    checker?: RequestCheckerUncheckedCreateNestedManyWithoutCheckerNameInput
  }

  export type UserCreateOrConnectWithoutMainFormInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
  }

  export type BranchCreateWithoutMainInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMainInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMainInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
  }

  export type ApprovalTableCreateWithoutMainRequestInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateWithoutMainRequestInput = {
    id?: number
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableCreateOrConnectWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    create: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput>
  }

  export type ApprovalTableCreateManyMainRequestInputEnvelope = {
    data: ApprovalTableCreateManyMainRequestInput | ApprovalTableCreateManyMainRequestInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeUpsertWithoutMainRequestsInput = {
    update: XOR<RequestTypeUpdateWithoutMainRequestsInput, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
    create: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    where?: RequestTypeWhereInput
  }

  export type RequestTypeUpdateToOneWithWhereWithoutMainRequestsInput = {
    where?: RequestTypeWhereInput
    data: XOR<RequestTypeUpdateWithoutMainRequestsInput, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
  }

  export type RequestTypeUpdateWithoutMainRequestsInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutMainRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUpsertWithoutMainRequestInput = {
    update: XOR<FormFundTransferUpdateWithoutMainRequestInput, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
    create: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    where?: FormFundTransferWhereInput
  }

  export type FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput = {
    where?: FormFundTransferWhereInput
    data: XOR<FormFundTransferUpdateWithoutMainRequestInput, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type FormFundTransferUpdateWithoutMainRequestInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestTo?: RequestCheckerUpdateOneWithoutFormRequestFundToNestedInput
  }

  export type FormFundTransferUncheckedUpdateWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMainFormInput = {
    update: XOR<UserUpdateWithoutMainFormInput, UserUncheckedUpdateWithoutMainFormInput>
    create: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMainFormInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMainFormInput, UserUncheckedUpdateWithoutMainFormInput>
  }

  export type UserUpdateWithoutMainFormInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    checker?: RequestCheckerUpdateManyWithoutCheckerNameNestedInput
  }

  export type UserUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checker?: RequestCheckerUncheckedUpdateManyWithoutCheckerNameNestedInput
  }

  export type BranchUpsertWithoutMainInput = {
    update: XOR<BranchUpdateWithoutMainInput, BranchUncheckedUpdateWithoutMainInput>
    create: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMainInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMainInput, BranchUncheckedUpdateWithoutMainInput>
  }

  export type BranchUpdateWithoutMainInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMainInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    update: XOR<ApprovalTableUpdateWithoutMainRequestInput, ApprovalTableUncheckedUpdateWithoutMainRequestInput>
    create: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput>
  }

  export type ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    data: XOR<ApprovalTableUpdateWithoutMainRequestInput, ApprovalTableUncheckedUpdateWithoutMainRequestInput>
  }

  export type ApprovalTableUpdateManyWithWhereWithoutMainRequestInput = {
    where: ApprovalTableScalarWhereInput
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyWithoutMainRequestInput>
  }

  export type ApprovalTableScalarWhereInput = {
    AND?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
    OR?: ApprovalTableScalarWhereInput[]
    NOT?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
    id?: IntFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
  }

  export type MainRequestCreateWithoutFundTransferInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestUncheckedCreateWithoutFundTransferInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
  }

  export type MainRequestCreateOrConnectWithoutFundTransferInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
  }

  export type RequestCheckerCreateWithoutFormRequestFundToInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerUncheckedCreateWithoutFormRequestFundToInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type RequestCheckerCreateOrConnectWithoutFormRequestFundToInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutFormRequestFundToInput, RequestCheckerUncheckedCreateWithoutFormRequestFundToInput>
  }

  export type MainRequestUpsertWithoutFundTransferInput = {
    update: XOR<MainRequestUpdateWithoutFundTransferInput, MainRequestUncheckedUpdateWithoutFundTransferInput>
    create: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutFundTransferInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutFundTransferInput, MainRequestUncheckedUpdateWithoutFundTransferInput>
  }

  export type MainRequestUpdateWithoutFundTransferInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutFundTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
  }

  export type RequestCheckerUpsertWithoutFormRequestFundToInput = {
    update: XOR<RequestCheckerUpdateWithoutFormRequestFundToInput, RequestCheckerUncheckedUpdateWithoutFormRequestFundToInput>
    create: XOR<RequestCheckerCreateWithoutFormRequestFundToInput, RequestCheckerUncheckedCreateWithoutFormRequestFundToInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutFormRequestFundToInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutFormRequestFundToInput, RequestCheckerUncheckedUpdateWithoutFormRequestFundToInput>
  }

  export type RequestCheckerUpdateWithoutFormRequestFundToInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutFormRequestFundToInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type MainRequestCreateWithoutApprovalInput = {
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
  }

  export type MainRequestUncheckedCreateWithoutApprovalInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
  }

  export type MainRequestCreateOrConnectWithoutApprovalInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsCreateWithoutApprovalInput = {
    checkerType: string
    createdAt?: Date | string
    approver?: RequestCheckerCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateWithoutApprovalInput = {
    id?: number
    checkerType: string
    approverId?: number | null
    createdAt?: Date | string
  }

  export type RequestLogsCreateOrConnectWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    create: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsCreateManyApprovalInputEnvelope = {
    data: RequestLogsCreateManyApprovalInput | RequestLogsCreateManyApprovalInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestUpsertWithoutApprovalInput = {
    update: XOR<MainRequestUpdateWithoutApprovalInput, MainRequestUncheckedUpdateWithoutApprovalInput>
    create: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutApprovalInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutApprovalInput, MainRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type MainRequestUpdateWithoutApprovalInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
  }

  export type RequestLogsUpsertWithWhereUniqueWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    update: XOR<RequestLogsUpdateWithoutApprovalInput, RequestLogsUncheckedUpdateWithoutApprovalInput>
    create: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsUpdateWithWhereUniqueWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    data: XOR<RequestLogsUpdateWithoutApprovalInput, RequestLogsUncheckedUpdateWithoutApprovalInput>
  }

  export type RequestLogsUpdateManyWithWhereWithoutApprovalInput = {
    where: RequestLogsScalarWhereInput
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyWithoutApprovalInput>
  }

  export type ApprovalTableCreateWithoutRequestLogsInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateWithoutRequestLogsInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovalTableCreateOrConnectWithoutRequestLogsInput = {
    where: ApprovalTableWhereUniqueInput
    create: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
  }

  export type RequestCheckerCreateWithoutRequestLogsInput = {
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checkerName?: UserCreateNestedOneWithoutCheckerInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
  }

  export type RequestCheckerUncheckedCreateWithoutRequestLogsInput = {
    id?: number
    userId?: number | null
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
  }

  export type RequestCheckerCreateOrConnectWithoutRequestLogsInput = {
    where: RequestCheckerWhereUniqueInput
    create: XOR<RequestCheckerCreateWithoutRequestLogsInput, RequestCheckerUncheckedCreateWithoutRequestLogsInput>
  }

  export type ApprovalTableUpsertWithoutRequestLogsInput = {
    update: XOR<ApprovalTableUpdateWithoutRequestLogsInput, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
    create: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    where?: ApprovalTableWhereInput
  }

  export type ApprovalTableUpdateToOneWithWhereWithoutRequestLogsInput = {
    where?: ApprovalTableWhereInput
    data: XOR<ApprovalTableUpdateWithoutRequestLogsInput, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
  }

  export type ApprovalTableUpdateWithoutRequestLogsInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateWithoutRequestLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCheckerUpsertWithoutRequestLogsInput = {
    update: XOR<RequestCheckerUpdateWithoutRequestLogsInput, RequestCheckerUncheckedUpdateWithoutRequestLogsInput>
    create: XOR<RequestCheckerCreateWithoutRequestLogsInput, RequestCheckerUncheckedCreateWithoutRequestLogsInput>
    where?: RequestCheckerWhereInput
  }

  export type RequestCheckerUpdateToOneWithWhereWithoutRequestLogsInput = {
    where?: RequestCheckerWhereInput
    data: XOR<RequestCheckerUpdateWithoutRequestLogsInput, RequestCheckerUncheckedUpdateWithoutRequestLogsInput>
  }

  export type RequestCheckerUpdateWithoutRequestLogsInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkerName?: UserUpdateOneWithoutCheckerNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutRequestLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
  }

  export type RequestCheckerCreateManyCheckerNameInput = {
    id?: number
    position: string
    initial: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MainRequestCreateManyRequestByInput = {
    id?: number
    requestTypeId?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestCheckerUpdateWithoutCheckerNameInput = {
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateWithoutCheckerNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RequestCheckerUncheckedUpdateManyWithoutCheckerNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    position?: StringFieldUpdateOperationsInput | string
    initial?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUpdateWithoutRequestByInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestCreateManyRequestFromInput = {
    id?: number
    requestTypeId?: number | null
    requestById?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checker?: RequestCheckerUpdateManyWithoutCheckerNameNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checker?: RequestCheckerUncheckedUpdateManyWithoutCheckerNameNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUpdateWithoutRequestFromInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestCreateManyRequestTypeInput = {
    id?: number
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestUpdateWithoutRequestTypeInput = {
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeCreateManyNotedByInput = {
    id?: number
    requestName: string
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyCheckedByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyCheckedBy2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyRecomApprovalInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyRecomApproval2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyApproveByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateManyRequestToInput = {
    id?: number
    mainRequestID?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestLogsCreateManyApproverInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    createdAt?: Date | string
  }

  export type RequestTypeUpdateWithoutNotedByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutNotedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutNotedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutCheckedByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutCheckedBy2Input = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutCheckedBy2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedBy2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutRecomApprovalInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutRecomApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutRecomApproval2Input = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    approveBy?: RequestCheckerUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutRecomApproval2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApproval2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutApproveByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: RequestCheckerUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: RequestCheckerUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: RequestCheckerUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: RequestCheckerUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: RequestCheckerUpdateOneWithoutRecomApproval2ForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutApproveByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutApproveByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUpdateWithoutRequestToInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutFundTransferNestedInput
  }

  export type FormFundTransferUncheckedUpdateWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUncheckedUpdateManyWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUpdateWithoutApproverInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableCreateManyMainRequestInput = {
    id?: number
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovalTableUpdateWithoutMainRequestInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateManyWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateManyApprovalInput = {
    id?: number
    checkerType: string
    approverId?: number | null
    createdAt?: Date | string
  }

  export type RequestLogsUpdateWithoutApprovalInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: RequestCheckerUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}