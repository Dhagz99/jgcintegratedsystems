
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model RequestType
 * 
 */
export type RequestType = $Result.DefaultSelection<Prisma.$RequestTypePayload>
/**
 * Model MainRequest
 * 
 */
export type MainRequest = $Result.DefaultSelection<Prisma.$MainRequestPayload>
/**
 * Model FormFundTransfer
 * 
 */
export type FormFundTransfer = $Result.DefaultSelection<Prisma.$FormFundTransferPayload>
/**
 * Model ApprovalTable
 * 
 */
export type ApprovalTable = $Result.DefaultSelection<Prisma.$ApprovalTablePayload>
/**
 * Model RequestLogs
 * 
 */
export type RequestLogs = $Result.DefaultSelection<Prisma.$RequestLogsPayload>
/**
 * Model formTravelOrder
 * 
 */
export type formTravelOrder = $Result.DefaultSelection<Prisma.$formTravelOrderPayload>
/**
 * Model formProposedBudget
 * 
 */
export type formProposedBudget = $Result.DefaultSelection<Prisma.$formProposedBudgetPayload>
/**
 * Model formTransmittalMemo
 * 
 */
export type formTransmittalMemo = $Result.DefaultSelection<Prisma.$formTransmittalMemoPayload>
/**
 * Model formDisburse
 * 
 */
export type formDisburse = $Result.DefaultSelection<Prisma.$formDisbursePayload>
/**
 * Model CountSheet
 * 
 */
export type CountSheet = $Result.DefaultSelection<Prisma.$CountSheetPayload>
/**
 * Model CashFund
 * 
 */
export type CashFund = $Result.DefaultSelection<Prisma.$CashFundPayload>
/**
 * Model TravelFund
 * 
 */
export type TravelFund = $Result.DefaultSelection<Prisma.$TravelFundPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Admin: 'Admin',
  User: 'User',
  Branch: 'Branch',
  Coordinator: 'Coordinator',
  Superadmin: 'Superadmin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Statuses: {
  PENDING: 'PENDING',
  INPROGRESS: 'INPROGRESS',
  CANCEL: 'CANCEL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EMPTY: 'EMPTY'
};

export type Statuses = (typeof Statuses)[keyof typeof Statuses]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Statuses = $Enums.Statuses

export const Statuses: typeof $Enums.Statuses

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestType`: Exposes CRUD operations for the **RequestType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestTypes
    * const requestTypes = await prisma.requestType.findMany()
    * ```
    */
  get requestType(): Prisma.RequestTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mainRequest`: Exposes CRUD operations for the **MainRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainRequests
    * const mainRequests = await prisma.mainRequest.findMany()
    * ```
    */
  get mainRequest(): Prisma.MainRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formFundTransfer`: Exposes CRUD operations for the **FormFundTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormFundTransfers
    * const formFundTransfers = await prisma.formFundTransfer.findMany()
    * ```
    */
  get formFundTransfer(): Prisma.FormFundTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvalTable`: Exposes CRUD operations for the **ApprovalTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalTables
    * const approvalTables = await prisma.approvalTable.findMany()
    * ```
    */
  get approvalTable(): Prisma.ApprovalTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestLogs`: Exposes CRUD operations for the **RequestLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestLogs
    * const requestLogs = await prisma.requestLogs.findMany()
    * ```
    */
  get requestLogs(): Prisma.RequestLogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formTravelOrder`: Exposes CRUD operations for the **formTravelOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTravelOrders
    * const formTravelOrders = await prisma.formTravelOrder.findMany()
    * ```
    */
  get formTravelOrder(): Prisma.formTravelOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formProposedBudget`: Exposes CRUD operations for the **formProposedBudget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormProposedBudgets
    * const formProposedBudgets = await prisma.formProposedBudget.findMany()
    * ```
    */
  get formProposedBudget(): Prisma.formProposedBudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formTransmittalMemo`: Exposes CRUD operations for the **formTransmittalMemo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTransmittalMemos
    * const formTransmittalMemos = await prisma.formTransmittalMemo.findMany()
    * ```
    */
  get formTransmittalMemo(): Prisma.formTransmittalMemoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formDisburse`: Exposes CRUD operations for the **formDisburse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormDisburses
    * const formDisburses = await prisma.formDisburse.findMany()
    * ```
    */
  get formDisburse(): Prisma.formDisburseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countSheet`: Exposes CRUD operations for the **CountSheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountSheets
    * const countSheets = await prisma.countSheet.findMany()
    * ```
    */
  get countSheet(): Prisma.CountSheetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashFund`: Exposes CRUD operations for the **CashFund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashFunds
    * const cashFunds = await prisma.cashFund.findMany()
    * ```
    */
  get cashFund(): Prisma.CashFundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.travelFund`: Exposes CRUD operations for the **TravelFund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TravelFunds
    * const travelFunds = await prisma.travelFund.findMany()
    * ```
    */
  get travelFund(): Prisma.TravelFundDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Branch: 'Branch',
    RequestType: 'RequestType',
    MainRequest: 'MainRequest',
    FormFundTransfer: 'FormFundTransfer',
    ApprovalTable: 'ApprovalTable',
    RequestLogs: 'RequestLogs',
    formTravelOrder: 'formTravelOrder',
    formProposedBudget: 'formProposedBudget',
    formTransmittalMemo: 'formTransmittalMemo',
    formDisburse: 'formDisburse',
    CountSheet: 'CountSheet',
    CashFund: 'CashFund',
    TravelFund: 'TravelFund'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "branch" | "requestType" | "mainRequest" | "formFundTransfer" | "approvalTable" | "requestLogs" | "formTravelOrder" | "formProposedBudget" | "formTransmittalMemo" | "formDisburse" | "countSheet" | "cashFund" | "travelFund"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      RequestType: {
        payload: Prisma.$RequestTypePayload<ExtArgs>
        fields: Prisma.RequestTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          findFirst: {
            args: Prisma.RequestTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          findMany: {
            args: Prisma.RequestTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          create: {
            args: Prisma.RequestTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          createMany: {
            args: Prisma.RequestTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          delete: {
            args: Prisma.RequestTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          update: {
            args: Prisma.RequestTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          deleteMany: {
            args: Prisma.RequestTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>[]
          }
          upsert: {
            args: Prisma.RequestTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestTypePayload>
          }
          aggregate: {
            args: Prisma.RequestTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestType>
          }
          groupBy: {
            args: Prisma.RequestTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RequestTypeCountAggregateOutputType> | number
          }
        }
      }
      MainRequest: {
        payload: Prisma.$MainRequestPayload<ExtArgs>
        fields: Prisma.MainRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MainRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MainRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          findFirst: {
            args: Prisma.MainRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MainRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          findMany: {
            args: Prisma.MainRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          create: {
            args: Prisma.MainRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          createMany: {
            args: Prisma.MainRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MainRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          delete: {
            args: Prisma.MainRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          update: {
            args: Prisma.MainRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          deleteMany: {
            args: Prisma.MainRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MainRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MainRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>[]
          }
          upsert: {
            args: Prisma.MainRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MainRequestPayload>
          }
          aggregate: {
            args: Prisma.MainRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMainRequest>
          }
          groupBy: {
            args: Prisma.MainRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MainRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MainRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MainRequestCountAggregateOutputType> | number
          }
        }
      }
      FormFundTransfer: {
        payload: Prisma.$FormFundTransferPayload<ExtArgs>
        fields: Prisma.FormFundTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFundTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFundTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          findFirst: {
            args: Prisma.FormFundTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFundTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          findMany: {
            args: Prisma.FormFundTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          create: {
            args: Prisma.FormFundTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          createMany: {
            args: Prisma.FormFundTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormFundTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          delete: {
            args: Prisma.FormFundTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          update: {
            args: Prisma.FormFundTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          deleteMany: {
            args: Prisma.FormFundTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormFundTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormFundTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>[]
          }
          upsert: {
            args: Prisma.FormFundTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFundTransferPayload>
          }
          aggregate: {
            args: Prisma.FormFundTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormFundTransfer>
          }
          groupBy: {
            args: Prisma.FormFundTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormFundTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormFundTransferCountArgs<ExtArgs>
            result: $Utils.Optional<FormFundTransferCountAggregateOutputType> | number
          }
        }
      }
      ApprovalTable: {
        payload: Prisma.$ApprovalTablePayload<ExtArgs>
        fields: Prisma.ApprovalTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          findFirst: {
            args: Prisma.ApprovalTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          findMany: {
            args: Prisma.ApprovalTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          create: {
            args: Prisma.ApprovalTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          createMany: {
            args: Prisma.ApprovalTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          delete: {
            args: Prisma.ApprovalTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          update: {
            args: Prisma.ApprovalTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          deleteMany: {
            args: Prisma.ApprovalTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>[]
          }
          upsert: {
            args: Prisma.ApprovalTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTablePayload>
          }
          aggregate: {
            args: Prisma.ApprovalTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalTable>
          }
          groupBy: {
            args: Prisma.ApprovalTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalTableCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTableCountAggregateOutputType> | number
          }
        }
      }
      RequestLogs: {
        payload: Prisma.$RequestLogsPayload<ExtArgs>
        fields: Prisma.RequestLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          findFirst: {
            args: Prisma.RequestLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          findMany: {
            args: Prisma.RequestLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          create: {
            args: Prisma.RequestLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          createMany: {
            args: Prisma.RequestLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestLogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          delete: {
            args: Prisma.RequestLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          update: {
            args: Prisma.RequestLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          deleteMany: {
            args: Prisma.RequestLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestLogsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>[]
          }
          upsert: {
            args: Prisma.RequestLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestLogsPayload>
          }
          aggregate: {
            args: Prisma.RequestLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestLogs>
          }
          groupBy: {
            args: Prisma.RequestLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestLogsCountArgs<ExtArgs>
            result: $Utils.Optional<RequestLogsCountAggregateOutputType> | number
          }
        }
      }
      formTravelOrder: {
        payload: Prisma.$formTravelOrderPayload<ExtArgs>
        fields: Prisma.formTravelOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formTravelOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formTravelOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          findFirst: {
            args: Prisma.formTravelOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formTravelOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          findMany: {
            args: Prisma.formTravelOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>[]
          }
          create: {
            args: Prisma.formTravelOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          createMany: {
            args: Prisma.formTravelOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.formTravelOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>[]
          }
          delete: {
            args: Prisma.formTravelOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          update: {
            args: Prisma.formTravelOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          deleteMany: {
            args: Prisma.formTravelOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formTravelOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.formTravelOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>[]
          }
          upsert: {
            args: Prisma.formTravelOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTravelOrderPayload>
          }
          aggregate: {
            args: Prisma.FormTravelOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormTravelOrder>
          }
          groupBy: {
            args: Prisma.formTravelOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormTravelOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.formTravelOrderCountArgs<ExtArgs>
            result: $Utils.Optional<FormTravelOrderCountAggregateOutputType> | number
          }
        }
      }
      formProposedBudget: {
        payload: Prisma.$formProposedBudgetPayload<ExtArgs>
        fields: Prisma.formProposedBudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formProposedBudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formProposedBudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          findFirst: {
            args: Prisma.formProposedBudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formProposedBudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          findMany: {
            args: Prisma.formProposedBudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>[]
          }
          create: {
            args: Prisma.formProposedBudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          createMany: {
            args: Prisma.formProposedBudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.formProposedBudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>[]
          }
          delete: {
            args: Prisma.formProposedBudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          update: {
            args: Prisma.formProposedBudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          deleteMany: {
            args: Prisma.formProposedBudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formProposedBudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.formProposedBudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>[]
          }
          upsert: {
            args: Prisma.formProposedBudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formProposedBudgetPayload>
          }
          aggregate: {
            args: Prisma.FormProposedBudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormProposedBudget>
          }
          groupBy: {
            args: Prisma.formProposedBudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormProposedBudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.formProposedBudgetCountArgs<ExtArgs>
            result: $Utils.Optional<FormProposedBudgetCountAggregateOutputType> | number
          }
        }
      }
      formTransmittalMemo: {
        payload: Prisma.$formTransmittalMemoPayload<ExtArgs>
        fields: Prisma.formTransmittalMemoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formTransmittalMemoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formTransmittalMemoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          findFirst: {
            args: Prisma.formTransmittalMemoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formTransmittalMemoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          findMany: {
            args: Prisma.formTransmittalMemoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>[]
          }
          create: {
            args: Prisma.formTransmittalMemoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          createMany: {
            args: Prisma.formTransmittalMemoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.formTransmittalMemoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>[]
          }
          delete: {
            args: Prisma.formTransmittalMemoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          update: {
            args: Prisma.formTransmittalMemoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          deleteMany: {
            args: Prisma.formTransmittalMemoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formTransmittalMemoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.formTransmittalMemoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>[]
          }
          upsert: {
            args: Prisma.formTransmittalMemoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formTransmittalMemoPayload>
          }
          aggregate: {
            args: Prisma.FormTransmittalMemoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormTransmittalMemo>
          }
          groupBy: {
            args: Prisma.formTransmittalMemoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormTransmittalMemoGroupByOutputType>[]
          }
          count: {
            args: Prisma.formTransmittalMemoCountArgs<ExtArgs>
            result: $Utils.Optional<FormTransmittalMemoCountAggregateOutputType> | number
          }
        }
      }
      formDisburse: {
        payload: Prisma.$formDisbursePayload<ExtArgs>
        fields: Prisma.formDisburseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formDisburseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formDisburseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          findFirst: {
            args: Prisma.formDisburseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formDisburseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          findMany: {
            args: Prisma.formDisburseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>[]
          }
          create: {
            args: Prisma.formDisburseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          createMany: {
            args: Prisma.formDisburseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.formDisburseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>[]
          }
          delete: {
            args: Prisma.formDisburseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          update: {
            args: Prisma.formDisburseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          deleteMany: {
            args: Prisma.formDisburseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formDisburseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.formDisburseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>[]
          }
          upsert: {
            args: Prisma.formDisburseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formDisbursePayload>
          }
          aggregate: {
            args: Prisma.FormDisburseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormDisburse>
          }
          groupBy: {
            args: Prisma.formDisburseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormDisburseGroupByOutputType>[]
          }
          count: {
            args: Prisma.formDisburseCountArgs<ExtArgs>
            result: $Utils.Optional<FormDisburseCountAggregateOutputType> | number
          }
        }
      }
      CountSheet: {
        payload: Prisma.$CountSheetPayload<ExtArgs>
        fields: Prisma.CountSheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountSheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountSheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          findFirst: {
            args: Prisma.CountSheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountSheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          findMany: {
            args: Prisma.CountSheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>[]
          }
          create: {
            args: Prisma.CountSheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          createMany: {
            args: Prisma.CountSheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountSheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>[]
          }
          delete: {
            args: Prisma.CountSheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          update: {
            args: Prisma.CountSheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          deleteMany: {
            args: Prisma.CountSheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountSheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountSheetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>[]
          }
          upsert: {
            args: Prisma.CountSheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountSheetPayload>
          }
          aggregate: {
            args: Prisma.CountSheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountSheet>
          }
          groupBy: {
            args: Prisma.CountSheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountSheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountSheetCountArgs<ExtArgs>
            result: $Utils.Optional<CountSheetCountAggregateOutputType> | number
          }
        }
      }
      CashFund: {
        payload: Prisma.$CashFundPayload<ExtArgs>
        fields: Prisma.CashFundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashFundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashFundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          findFirst: {
            args: Prisma.CashFundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashFundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          findMany: {
            args: Prisma.CashFundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>[]
          }
          create: {
            args: Prisma.CashFundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          createMany: {
            args: Prisma.CashFundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashFundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>[]
          }
          delete: {
            args: Prisma.CashFundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          update: {
            args: Prisma.CashFundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          deleteMany: {
            args: Prisma.CashFundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashFundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashFundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>[]
          }
          upsert: {
            args: Prisma.CashFundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFundPayload>
          }
          aggregate: {
            args: Prisma.CashFundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashFund>
          }
          groupBy: {
            args: Prisma.CashFundGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashFundGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashFundCountArgs<ExtArgs>
            result: $Utils.Optional<CashFundCountAggregateOutputType> | number
          }
        }
      }
      TravelFund: {
        payload: Prisma.$TravelFundPayload<ExtArgs>
        fields: Prisma.TravelFundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TravelFundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TravelFundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          findFirst: {
            args: Prisma.TravelFundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TravelFundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          findMany: {
            args: Prisma.TravelFundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>[]
          }
          create: {
            args: Prisma.TravelFundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          createMany: {
            args: Prisma.TravelFundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TravelFundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>[]
          }
          delete: {
            args: Prisma.TravelFundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          update: {
            args: Prisma.TravelFundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          deleteMany: {
            args: Prisma.TravelFundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TravelFundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TravelFundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>[]
          }
          upsert: {
            args: Prisma.TravelFundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelFundPayload>
          }
          aggregate: {
            args: Prisma.TravelFundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTravelFund>
          }
          groupBy: {
            args: Prisma.TravelFundGroupByArgs<ExtArgs>
            result: $Utils.Optional<TravelFundGroupByOutputType>[]
          }
          count: {
            args: Prisma.TravelFundCountArgs<ExtArgs>
            result: $Utils.Optional<TravelFundCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    branch?: BranchOmit
    requestType?: RequestTypeOmit
    mainRequest?: MainRequestOmit
    formFundTransfer?: FormFundTransferOmit
    approvalTable?: ApprovalTableOmit
    requestLogs?: RequestLogsOmit
    formTravelOrder?: formTravelOrderOmit
    formProposedBudget?: formProposedBudgetOmit
    formTransmittalMemo?: formTransmittalMemoOmit
    formDisburse?: formDisburseOmit
    countSheet?: CountSheetOmit
    cashFund?: CashFundOmit
    travelFund?: TravelFundOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notedByForTypes: number
    checkedByForTypes: number
    checkedBy2ForTypes: number
    recomApprovalForTypes: number
    recomApproval2ForTypes: number
    approveByForTypes: number
    formRequestFundTo: number
    formRequestTransmittalTo: number
    formRequestDisburseTo: number
    requestLogs: number
    mainForm: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedByForTypes?: boolean | UserCountOutputTypeCountNotedByForTypesArgs
    checkedByForTypes?: boolean | UserCountOutputTypeCountCheckedByForTypesArgs
    checkedBy2ForTypes?: boolean | UserCountOutputTypeCountCheckedBy2ForTypesArgs
    recomApprovalForTypes?: boolean | UserCountOutputTypeCountRecomApprovalForTypesArgs
    recomApproval2ForTypes?: boolean | UserCountOutputTypeCountRecomApproval2ForTypesArgs
    approveByForTypes?: boolean | UserCountOutputTypeCountApproveByForTypesArgs
    formRequestFundTo?: boolean | UserCountOutputTypeCountFormRequestFundToArgs
    formRequestTransmittalTo?: boolean | UserCountOutputTypeCountFormRequestTransmittalToArgs
    formRequestDisburseTo?: boolean | UserCountOutputTypeCountFormRequestDisburseToArgs
    requestLogs?: boolean | UserCountOutputTypeCountRequestLogsArgs
    mainForm?: boolean | UserCountOutputTypeCountMainFormArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckedBy2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecomApprovalForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecomApproval2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApproveByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormRequestFundToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFundTransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormRequestTransmittalToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formTransmittalMemoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormRequestDisburseToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formDisburseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    users: number
    main: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    main?: boolean | BranchCountOutputTypeCountMainArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountMainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type RequestTypeCountOutputType
   */

  export type RequestTypeCountOutputType = {
    mainRequests: number
  }

  export type RequestTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequests?: boolean | RequestTypeCountOutputTypeCountMainRequestsArgs
  }

  // Custom InputTypes
  /**
   * RequestTypeCountOutputType without action
   */
  export type RequestTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestTypeCountOutputType
     */
    select?: RequestTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestTypeCountOutputType without action
   */
  export type RequestTypeCountOutputTypeCountMainRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
  }


  /**
   * Count Type MainRequestCountOutputType
   */

  export type MainRequestCountOutputType = {
    approval: number
    proposedBudget: number
  }

  export type MainRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | MainRequestCountOutputTypeCountApprovalArgs
    proposedBudget?: boolean | MainRequestCountOutputTypeCountProposedBudgetArgs
  }

  // Custom InputTypes
  /**
   * MainRequestCountOutputType without action
   */
  export type MainRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequestCountOutputType
     */
    select?: MainRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MainRequestCountOutputType without action
   */
  export type MainRequestCountOutputTypeCountApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTableWhereInput
  }

  /**
   * MainRequestCountOutputType without action
   */
  export type MainRequestCountOutputTypeCountProposedBudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formProposedBudgetWhereInput
  }


  /**
   * Count Type ApprovalTableCountOutputType
   */

  export type ApprovalTableCountOutputType = {
    requestLogs: number
  }

  export type ApprovalTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestLogs?: boolean | ApprovalTableCountOutputTypeCountRequestLogsArgs
  }

  // Custom InputTypes
  /**
   * ApprovalTableCountOutputType without action
   */
  export type ApprovalTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTableCountOutputType
     */
    select?: ApprovalTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalTableCountOutputType without action
   */
  export type ApprovalTableCountOutputTypeCountRequestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
  }


  /**
   * Count Type CountSheetCountOutputType
   */

  export type CountSheetCountOutputType = {
    CashCountSheet: number
    TravelCountSheet: number
  }

  export type CountSheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CashCountSheet?: boolean | CountSheetCountOutputTypeCountCashCountSheetArgs
    TravelCountSheet?: boolean | CountSheetCountOutputTypeCountTravelCountSheetArgs
  }

  // Custom InputTypes
  /**
   * CountSheetCountOutputType without action
   */
  export type CountSheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheetCountOutputType
     */
    select?: CountSheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountSheetCountOutputType without action
   */
  export type CountSheetCountOutputTypeCountCashCountSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFundWhereInput
  }

  /**
   * CountSheetCountOutputType without action
   */
  export type CountSheetCountOutputTypeCountTravelCountSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelFundWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    branchId: number | null
    signatureUrl: string | null
    position: string | null
    initial: string | null
    approver: boolean | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    branchId: number | null
    signatureUrl: string | null
    position: string | null
    initial: string | null
    approver: boolean | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    username: number
    password: number
    role: number
    branchId: number
    signatureUrl: number
    position: number
    initial: number
    approver: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    signatureUrl?: true
    position?: true
    initial?: true
    approver?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    signatureUrl?: true
    position?: true
    initial?: true
    approver?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    role?: true
    branchId?: true
    signatureUrl?: true
    position?: true
    initial?: true
    approver?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    username: string
    password: string
    role: $Enums.Role
    branchId: number | null
    signatureUrl: string | null
    position: string | null
    initial: string | null
    approver: boolean
    createdAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    signatureUrl?: boolean
    position?: boolean
    initial?: boolean
    approver?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    notedByForTypes?: boolean | User$notedByForTypesArgs<ExtArgs>
    checkedByForTypes?: boolean | User$checkedByForTypesArgs<ExtArgs>
    checkedBy2ForTypes?: boolean | User$checkedBy2ForTypesArgs<ExtArgs>
    recomApprovalForTypes?: boolean | User$recomApprovalForTypesArgs<ExtArgs>
    recomApproval2ForTypes?: boolean | User$recomApproval2ForTypesArgs<ExtArgs>
    approveByForTypes?: boolean | User$approveByForTypesArgs<ExtArgs>
    formRequestFundTo?: boolean | User$formRequestFundToArgs<ExtArgs>
    formRequestTransmittalTo?: boolean | User$formRequestTransmittalToArgs<ExtArgs>
    formRequestDisburseTo?: boolean | User$formRequestDisburseToArgs<ExtArgs>
    requestLogs?: boolean | User$requestLogsArgs<ExtArgs>
    mainForm?: boolean | User$mainFormArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    signatureUrl?: boolean
    position?: boolean
    initial?: boolean
    approver?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    signatureUrl?: boolean
    position?: boolean
    initial?: boolean
    approver?: boolean
    createdAt?: boolean
    updateAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    branchId?: boolean
    signatureUrl?: boolean
    position?: boolean
    initial?: boolean
    approver?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "username" | "password" | "role" | "branchId" | "signatureUrl" | "position" | "initial" | "approver" | "createdAt" | "updateAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    notedByForTypes?: boolean | User$notedByForTypesArgs<ExtArgs>
    checkedByForTypes?: boolean | User$checkedByForTypesArgs<ExtArgs>
    checkedBy2ForTypes?: boolean | User$checkedBy2ForTypesArgs<ExtArgs>
    recomApprovalForTypes?: boolean | User$recomApprovalForTypesArgs<ExtArgs>
    recomApproval2ForTypes?: boolean | User$recomApproval2ForTypesArgs<ExtArgs>
    approveByForTypes?: boolean | User$approveByForTypesArgs<ExtArgs>
    formRequestFundTo?: boolean | User$formRequestFundToArgs<ExtArgs>
    formRequestTransmittalTo?: boolean | User$formRequestTransmittalToArgs<ExtArgs>
    formRequestDisburseTo?: boolean | User$formRequestDisburseToArgs<ExtArgs>
    requestLogs?: boolean | User$requestLogsArgs<ExtArgs>
    mainForm?: boolean | User$mainFormArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      notedByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      checkedByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      checkedBy2ForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      recomApprovalForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      recomApproval2ForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      approveByForTypes: Prisma.$RequestTypePayload<ExtArgs>[]
      formRequestFundTo: Prisma.$FormFundTransferPayload<ExtArgs>[]
      formRequestTransmittalTo: Prisma.$formTransmittalMemoPayload<ExtArgs>[]
      formRequestDisburseTo: Prisma.$formDisbursePayload<ExtArgs>[]
      requestLogs: Prisma.$RequestLogsPayload<ExtArgs>[]
      mainForm: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      username: string
      password: string
      role: $Enums.Role
      branchId: number | null
      signatureUrl: string | null
      position: string | null
      initial: string | null
      approver: boolean
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notedByForTypes<T extends User$notedByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$notedByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkedByForTypes<T extends User$checkedByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$checkedByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkedBy2ForTypes<T extends User$checkedBy2ForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$checkedBy2ForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recomApprovalForTypes<T extends User$recomApprovalForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$recomApprovalForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recomApproval2ForTypes<T extends User$recomApproval2ForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$recomApproval2ForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approveByForTypes<T extends User$approveByForTypesArgs<ExtArgs> = {}>(args?: Subset<T, User$approveByForTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formRequestFundTo<T extends User$formRequestFundToArgs<ExtArgs> = {}>(args?: Subset<T, User$formRequestFundToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formRequestTransmittalTo<T extends User$formRequestTransmittalToArgs<ExtArgs> = {}>(args?: Subset<T, User$formRequestTransmittalToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formRequestDisburseTo<T extends User$formRequestDisburseToArgs<ExtArgs> = {}>(args?: Subset<T, User$formRequestDisburseToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestLogs<T extends User$requestLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$requestLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mainForm<T extends User$mainFormArgs<ExtArgs> = {}>(args?: Subset<T, User$mainFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly signatureUrl: FieldRef<"User", 'String'>
    readonly position: FieldRef<"User", 'String'>
    readonly initial: FieldRef<"User", 'String'>
    readonly approver: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updateAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.notedByForTypes
   */
  export type User$notedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.checkedByForTypes
   */
  export type User$checkedByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.checkedBy2ForTypes
   */
  export type User$checkedBy2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.recomApprovalForTypes
   */
  export type User$recomApprovalForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.recomApproval2ForTypes
   */
  export type User$recomApproval2ForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.approveByForTypes
   */
  export type User$approveByForTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    cursor?: RequestTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * User.formRequestFundTo
   */
  export type User$formRequestFundToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    where?: FormFundTransferWhereInput
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    cursor?: FormFundTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * User.formRequestTransmittalTo
   */
  export type User$formRequestTransmittalToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    where?: formTransmittalMemoWhereInput
    orderBy?: formTransmittalMemoOrderByWithRelationInput | formTransmittalMemoOrderByWithRelationInput[]
    cursor?: formTransmittalMemoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormTransmittalMemoScalarFieldEnum | FormTransmittalMemoScalarFieldEnum[]
  }

  /**
   * User.formRequestDisburseTo
   */
  export type User$formRequestDisburseToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    where?: formDisburseWhereInput
    orderBy?: formDisburseOrderByWithRelationInput | formDisburseOrderByWithRelationInput[]
    cursor?: formDisburseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormDisburseScalarFieldEnum | FormDisburseScalarFieldEnum[]
  }

  /**
   * User.requestLogs
   */
  export type User$requestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    cursor?: RequestLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * User.mainForm
   */
  export type User$mainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    branchCode: string | null
    branchName: string | null
    bom: string | null
    faa: string | null
    telephone: string | null
    address: string | null
    companyName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    branchCode: string | null
    branchName: string | null
    bom: string | null
    faa: string | null
    telephone: string | null
    address: string | null
    companyName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    branchCode: number
    branchName: number
    bom: number
    faa: number
    telephone: number
    address: number
    companyName: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    branchCode?: true
    branchName?: true
    bom?: true
    faa?: true
    telephone?: true
    address?: true
    companyName?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt: Date
    updateAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
    users?: boolean | Branch$usersArgs<ExtArgs>
    main?: boolean | Branch$mainArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    branchCode?: boolean
    branchName?: boolean
    bom?: boolean
    faa?: boolean
    telephone?: boolean
    address?: boolean
    companyName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branchCode" | "branchName" | "bom" | "faa" | "telephone" | "address" | "companyName" | "createdAt" | "updateAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Branch$usersArgs<ExtArgs>
    main?: boolean | Branch$mainArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      main: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchCode: string
      branchName: string
      bom: string
      faa: string
      telephone: string
      address: string
      companyName: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    main<T extends Branch$mainArgs<ExtArgs> = {}>(args?: Subset<T, Branch$mainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly branchCode: FieldRef<"Branch", 'String'>
    readonly branchName: FieldRef<"Branch", 'String'>
    readonly bom: FieldRef<"Branch", 'String'>
    readonly faa: FieldRef<"Branch", 'String'>
    readonly telephone: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly companyName: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updateAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.main
   */
  export type Branch$mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model RequestType
   */

  export type AggregateRequestType = {
    _count: RequestTypeCountAggregateOutputType | null
    _avg: RequestTypeAvgAggregateOutputType | null
    _sum: RequestTypeSumAggregateOutputType | null
    _min: RequestTypeMinAggregateOutputType | null
    _max: RequestTypeMaxAggregateOutputType | null
  }

  export type RequestTypeAvgAggregateOutputType = {
    id: number | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
  }

  export type RequestTypeSumAggregateOutputType = {
    id: number | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
  }

  export type RequestTypeMinAggregateOutputType = {
    id: number | null
    requestName: string | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type RequestTypeMaxAggregateOutputType = {
    id: number | null
    requestName: string | null
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type RequestTypeCountAggregateOutputType = {
    id: number
    requestName: number
    notedById: number
    checkedById: number
    checkedBy2Id: number
    recomApprovalId: number
    recomApproval2Id: number
    approveById: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type RequestTypeAvgAggregateInputType = {
    id?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
  }

  export type RequestTypeSumAggregateInputType = {
    id?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
  }

  export type RequestTypeMinAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
  }

  export type RequestTypeMaxAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
  }

  export type RequestTypeCountAggregateInputType = {
    id?: true
    requestName?: true
    notedById?: true
    checkedById?: true
    checkedBy2Id?: true
    recomApprovalId?: true
    recomApproval2Id?: true
    approveById?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type RequestTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestType to aggregate.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestTypes
    **/
    _count?: true | RequestTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestTypeMaxAggregateInputType
  }

  export type GetRequestTypeAggregateType<T extends RequestTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestType[P]>
      : GetScalarType<T[P], AggregateRequestType[P]>
  }




  export type RequestTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestTypeWhereInput
    orderBy?: RequestTypeOrderByWithAggregationInput | RequestTypeOrderByWithAggregationInput[]
    by: RequestTypeScalarFieldEnum[] | RequestTypeScalarFieldEnum
    having?: RequestTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestTypeCountAggregateInputType | true
    _avg?: RequestTypeAvgAggregateInputType
    _sum?: RequestTypeSumAggregateInputType
    _min?: RequestTypeMinAggregateInputType
    _max?: RequestTypeMaxAggregateInputType
  }

  export type RequestTypeGroupByOutputType = {
    id: number
    requestName: string
    notedById: number | null
    checkedById: number | null
    checkedBy2Id: number | null
    recomApprovalId: number | null
    recomApproval2Id: number | null
    approveById: number | null
    createdAt: Date
    updateAt: Date
    _count: RequestTypeCountAggregateOutputType | null
    _avg: RequestTypeAvgAggregateOutputType | null
    _sum: RequestTypeSumAggregateOutputType | null
    _min: RequestTypeMinAggregateOutputType | null
    _max: RequestTypeMaxAggregateOutputType | null
  }

  type GetRequestTypeGroupByPayload<T extends RequestTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RequestTypeGroupByOutputType[P]>
        }
      >
    >


  export type RequestTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
    mainRequests?: boolean | RequestType$mainRequestsArgs<ExtArgs>
    _count?: boolean | RequestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }, ExtArgs["result"]["requestType"]>

  export type RequestTypeSelectScalar = {
    id?: boolean
    requestName?: boolean
    notedById?: boolean
    checkedById?: boolean
    checkedBy2Id?: boolean
    recomApprovalId?: boolean
    recomApproval2Id?: boolean
    approveById?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type RequestTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestName" | "notedById" | "checkedById" | "checkedBy2Id" | "recomApprovalId" | "recomApproval2Id" | "approveById" | "createdAt" | "updateAt", ExtArgs["result"]["requestType"]>
  export type RequestTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
    mainRequests?: boolean | RequestType$mainRequestsArgs<ExtArgs>
    _count?: boolean | RequestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }
  export type RequestTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notedBy?: boolean | RequestType$notedByArgs<ExtArgs>
    checkedBy?: boolean | RequestType$checkedByArgs<ExtArgs>
    checkedBy2?: boolean | RequestType$checkedBy2Args<ExtArgs>
    recomApproval?: boolean | RequestType$recomApprovalArgs<ExtArgs>
    recomApproval2?: boolean | RequestType$recomApproval2Args<ExtArgs>
    approveBy?: boolean | RequestType$approveByArgs<ExtArgs>
  }

  export type $RequestTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestType"
    objects: {
      notedBy: Prisma.$UserPayload<ExtArgs> | null
      checkedBy: Prisma.$UserPayload<ExtArgs> | null
      checkedBy2: Prisma.$UserPayload<ExtArgs> | null
      recomApproval: Prisma.$UserPayload<ExtArgs> | null
      recomApproval2: Prisma.$UserPayload<ExtArgs> | null
      approveBy: Prisma.$UserPayload<ExtArgs> | null
      mainRequests: Prisma.$MainRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestName: string
      notedById: number | null
      checkedById: number | null
      checkedBy2Id: number | null
      recomApprovalId: number | null
      recomApproval2Id: number | null
      approveById: number | null
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["requestType"]>
    composites: {}
  }

  type RequestTypeGetPayload<S extends boolean | null | undefined | RequestTypeDefaultArgs> = $Result.GetResult<Prisma.$RequestTypePayload, S>

  type RequestTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestTypeCountAggregateInputType | true
    }

  export interface RequestTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestType'], meta: { name: 'RequestType' } }
    /**
     * Find zero or one RequestType that matches the filter.
     * @param {RequestTypeFindUniqueArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestTypeFindUniqueArgs>(args: SelectSubset<T, RequestTypeFindUniqueArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestTypeFindUniqueOrThrowArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindFirstArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestTypeFindFirstArgs>(args?: SelectSubset<T, RequestTypeFindFirstArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindFirstOrThrowArgs} args - Arguments to find a RequestType
     * @example
     * // Get one RequestType
     * const requestType = await prisma.requestType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestTypes
     * const requestTypes = await prisma.requestType.findMany()
     * 
     * // Get first 10 RequestTypes
     * const requestTypes = await prisma.requestType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestTypeFindManyArgs>(args?: SelectSubset<T, RequestTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestType.
     * @param {RequestTypeCreateArgs} args - Arguments to create a RequestType.
     * @example
     * // Create one RequestType
     * const RequestType = await prisma.requestType.create({
     *   data: {
     *     // ... data to create a RequestType
     *   }
     * })
     * 
     */
    create<T extends RequestTypeCreateArgs>(args: SelectSubset<T, RequestTypeCreateArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestTypes.
     * @param {RequestTypeCreateManyArgs} args - Arguments to create many RequestTypes.
     * @example
     * // Create many RequestTypes
     * const requestType = await prisma.requestType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestTypeCreateManyArgs>(args?: SelectSubset<T, RequestTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestTypes and returns the data saved in the database.
     * @param {RequestTypeCreateManyAndReturnArgs} args - Arguments to create many RequestTypes.
     * @example
     * // Create many RequestTypes
     * const requestType = await prisma.requestType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestTypes and only return the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestType.
     * @param {RequestTypeDeleteArgs} args - Arguments to delete one RequestType.
     * @example
     * // Delete one RequestType
     * const RequestType = await prisma.requestType.delete({
     *   where: {
     *     // ... filter to delete one RequestType
     *   }
     * })
     * 
     */
    delete<T extends RequestTypeDeleteArgs>(args: SelectSubset<T, RequestTypeDeleteArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestType.
     * @param {RequestTypeUpdateArgs} args - Arguments to update one RequestType.
     * @example
     * // Update one RequestType
     * const requestType = await prisma.requestType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestTypeUpdateArgs>(args: SelectSubset<T, RequestTypeUpdateArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestTypes.
     * @param {RequestTypeDeleteManyArgs} args - Arguments to filter RequestTypes to delete.
     * @example
     * // Delete a few RequestTypes
     * const { count } = await prisma.requestType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestTypeDeleteManyArgs>(args?: SelectSubset<T, RequestTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestTypes
     * const requestType = await prisma.requestType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestTypeUpdateManyArgs>(args: SelectSubset<T, RequestTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestTypes and returns the data updated in the database.
     * @param {RequestTypeUpdateManyAndReturnArgs} args - Arguments to update many RequestTypes.
     * @example
     * // Update many RequestTypes
     * const requestType = await prisma.requestType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestTypes and only return the `id`
     * const requestTypeWithIdOnly = await prisma.requestType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestType.
     * @param {RequestTypeUpsertArgs} args - Arguments to update or create a RequestType.
     * @example
     * // Update or create a RequestType
     * const requestType = await prisma.requestType.upsert({
     *   create: {
     *     // ... data to create a RequestType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestType we want to update
     *   }
     * })
     */
    upsert<T extends RequestTypeUpsertArgs>(args: SelectSubset<T, RequestTypeUpsertArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeCountArgs} args - Arguments to filter RequestTypes to count.
     * @example
     * // Count the number of RequestTypes
     * const count = await prisma.requestType.count({
     *   where: {
     *     // ... the filter for the RequestTypes we want to count
     *   }
     * })
    **/
    count<T extends RequestTypeCountArgs>(
      args?: Subset<T, RequestTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestTypeAggregateArgs>(args: Subset<T, RequestTypeAggregateArgs>): Prisma.PrismaPromise<GetRequestTypeAggregateType<T>>

    /**
     * Group by RequestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestTypeGroupByArgs['orderBy'] }
        : { orderBy?: RequestTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestType model
   */
  readonly fields: RequestTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notedBy<T extends RequestType$notedByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$notedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checkedBy<T extends RequestType$checkedByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$checkedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checkedBy2<T extends RequestType$checkedBy2Args<ExtArgs> = {}>(args?: Subset<T, RequestType$checkedBy2Args<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recomApproval<T extends RequestType$recomApprovalArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$recomApprovalArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recomApproval2<T extends RequestType$recomApproval2Args<ExtArgs> = {}>(args?: Subset<T, RequestType$recomApproval2Args<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approveBy<T extends RequestType$approveByArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$approveByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mainRequests<T extends RequestType$mainRequestsArgs<ExtArgs> = {}>(args?: Subset<T, RequestType$mainRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestType model
   */
  interface RequestTypeFieldRefs {
    readonly id: FieldRef<"RequestType", 'Int'>
    readonly requestName: FieldRef<"RequestType", 'String'>
    readonly notedById: FieldRef<"RequestType", 'Int'>
    readonly checkedById: FieldRef<"RequestType", 'Int'>
    readonly checkedBy2Id: FieldRef<"RequestType", 'Int'>
    readonly recomApprovalId: FieldRef<"RequestType", 'Int'>
    readonly recomApproval2Id: FieldRef<"RequestType", 'Int'>
    readonly approveById: FieldRef<"RequestType", 'Int'>
    readonly createdAt: FieldRef<"RequestType", 'DateTime'>
    readonly updateAt: FieldRef<"RequestType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestType findUnique
   */
  export type RequestTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType findUniqueOrThrow
   */
  export type RequestTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType findFirst
   */
  export type RequestTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestTypes.
     */
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType findFirstOrThrow
   */
  export type RequestTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestType to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestTypes.
     */
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType findMany
   */
  export type RequestTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter, which RequestTypes to fetch.
     */
    where?: RequestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestTypes to fetch.
     */
    orderBy?: RequestTypeOrderByWithRelationInput | RequestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestTypes.
     */
    cursor?: RequestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestTypes.
     */
    skip?: number
    distinct?: RequestTypeScalarFieldEnum | RequestTypeScalarFieldEnum[]
  }

  /**
   * RequestType create
   */
  export type RequestTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestType.
     */
    data: XOR<RequestTypeCreateInput, RequestTypeUncheckedCreateInput>
  }

  /**
   * RequestType createMany
   */
  export type RequestTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestTypes.
     */
    data: RequestTypeCreateManyInput | RequestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestType createManyAndReturn
   */
  export type RequestTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * The data used to create many RequestTypes.
     */
    data: RequestTypeCreateManyInput | RequestTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestType update
   */
  export type RequestTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestType.
     */
    data: XOR<RequestTypeUpdateInput, RequestTypeUncheckedUpdateInput>
    /**
     * Choose, which RequestType to update.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType updateMany
   */
  export type RequestTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestTypes.
     */
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyInput>
    /**
     * Filter which RequestTypes to update
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to update.
     */
    limit?: number
  }

  /**
   * RequestType updateManyAndReturn
   */
  export type RequestTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * The data used to update RequestTypes.
     */
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyInput>
    /**
     * Filter which RequestTypes to update
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestType upsert
   */
  export type RequestTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestType to update in case it exists.
     */
    where: RequestTypeWhereUniqueInput
    /**
     * In case the RequestType found by the `where` argument doesn't exist, create a new RequestType with this data.
     */
    create: XOR<RequestTypeCreateInput, RequestTypeUncheckedCreateInput>
    /**
     * In case the RequestType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestTypeUpdateInput, RequestTypeUncheckedUpdateInput>
  }

  /**
   * RequestType delete
   */
  export type RequestTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    /**
     * Filter which RequestType to delete.
     */
    where: RequestTypeWhereUniqueInput
  }

  /**
   * RequestType deleteMany
   */
  export type RequestTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestTypes to delete
     */
    where?: RequestTypeWhereInput
    /**
     * Limit how many RequestTypes to delete.
     */
    limit?: number
  }

  /**
   * RequestType.notedBy
   */
  export type RequestType$notedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.checkedBy
   */
  export type RequestType$checkedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.checkedBy2
   */
  export type RequestType$checkedBy2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.recomApproval
   */
  export type RequestType$recomApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.recomApproval2
   */
  export type RequestType$recomApproval2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.approveBy
   */
  export type RequestType$approveByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestType.mainRequests
   */
  export type RequestType$mainRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    cursor?: MainRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * RequestType without action
   */
  export type RequestTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
  }


  /**
   * Model MainRequest
   */

  export type AggregateMainRequest = {
    _count: MainRequestCountAggregateOutputType | null
    _avg: MainRequestAvgAggregateOutputType | null
    _sum: MainRequestSumAggregateOutputType | null
    _min: MainRequestMinAggregateOutputType | null
    _max: MainRequestMaxAggregateOutputType | null
  }

  export type MainRequestAvgAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
  }

  export type MainRequestSumAggregateOutputType = {
    id: number | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
  }

  export type MainRequestMinAggregateOutputType = {
    id: number | null
    referenceCode: string | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses | null
    requestDate: Date | null
    remarks: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MainRequestMaxAggregateOutputType = {
    id: number | null
    referenceCode: string | null
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses | null
    requestDate: Date | null
    remarks: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MainRequestCountAggregateOutputType = {
    id: number
    referenceCode: number
    requestTypeId: number
    requestById: number
    requestFromId: number
    status: number
    requestDate: number
    remarks: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type MainRequestAvgAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
  }

  export type MainRequestSumAggregateInputType = {
    id?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
  }

  export type MainRequestMinAggregateInputType = {
    id?: true
    referenceCode?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
  }

  export type MainRequestMaxAggregateInputType = {
    id?: true
    referenceCode?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
  }

  export type MainRequestCountAggregateInputType = {
    id?: true
    referenceCode?: true
    requestTypeId?: true
    requestById?: true
    requestFromId?: true
    status?: true
    requestDate?: true
    remarks?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type MainRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainRequest to aggregate.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainRequests
    **/
    _count?: true | MainRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainRequestMaxAggregateInputType
  }

  export type GetMainRequestAggregateType<T extends MainRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMainRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainRequest[P]>
      : GetScalarType<T[P], AggregateMainRequest[P]>
  }




  export type MainRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MainRequestWhereInput
    orderBy?: MainRequestOrderByWithAggregationInput | MainRequestOrderByWithAggregationInput[]
    by: MainRequestScalarFieldEnum[] | MainRequestScalarFieldEnum
    having?: MainRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainRequestCountAggregateInputType | true
    _avg?: MainRequestAvgAggregateInputType
    _sum?: MainRequestSumAggregateInputType
    _min?: MainRequestMinAggregateInputType
    _max?: MainRequestMaxAggregateInputType
  }

  export type MainRequestGroupByOutputType = {
    id: number
    referenceCode: string
    requestTypeId: number | null
    requestById: number | null
    requestFromId: number | null
    status: $Enums.Statuses
    requestDate: Date
    remarks: string | null
    createdAt: Date
    updateAt: Date
    _count: MainRequestCountAggregateOutputType | null
    _avg: MainRequestAvgAggregateOutputType | null
    _sum: MainRequestSumAggregateOutputType | null
    _min: MainRequestMinAggregateOutputType | null
    _max: MainRequestMaxAggregateOutputType | null
  }

  type GetMainRequestGroupByPayload<T extends MainRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MainRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MainRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MainRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MainRequestGroupByOutputType[P]>
        }
      >
    >


  export type MainRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceCode?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    fundTransfer?: boolean | MainRequest$fundTransferArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
    approval?: boolean | MainRequest$approvalArgs<ExtArgs>
    travelOrder?: boolean | MainRequest$travelOrderArgs<ExtArgs>
    transmittalMemo?: boolean | MainRequest$transmittalMemoArgs<ExtArgs>
    proposedBudget?: boolean | MainRequest$proposedBudgetArgs<ExtArgs>
    disburse?: boolean | MainRequest$disburseArgs<ExtArgs>
    countSheet?: boolean | MainRequest$countSheetArgs<ExtArgs>
    _count?: boolean | MainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceCode?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceCode?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }, ExtArgs["result"]["mainRequest"]>

  export type MainRequestSelectScalar = {
    id?: boolean
    referenceCode?: boolean
    requestTypeId?: boolean
    requestById?: boolean
    requestFromId?: boolean
    status?: boolean
    requestDate?: boolean
    remarks?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type MainRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceCode" | "requestTypeId" | "requestById" | "requestFromId" | "status" | "requestDate" | "remarks" | "createdAt" | "updateAt", ExtArgs["result"]["mainRequest"]>
  export type MainRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    fundTransfer?: boolean | MainRequest$fundTransferArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
    approval?: boolean | MainRequest$approvalArgs<ExtArgs>
    travelOrder?: boolean | MainRequest$travelOrderArgs<ExtArgs>
    transmittalMemo?: boolean | MainRequest$transmittalMemoArgs<ExtArgs>
    proposedBudget?: boolean | MainRequest$proposedBudgetArgs<ExtArgs>
    disburse?: boolean | MainRequest$disburseArgs<ExtArgs>
    countSheet?: boolean | MainRequest$countSheetArgs<ExtArgs>
    _count?: boolean | MainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MainRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }
  export type MainRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestType?: boolean | MainRequest$requestTypeArgs<ExtArgs>
    requestBy?: boolean | MainRequest$requestByArgs<ExtArgs>
    requestFrom?: boolean | MainRequest$requestFromArgs<ExtArgs>
  }

  export type $MainRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MainRequest"
    objects: {
      requestType: Prisma.$RequestTypePayload<ExtArgs> | null
      fundTransfer: Prisma.$FormFundTransferPayload<ExtArgs> | null
      requestBy: Prisma.$UserPayload<ExtArgs> | null
      requestFrom: Prisma.$BranchPayload<ExtArgs> | null
      approval: Prisma.$ApprovalTablePayload<ExtArgs>[]
      travelOrder: Prisma.$formTravelOrderPayload<ExtArgs> | null
      transmittalMemo: Prisma.$formTransmittalMemoPayload<ExtArgs> | null
      proposedBudget: Prisma.$formProposedBudgetPayload<ExtArgs>[]
      disburse: Prisma.$formDisbursePayload<ExtArgs> | null
      countSheet: Prisma.$CountSheetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referenceCode: string
      requestTypeId: number | null
      requestById: number | null
      requestFromId: number | null
      status: $Enums.Statuses
      requestDate: Date
      remarks: string | null
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["mainRequest"]>
    composites: {}
  }

  type MainRequestGetPayload<S extends boolean | null | undefined | MainRequestDefaultArgs> = $Result.GetResult<Prisma.$MainRequestPayload, S>

  type MainRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MainRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MainRequestCountAggregateInputType | true
    }

  export interface MainRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MainRequest'], meta: { name: 'MainRequest' } }
    /**
     * Find zero or one MainRequest that matches the filter.
     * @param {MainRequestFindUniqueArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MainRequestFindUniqueArgs>(args: SelectSubset<T, MainRequestFindUniqueArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MainRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MainRequestFindUniqueOrThrowArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MainRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MainRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindFirstArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MainRequestFindFirstArgs>(args?: SelectSubset<T, MainRequestFindFirstArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MainRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindFirstOrThrowArgs} args - Arguments to find a MainRequest
     * @example
     * // Get one MainRequest
     * const mainRequest = await prisma.mainRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MainRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MainRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MainRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainRequests
     * const mainRequests = await prisma.mainRequest.findMany()
     * 
     * // Get first 10 MainRequests
     * const mainRequests = await prisma.mainRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MainRequestFindManyArgs>(args?: SelectSubset<T, MainRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MainRequest.
     * @param {MainRequestCreateArgs} args - Arguments to create a MainRequest.
     * @example
     * // Create one MainRequest
     * const MainRequest = await prisma.mainRequest.create({
     *   data: {
     *     // ... data to create a MainRequest
     *   }
     * })
     * 
     */
    create<T extends MainRequestCreateArgs>(args: SelectSubset<T, MainRequestCreateArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MainRequests.
     * @param {MainRequestCreateManyArgs} args - Arguments to create many MainRequests.
     * @example
     * // Create many MainRequests
     * const mainRequest = await prisma.mainRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MainRequestCreateManyArgs>(args?: SelectSubset<T, MainRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MainRequests and returns the data saved in the database.
     * @param {MainRequestCreateManyAndReturnArgs} args - Arguments to create many MainRequests.
     * @example
     * // Create many MainRequests
     * const mainRequest = await prisma.mainRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MainRequests and only return the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MainRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MainRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MainRequest.
     * @param {MainRequestDeleteArgs} args - Arguments to delete one MainRequest.
     * @example
     * // Delete one MainRequest
     * const MainRequest = await prisma.mainRequest.delete({
     *   where: {
     *     // ... filter to delete one MainRequest
     *   }
     * })
     * 
     */
    delete<T extends MainRequestDeleteArgs>(args: SelectSubset<T, MainRequestDeleteArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MainRequest.
     * @param {MainRequestUpdateArgs} args - Arguments to update one MainRequest.
     * @example
     * // Update one MainRequest
     * const mainRequest = await prisma.mainRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MainRequestUpdateArgs>(args: SelectSubset<T, MainRequestUpdateArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MainRequests.
     * @param {MainRequestDeleteManyArgs} args - Arguments to filter MainRequests to delete.
     * @example
     * // Delete a few MainRequests
     * const { count } = await prisma.mainRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MainRequestDeleteManyArgs>(args?: SelectSubset<T, MainRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainRequests
     * const mainRequest = await prisma.mainRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MainRequestUpdateManyArgs>(args: SelectSubset<T, MainRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainRequests and returns the data updated in the database.
     * @param {MainRequestUpdateManyAndReturnArgs} args - Arguments to update many MainRequests.
     * @example
     * // Update many MainRequests
     * const mainRequest = await prisma.mainRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MainRequests and only return the `id`
     * const mainRequestWithIdOnly = await prisma.mainRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MainRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MainRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MainRequest.
     * @param {MainRequestUpsertArgs} args - Arguments to update or create a MainRequest.
     * @example
     * // Update or create a MainRequest
     * const mainRequest = await prisma.mainRequest.upsert({
     *   create: {
     *     // ... data to create a MainRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainRequest we want to update
     *   }
     * })
     */
    upsert<T extends MainRequestUpsertArgs>(args: SelectSubset<T, MainRequestUpsertArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestCountArgs} args - Arguments to filter MainRequests to count.
     * @example
     * // Count the number of MainRequests
     * const count = await prisma.mainRequest.count({
     *   where: {
     *     // ... the filter for the MainRequests we want to count
     *   }
     * })
    **/
    count<T extends MainRequestCountArgs>(
      args?: Subset<T, MainRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainRequestAggregateArgs>(args: Subset<T, MainRequestAggregateArgs>): Prisma.PrismaPromise<GetMainRequestAggregateType<T>>

    /**
     * Group by MainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainRequestGroupByArgs['orderBy'] }
        : { orderBy?: MainRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MainRequest model
   */
  readonly fields: MainRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MainRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MainRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestType<T extends MainRequest$requestTypeArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestTypeArgs<ExtArgs>>): Prisma__RequestTypeClient<$Result.GetResult<Prisma.$RequestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fundTransfer<T extends MainRequest$fundTransferArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$fundTransferArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestBy<T extends MainRequest$requestByArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestFrom<T extends MainRequest$requestFromArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$requestFromArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approval<T extends MainRequest$approvalArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$approvalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    travelOrder<T extends MainRequest$travelOrderArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$travelOrderArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transmittalMemo<T extends MainRequest$transmittalMemoArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$transmittalMemoArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposedBudget<T extends MainRequest$proposedBudgetArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$proposedBudgetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disburse<T extends MainRequest$disburseArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$disburseArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    countSheet<T extends MainRequest$countSheetArgs<ExtArgs> = {}>(args?: Subset<T, MainRequest$countSheetArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MainRequest model
   */
  interface MainRequestFieldRefs {
    readonly id: FieldRef<"MainRequest", 'Int'>
    readonly referenceCode: FieldRef<"MainRequest", 'String'>
    readonly requestTypeId: FieldRef<"MainRequest", 'Int'>
    readonly requestById: FieldRef<"MainRequest", 'Int'>
    readonly requestFromId: FieldRef<"MainRequest", 'Int'>
    readonly status: FieldRef<"MainRequest", 'Statuses'>
    readonly requestDate: FieldRef<"MainRequest", 'DateTime'>
    readonly remarks: FieldRef<"MainRequest", 'String'>
    readonly createdAt: FieldRef<"MainRequest", 'DateTime'>
    readonly updateAt: FieldRef<"MainRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MainRequest findUnique
   */
  export type MainRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest findUniqueOrThrow
   */
  export type MainRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest findFirst
   */
  export type MainRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainRequests.
     */
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest findFirstOrThrow
   */
  export type MainRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequest to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainRequests.
     */
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest findMany
   */
  export type MainRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter, which MainRequests to fetch.
     */
    where?: MainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainRequests to fetch.
     */
    orderBy?: MainRequestOrderByWithRelationInput | MainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainRequests.
     */
    cursor?: MainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainRequests.
     */
    skip?: number
    distinct?: MainRequestScalarFieldEnum | MainRequestScalarFieldEnum[]
  }

  /**
   * MainRequest create
   */
  export type MainRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MainRequest.
     */
    data: XOR<MainRequestCreateInput, MainRequestUncheckedCreateInput>
  }

  /**
   * MainRequest createMany
   */
  export type MainRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MainRequests.
     */
    data: MainRequestCreateManyInput | MainRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MainRequest createManyAndReturn
   */
  export type MainRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MainRequests.
     */
    data: MainRequestCreateManyInput | MainRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainRequest update
   */
  export type MainRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MainRequest.
     */
    data: XOR<MainRequestUpdateInput, MainRequestUncheckedUpdateInput>
    /**
     * Choose, which MainRequest to update.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest updateMany
   */
  export type MainRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MainRequests.
     */
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyInput>
    /**
     * Filter which MainRequests to update
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to update.
     */
    limit?: number
  }

  /**
   * MainRequest updateManyAndReturn
   */
  export type MainRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * The data used to update MainRequests.
     */
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyInput>
    /**
     * Filter which MainRequests to update
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MainRequest upsert
   */
  export type MainRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MainRequest to update in case it exists.
     */
    where: MainRequestWhereUniqueInput
    /**
     * In case the MainRequest found by the `where` argument doesn't exist, create a new MainRequest with this data.
     */
    create: XOR<MainRequestCreateInput, MainRequestUncheckedCreateInput>
    /**
     * In case the MainRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MainRequestUpdateInput, MainRequestUncheckedUpdateInput>
  }

  /**
   * MainRequest delete
   */
  export type MainRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    /**
     * Filter which MainRequest to delete.
     */
    where: MainRequestWhereUniqueInput
  }

  /**
   * MainRequest deleteMany
   */
  export type MainRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MainRequests to delete
     */
    where?: MainRequestWhereInput
    /**
     * Limit how many MainRequests to delete.
     */
    limit?: number
  }

  /**
   * MainRequest.requestType
   */
  export type MainRequest$requestTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestType
     */
    select?: RequestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestType
     */
    omit?: RequestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestTypeInclude<ExtArgs> | null
    where?: RequestTypeWhereInput
  }

  /**
   * MainRequest.fundTransfer
   */
  export type MainRequest$fundTransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    where?: FormFundTransferWhereInput
  }

  /**
   * MainRequest.requestBy
   */
  export type MainRequest$requestByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MainRequest.requestFrom
   */
  export type MainRequest$requestFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * MainRequest.approval
   */
  export type MainRequest$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    where?: ApprovalTableWhereInput
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    cursor?: ApprovalTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * MainRequest.travelOrder
   */
  export type MainRequest$travelOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    where?: formTravelOrderWhereInput
  }

  /**
   * MainRequest.transmittalMemo
   */
  export type MainRequest$transmittalMemoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    where?: formTransmittalMemoWhereInput
  }

  /**
   * MainRequest.proposedBudget
   */
  export type MainRequest$proposedBudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    where?: formProposedBudgetWhereInput
    orderBy?: formProposedBudgetOrderByWithRelationInput | formProposedBudgetOrderByWithRelationInput[]
    cursor?: formProposedBudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormProposedBudgetScalarFieldEnum | FormProposedBudgetScalarFieldEnum[]
  }

  /**
   * MainRequest.disburse
   */
  export type MainRequest$disburseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    where?: formDisburseWhereInput
  }

  /**
   * MainRequest.countSheet
   */
  export type MainRequest$countSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    where?: CountSheetWhereInput
  }

  /**
   * MainRequest without action
   */
  export type MainRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
  }


  /**
   * Model FormFundTransfer
   */

  export type AggregateFormFundTransfer = {
    _count: FormFundTransferCountAggregateOutputType | null
    _avg: FormFundTransferAvgAggregateOutputType | null
    _sum: FormFundTransferSumAggregateOutputType | null
    _min: FormFundTransferMinAggregateOutputType | null
    _max: FormFundTransferMaxAggregateOutputType | null
  }

  export type FormFundTransferAvgAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
  }

  export type FormFundTransferSumAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
  }

  export type FormFundTransferMinAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FormFundTransferMaxAggregateOutputType = {
    id: number | null
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FormFundTransferCountAggregateOutputType = {
    id: number
    mainRequestID: number
    requestToId: number
    requestContent: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type FormFundTransferAvgAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
  }

  export type FormFundTransferSumAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
  }

  export type FormFundTransferMinAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
  }

  export type FormFundTransferMaxAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
  }

  export type FormFundTransferCountAggregateInputType = {
    id?: true
    mainRequestID?: true
    requestToId?: true
    requestContent?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type FormFundTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFundTransfer to aggregate.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormFundTransfers
    **/
    _count?: true | FormFundTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormFundTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormFundTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormFundTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormFundTransferMaxAggregateInputType
  }

  export type GetFormFundTransferAggregateType<T extends FormFundTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateFormFundTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormFundTransfer[P]>
      : GetScalarType<T[P], AggregateFormFundTransfer[P]>
  }




  export type FormFundTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFundTransferWhereInput
    orderBy?: FormFundTransferOrderByWithAggregationInput | FormFundTransferOrderByWithAggregationInput[]
    by: FormFundTransferScalarFieldEnum[] | FormFundTransferScalarFieldEnum
    having?: FormFundTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormFundTransferCountAggregateInputType | true
    _avg?: FormFundTransferAvgAggregateInputType
    _sum?: FormFundTransferSumAggregateInputType
    _min?: FormFundTransferMinAggregateInputType
    _max?: FormFundTransferMaxAggregateInputType
  }

  export type FormFundTransferGroupByOutputType = {
    id: number
    mainRequestID: number | null
    requestToId: number | null
    requestContent: string
    createdAt: Date
    updateAt: Date
    _count: FormFundTransferCountAggregateOutputType | null
    _avg: FormFundTransferAvgAggregateOutputType | null
    _sum: FormFundTransferSumAggregateOutputType | null
    _min: FormFundTransferMinAggregateOutputType | null
    _max: FormFundTransferMaxAggregateOutputType | null
  }

  type GetFormFundTransferGroupByPayload<T extends FormFundTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormFundTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormFundTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormFundTransferGroupByOutputType[P]>
            : GetScalarType<T[P], FormFundTransferGroupByOutputType[P]>
        }
      >
    >


  export type FormFundTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }, ExtArgs["result"]["formFundTransfer"]>

  export type FormFundTransferSelectScalar = {
    id?: boolean
    mainRequestID?: boolean
    requestToId?: boolean
    requestContent?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type FormFundTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mainRequestID" | "requestToId" | "requestContent" | "createdAt" | "updateAt", ExtArgs["result"]["formFundTransfer"]>
  export type FormFundTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }
  export type FormFundTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }
  export type FormFundTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | FormFundTransfer$mainRequestArgs<ExtArgs>
    requestTo?: boolean | FormFundTransfer$requestToArgs<ExtArgs>
  }

  export type $FormFundTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormFundTransfer"
    objects: {
      mainRequest: Prisma.$MainRequestPayload<ExtArgs> | null
      requestTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mainRequestID: number | null
      requestToId: number | null
      requestContent: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["formFundTransfer"]>
    composites: {}
  }

  type FormFundTransferGetPayload<S extends boolean | null | undefined | FormFundTransferDefaultArgs> = $Result.GetResult<Prisma.$FormFundTransferPayload, S>

  type FormFundTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFundTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormFundTransferCountAggregateInputType | true
    }

  export interface FormFundTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormFundTransfer'], meta: { name: 'FormFundTransfer' } }
    /**
     * Find zero or one FormFundTransfer that matches the filter.
     * @param {FormFundTransferFindUniqueArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFundTransferFindUniqueArgs>(args: SelectSubset<T, FormFundTransferFindUniqueArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormFundTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFundTransferFindUniqueOrThrowArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFundTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFundTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFundTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindFirstArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFundTransferFindFirstArgs>(args?: SelectSubset<T, FormFundTransferFindFirstArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFundTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindFirstOrThrowArgs} args - Arguments to find a FormFundTransfer
     * @example
     * // Get one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFundTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFundTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormFundTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormFundTransfers
     * const formFundTransfers = await prisma.formFundTransfer.findMany()
     * 
     * // Get first 10 FormFundTransfers
     * const formFundTransfers = await prisma.formFundTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFundTransferFindManyArgs>(args?: SelectSubset<T, FormFundTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormFundTransfer.
     * @param {FormFundTransferCreateArgs} args - Arguments to create a FormFundTransfer.
     * @example
     * // Create one FormFundTransfer
     * const FormFundTransfer = await prisma.formFundTransfer.create({
     *   data: {
     *     // ... data to create a FormFundTransfer
     *   }
     * })
     * 
     */
    create<T extends FormFundTransferCreateArgs>(args: SelectSubset<T, FormFundTransferCreateArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormFundTransfers.
     * @param {FormFundTransferCreateManyArgs} args - Arguments to create many FormFundTransfers.
     * @example
     * // Create many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormFundTransferCreateManyArgs>(args?: SelectSubset<T, FormFundTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormFundTransfers and returns the data saved in the database.
     * @param {FormFundTransferCreateManyAndReturnArgs} args - Arguments to create many FormFundTransfers.
     * @example
     * // Create many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormFundTransfers and only return the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormFundTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, FormFundTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormFundTransfer.
     * @param {FormFundTransferDeleteArgs} args - Arguments to delete one FormFundTransfer.
     * @example
     * // Delete one FormFundTransfer
     * const FormFundTransfer = await prisma.formFundTransfer.delete({
     *   where: {
     *     // ... filter to delete one FormFundTransfer
     *   }
     * })
     * 
     */
    delete<T extends FormFundTransferDeleteArgs>(args: SelectSubset<T, FormFundTransferDeleteArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormFundTransfer.
     * @param {FormFundTransferUpdateArgs} args - Arguments to update one FormFundTransfer.
     * @example
     * // Update one FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormFundTransferUpdateArgs>(args: SelectSubset<T, FormFundTransferUpdateArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormFundTransfers.
     * @param {FormFundTransferDeleteManyArgs} args - Arguments to filter FormFundTransfers to delete.
     * @example
     * // Delete a few FormFundTransfers
     * const { count } = await prisma.formFundTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormFundTransferDeleteManyArgs>(args?: SelectSubset<T, FormFundTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFundTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormFundTransferUpdateManyArgs>(args: SelectSubset<T, FormFundTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFundTransfers and returns the data updated in the database.
     * @param {FormFundTransferUpdateManyAndReturnArgs} args - Arguments to update many FormFundTransfers.
     * @example
     * // Update many FormFundTransfers
     * const formFundTransfer = await prisma.formFundTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormFundTransfers and only return the `id`
     * const formFundTransferWithIdOnly = await prisma.formFundTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormFundTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, FormFundTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormFundTransfer.
     * @param {FormFundTransferUpsertArgs} args - Arguments to update or create a FormFundTransfer.
     * @example
     * // Update or create a FormFundTransfer
     * const formFundTransfer = await prisma.formFundTransfer.upsert({
     *   create: {
     *     // ... data to create a FormFundTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormFundTransfer we want to update
     *   }
     * })
     */
    upsert<T extends FormFundTransferUpsertArgs>(args: SelectSubset<T, FormFundTransferUpsertArgs<ExtArgs>>): Prisma__FormFundTransferClient<$Result.GetResult<Prisma.$FormFundTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormFundTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferCountArgs} args - Arguments to filter FormFundTransfers to count.
     * @example
     * // Count the number of FormFundTransfers
     * const count = await prisma.formFundTransfer.count({
     *   where: {
     *     // ... the filter for the FormFundTransfers we want to count
     *   }
     * })
    **/
    count<T extends FormFundTransferCountArgs>(
      args?: Subset<T, FormFundTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormFundTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormFundTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormFundTransferAggregateArgs>(args: Subset<T, FormFundTransferAggregateArgs>): Prisma.PrismaPromise<GetFormFundTransferAggregateType<T>>

    /**
     * Group by FormFundTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFundTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormFundTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormFundTransferGroupByArgs['orderBy'] }
        : { orderBy?: FormFundTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormFundTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormFundTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormFundTransfer model
   */
  readonly fields: FormFundTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormFundTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormFundTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainRequest<T extends FormFundTransfer$mainRequestArgs<ExtArgs> = {}>(args?: Subset<T, FormFundTransfer$mainRequestArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestTo<T extends FormFundTransfer$requestToArgs<ExtArgs> = {}>(args?: Subset<T, FormFundTransfer$requestToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormFundTransfer model
   */
  interface FormFundTransferFieldRefs {
    readonly id: FieldRef<"FormFundTransfer", 'Int'>
    readonly mainRequestID: FieldRef<"FormFundTransfer", 'Int'>
    readonly requestToId: FieldRef<"FormFundTransfer", 'Int'>
    readonly requestContent: FieldRef<"FormFundTransfer", 'String'>
    readonly createdAt: FieldRef<"FormFundTransfer", 'DateTime'>
    readonly updateAt: FieldRef<"FormFundTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormFundTransfer findUnique
   */
  export type FormFundTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer findUniqueOrThrow
   */
  export type FormFundTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer findFirst
   */
  export type FormFundTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFundTransfers.
     */
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer findFirstOrThrow
   */
  export type FormFundTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfer to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFundTransfers.
     */
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer findMany
   */
  export type FormFundTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter, which FormFundTransfers to fetch.
     */
    where?: FormFundTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFundTransfers to fetch.
     */
    orderBy?: FormFundTransferOrderByWithRelationInput | FormFundTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormFundTransfers.
     */
    cursor?: FormFundTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFundTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFundTransfers.
     */
    skip?: number
    distinct?: FormFundTransferScalarFieldEnum | FormFundTransferScalarFieldEnum[]
  }

  /**
   * FormFundTransfer create
   */
  export type FormFundTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a FormFundTransfer.
     */
    data: XOR<FormFundTransferCreateInput, FormFundTransferUncheckedCreateInput>
  }

  /**
   * FormFundTransfer createMany
   */
  export type FormFundTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormFundTransfers.
     */
    data: FormFundTransferCreateManyInput | FormFundTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormFundTransfer createManyAndReturn
   */
  export type FormFundTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * The data used to create many FormFundTransfers.
     */
    data: FormFundTransferCreateManyInput | FormFundTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFundTransfer update
   */
  export type FormFundTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a FormFundTransfer.
     */
    data: XOR<FormFundTransferUpdateInput, FormFundTransferUncheckedUpdateInput>
    /**
     * Choose, which FormFundTransfer to update.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer updateMany
   */
  export type FormFundTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormFundTransfers.
     */
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyInput>
    /**
     * Filter which FormFundTransfers to update
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to update.
     */
    limit?: number
  }

  /**
   * FormFundTransfer updateManyAndReturn
   */
  export type FormFundTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * The data used to update FormFundTransfers.
     */
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyInput>
    /**
     * Filter which FormFundTransfers to update
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFundTransfer upsert
   */
  export type FormFundTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the FormFundTransfer to update in case it exists.
     */
    where: FormFundTransferWhereUniqueInput
    /**
     * In case the FormFundTransfer found by the `where` argument doesn't exist, create a new FormFundTransfer with this data.
     */
    create: XOR<FormFundTransferCreateInput, FormFundTransferUncheckedCreateInput>
    /**
     * In case the FormFundTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormFundTransferUpdateInput, FormFundTransferUncheckedUpdateInput>
  }

  /**
   * FormFundTransfer delete
   */
  export type FormFundTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
    /**
     * Filter which FormFundTransfer to delete.
     */
    where: FormFundTransferWhereUniqueInput
  }

  /**
   * FormFundTransfer deleteMany
   */
  export type FormFundTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFundTransfers to delete
     */
    where?: FormFundTransferWhereInput
    /**
     * Limit how many FormFundTransfers to delete.
     */
    limit?: number
  }

  /**
   * FormFundTransfer.mainRequest
   */
  export type FormFundTransfer$mainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * FormFundTransfer.requestTo
   */
  export type FormFundTransfer$requestToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FormFundTransfer without action
   */
  export type FormFundTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFundTransfer
     */
    select?: FormFundTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFundTransfer
     */
    omit?: FormFundTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFundTransferInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalTable
   */

  export type AggregateApprovalTable = {
    _count: ApprovalTableCountAggregateOutputType | null
    _avg: ApprovalTableAvgAggregateOutputType | null
    _sum: ApprovalTableSumAggregateOutputType | null
    _min: ApprovalTableMinAggregateOutputType | null
    _max: ApprovalTableMaxAggregateOutputType | null
  }

  export type ApprovalTableAvgAggregateOutputType = {
    id: number | null
    mainFormId: number | null
  }

  export type ApprovalTableSumAggregateOutputType = {
    id: number | null
    mainFormId: number | null
  }

  export type ApprovalTableMinAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    notedBy: $Enums.Statuses | null
    checkedBy: $Enums.Statuses | null
    checkedBy2: $Enums.Statuses | null
    recomApproval: $Enums.Statuses | null
    recomApproval2: $Enums.Statuses | null
    approveBy: $Enums.Statuses | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ApprovalTableMaxAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    notedBy: $Enums.Statuses | null
    checkedBy: $Enums.Statuses | null
    checkedBy2: $Enums.Statuses | null
    recomApproval: $Enums.Statuses | null
    recomApproval2: $Enums.Statuses | null
    approveBy: $Enums.Statuses | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ApprovalTableCountAggregateOutputType = {
    id: number
    mainFormId: number
    notedBy: number
    checkedBy: number
    checkedBy2: number
    recomApproval: number
    recomApproval2: number
    approveBy: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type ApprovalTableAvgAggregateInputType = {
    id?: true
    mainFormId?: true
  }

  export type ApprovalTableSumAggregateInputType = {
    id?: true
    mainFormId?: true
  }

  export type ApprovalTableMinAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
  }

  export type ApprovalTableMaxAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
  }

  export type ApprovalTableCountAggregateInputType = {
    id?: true
    mainFormId?: true
    notedBy?: true
    checkedBy?: true
    checkedBy2?: true
    recomApproval?: true
    recomApproval2?: true
    approveBy?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type ApprovalTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTable to aggregate.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalTables
    **/
    _count?: true | ApprovalTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalTableMaxAggregateInputType
  }

  export type GetApprovalTableAggregateType<T extends ApprovalTableAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalTable[P]>
      : GetScalarType<T[P], AggregateApprovalTable[P]>
  }




  export type ApprovalTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTableWhereInput
    orderBy?: ApprovalTableOrderByWithAggregationInput | ApprovalTableOrderByWithAggregationInput[]
    by: ApprovalTableScalarFieldEnum[] | ApprovalTableScalarFieldEnum
    having?: ApprovalTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalTableCountAggregateInputType | true
    _avg?: ApprovalTableAvgAggregateInputType
    _sum?: ApprovalTableSumAggregateInputType
    _min?: ApprovalTableMinAggregateInputType
    _max?: ApprovalTableMaxAggregateInputType
  }

  export type ApprovalTableGroupByOutputType = {
    id: number
    mainFormId: number | null
    notedBy: $Enums.Statuses
    checkedBy: $Enums.Statuses
    checkedBy2: $Enums.Statuses
    recomApproval: $Enums.Statuses
    recomApproval2: $Enums.Statuses
    approveBy: $Enums.Statuses
    createdAt: Date
    updateAt: Date
    _count: ApprovalTableCountAggregateOutputType | null
    _avg: ApprovalTableAvgAggregateOutputType | null
    _sum: ApprovalTableSumAggregateOutputType | null
    _min: ApprovalTableMinAggregateOutputType | null
    _max: ApprovalTableMaxAggregateOutputType | null
  }

  type GetApprovalTableGroupByPayload<T extends ApprovalTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalTableGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalTableGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
    requestLogs?: boolean | ApprovalTable$requestLogsArgs<ExtArgs>
    _count?: boolean | ApprovalTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTable"]>

  export type ApprovalTableSelectScalar = {
    id?: boolean
    mainFormId?: boolean
    notedBy?: boolean
    checkedBy?: boolean
    checkedBy2?: boolean
    recomApproval?: boolean
    recomApproval2?: boolean
    approveBy?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type ApprovalTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mainFormId" | "notedBy" | "checkedBy" | "checkedBy2" | "recomApproval" | "recomApproval2" | "approveBy" | "createdAt" | "updateAt", ExtArgs["result"]["approvalTable"]>
  export type ApprovalTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
    requestLogs?: boolean | ApprovalTable$requestLogsArgs<ExtArgs>
    _count?: boolean | ApprovalTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }
  export type ApprovalTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainRequest?: boolean | ApprovalTable$mainRequestArgs<ExtArgs>
  }

  export type $ApprovalTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalTable"
    objects: {
      mainRequest: Prisma.$MainRequestPayload<ExtArgs> | null
      requestLogs: Prisma.$RequestLogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mainFormId: number | null
      notedBy: $Enums.Statuses
      checkedBy: $Enums.Statuses
      checkedBy2: $Enums.Statuses
      recomApproval: $Enums.Statuses
      recomApproval2: $Enums.Statuses
      approveBy: $Enums.Statuses
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["approvalTable"]>
    composites: {}
  }

  type ApprovalTableGetPayload<S extends boolean | null | undefined | ApprovalTableDefaultArgs> = $Result.GetResult<Prisma.$ApprovalTablePayload, S>

  type ApprovalTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalTableCountAggregateInputType | true
    }

  export interface ApprovalTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalTable'], meta: { name: 'ApprovalTable' } }
    /**
     * Find zero or one ApprovalTable that matches the filter.
     * @param {ApprovalTableFindUniqueArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalTableFindUniqueArgs>(args: SelectSubset<T, ApprovalTableFindUniqueArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovalTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalTableFindUniqueOrThrowArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalTableFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindFirstArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalTableFindFirstArgs>(args?: SelectSubset<T, ApprovalTableFindFirstArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindFirstOrThrowArgs} args - Arguments to find a ApprovalTable
     * @example
     * // Get one ApprovalTable
     * const approvalTable = await prisma.approvalTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalTableFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovalTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalTables
     * const approvalTables = await prisma.approvalTable.findMany()
     * 
     * // Get first 10 ApprovalTables
     * const approvalTables = await prisma.approvalTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalTableFindManyArgs>(args?: SelectSubset<T, ApprovalTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovalTable.
     * @param {ApprovalTableCreateArgs} args - Arguments to create a ApprovalTable.
     * @example
     * // Create one ApprovalTable
     * const ApprovalTable = await prisma.approvalTable.create({
     *   data: {
     *     // ... data to create a ApprovalTable
     *   }
     * })
     * 
     */
    create<T extends ApprovalTableCreateArgs>(args: SelectSubset<T, ApprovalTableCreateArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovalTables.
     * @param {ApprovalTableCreateManyArgs} args - Arguments to create many ApprovalTables.
     * @example
     * // Create many ApprovalTables
     * const approvalTable = await prisma.approvalTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalTableCreateManyArgs>(args?: SelectSubset<T, ApprovalTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalTables and returns the data saved in the database.
     * @param {ApprovalTableCreateManyAndReturnArgs} args - Arguments to create many ApprovalTables.
     * @example
     * // Create many ApprovalTables
     * const approvalTable = await prisma.approvalTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalTables and only return the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalTableCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApprovalTable.
     * @param {ApprovalTableDeleteArgs} args - Arguments to delete one ApprovalTable.
     * @example
     * // Delete one ApprovalTable
     * const ApprovalTable = await prisma.approvalTable.delete({
     *   where: {
     *     // ... filter to delete one ApprovalTable
     *   }
     * })
     * 
     */
    delete<T extends ApprovalTableDeleteArgs>(args: SelectSubset<T, ApprovalTableDeleteArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovalTable.
     * @param {ApprovalTableUpdateArgs} args - Arguments to update one ApprovalTable.
     * @example
     * // Update one ApprovalTable
     * const approvalTable = await prisma.approvalTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalTableUpdateArgs>(args: SelectSubset<T, ApprovalTableUpdateArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovalTables.
     * @param {ApprovalTableDeleteManyArgs} args - Arguments to filter ApprovalTables to delete.
     * @example
     * // Delete a few ApprovalTables
     * const { count } = await prisma.approvalTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalTableDeleteManyArgs>(args?: SelectSubset<T, ApprovalTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalTables
     * const approvalTable = await prisma.approvalTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalTableUpdateManyArgs>(args: SelectSubset<T, ApprovalTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTables and returns the data updated in the database.
     * @param {ApprovalTableUpdateManyAndReturnArgs} args - Arguments to update many ApprovalTables.
     * @example
     * // Update many ApprovalTables
     * const approvalTable = await prisma.approvalTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApprovalTables and only return the `id`
     * const approvalTableWithIdOnly = await prisma.approvalTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalTableUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApprovalTable.
     * @param {ApprovalTableUpsertArgs} args - Arguments to update or create a ApprovalTable.
     * @example
     * // Update or create a ApprovalTable
     * const approvalTable = await prisma.approvalTable.upsert({
     *   create: {
     *     // ... data to create a ApprovalTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalTable we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalTableUpsertArgs>(args: SelectSubset<T, ApprovalTableUpsertArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApprovalTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableCountArgs} args - Arguments to filter ApprovalTables to count.
     * @example
     * // Count the number of ApprovalTables
     * const count = await prisma.approvalTable.count({
     *   where: {
     *     // ... the filter for the ApprovalTables we want to count
     *   }
     * })
    **/
    count<T extends ApprovalTableCountArgs>(
      args?: Subset<T, ApprovalTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalTableAggregateArgs>(args: Subset<T, ApprovalTableAggregateArgs>): Prisma.PrismaPromise<GetApprovalTableAggregateType<T>>

    /**
     * Group by ApprovalTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalTableGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalTable model
   */
  readonly fields: ApprovalTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainRequest<T extends ApprovalTable$mainRequestArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTable$mainRequestArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requestLogs<T extends ApprovalTable$requestLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTable$requestLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalTable model
   */
  interface ApprovalTableFieldRefs {
    readonly id: FieldRef<"ApprovalTable", 'Int'>
    readonly mainFormId: FieldRef<"ApprovalTable", 'Int'>
    readonly notedBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly checkedBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly checkedBy2: FieldRef<"ApprovalTable", 'Statuses'>
    readonly recomApproval: FieldRef<"ApprovalTable", 'Statuses'>
    readonly recomApproval2: FieldRef<"ApprovalTable", 'Statuses'>
    readonly approveBy: FieldRef<"ApprovalTable", 'Statuses'>
    readonly createdAt: FieldRef<"ApprovalTable", 'DateTime'>
    readonly updateAt: FieldRef<"ApprovalTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalTable findUnique
   */
  export type ApprovalTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable findUniqueOrThrow
   */
  export type ApprovalTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable findFirst
   */
  export type ApprovalTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTables.
     */
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable findFirstOrThrow
   */
  export type ApprovalTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTable to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTables.
     */
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable findMany
   */
  export type ApprovalTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTables to fetch.
     */
    where?: ApprovalTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTables to fetch.
     */
    orderBy?: ApprovalTableOrderByWithRelationInput | ApprovalTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalTables.
     */
    cursor?: ApprovalTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTables.
     */
    skip?: number
    distinct?: ApprovalTableScalarFieldEnum | ApprovalTableScalarFieldEnum[]
  }

  /**
   * ApprovalTable create
   */
  export type ApprovalTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalTable.
     */
    data: XOR<ApprovalTableCreateInput, ApprovalTableUncheckedCreateInput>
  }

  /**
   * ApprovalTable createMany
   */
  export type ApprovalTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalTables.
     */
    data: ApprovalTableCreateManyInput | ApprovalTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalTable createManyAndReturn
   */
  export type ApprovalTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * The data used to create many ApprovalTables.
     */
    data: ApprovalTableCreateManyInput | ApprovalTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTable update
   */
  export type ApprovalTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalTable.
     */
    data: XOR<ApprovalTableUpdateInput, ApprovalTableUncheckedUpdateInput>
    /**
     * Choose, which ApprovalTable to update.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable updateMany
   */
  export type ApprovalTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalTables.
     */
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTables to update
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to update.
     */
    limit?: number
  }

  /**
   * ApprovalTable updateManyAndReturn
   */
  export type ApprovalTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * The data used to update ApprovalTables.
     */
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTables to update
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTable upsert
   */
  export type ApprovalTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalTable to update in case it exists.
     */
    where: ApprovalTableWhereUniqueInput
    /**
     * In case the ApprovalTable found by the `where` argument doesn't exist, create a new ApprovalTable with this data.
     */
    create: XOR<ApprovalTableCreateInput, ApprovalTableUncheckedCreateInput>
    /**
     * In case the ApprovalTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalTableUpdateInput, ApprovalTableUncheckedUpdateInput>
  }

  /**
   * ApprovalTable delete
   */
  export type ApprovalTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    /**
     * Filter which ApprovalTable to delete.
     */
    where: ApprovalTableWhereUniqueInput
  }

  /**
   * ApprovalTable deleteMany
   */
  export type ApprovalTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTables to delete
     */
    where?: ApprovalTableWhereInput
    /**
     * Limit how many ApprovalTables to delete.
     */
    limit?: number
  }

  /**
   * ApprovalTable.mainRequest
   */
  export type ApprovalTable$mainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * ApprovalTable.requestLogs
   */
  export type ApprovalTable$requestLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    cursor?: RequestLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * ApprovalTable without action
   */
  export type ApprovalTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
  }


  /**
   * Model RequestLogs
   */

  export type AggregateRequestLogs = {
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  export type RequestLogsAvgAggregateOutputType = {
    id: number | null
    approvalId: number | null
    approverId: number | null
  }

  export type RequestLogsSumAggregateOutputType = {
    id: number | null
    approvalId: number | null
    approverId: number | null
  }

  export type RequestLogsMinAggregateOutputType = {
    id: number | null
    approvalId: number | null
    checkerType: string | null
    approverId: number | null
    action: string | null
    createdAt: Date | null
  }

  export type RequestLogsMaxAggregateOutputType = {
    id: number | null
    approvalId: number | null
    checkerType: string | null
    approverId: number | null
    action: string | null
    createdAt: Date | null
  }

  export type RequestLogsCountAggregateOutputType = {
    id: number
    approvalId: number
    checkerType: number
    approverId: number
    action: number
    createdAt: number
    _all: number
  }


  export type RequestLogsAvgAggregateInputType = {
    id?: true
    approvalId?: true
    approverId?: true
  }

  export type RequestLogsSumAggregateInputType = {
    id?: true
    approvalId?: true
    approverId?: true
  }

  export type RequestLogsMinAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    action?: true
    createdAt?: true
  }

  export type RequestLogsMaxAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    action?: true
    createdAt?: true
  }

  export type RequestLogsCountAggregateInputType = {
    id?: true
    approvalId?: true
    checkerType?: true
    approverId?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type RequestLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestLogs to aggregate.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestLogs
    **/
    _count?: true | RequestLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestLogsMaxAggregateInputType
  }

  export type GetRequestLogsAggregateType<T extends RequestLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestLogs[P]>
      : GetScalarType<T[P], AggregateRequestLogs[P]>
  }




  export type RequestLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestLogsWhereInput
    orderBy?: RequestLogsOrderByWithAggregationInput | RequestLogsOrderByWithAggregationInput[]
    by: RequestLogsScalarFieldEnum[] | RequestLogsScalarFieldEnum
    having?: RequestLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestLogsCountAggregateInputType | true
    _avg?: RequestLogsAvgAggregateInputType
    _sum?: RequestLogsSumAggregateInputType
    _min?: RequestLogsMinAggregateInputType
    _max?: RequestLogsMaxAggregateInputType
  }

  export type RequestLogsGroupByOutputType = {
    id: number
    approvalId: number | null
    checkerType: string
    approverId: number | null
    action: string
    createdAt: Date
    _count: RequestLogsCountAggregateOutputType | null
    _avg: RequestLogsAvgAggregateOutputType | null
    _sum: RequestLogsSumAggregateOutputType | null
    _min: RequestLogsMinAggregateOutputType | null
    _max: RequestLogsMaxAggregateOutputType | null
  }

  type GetRequestLogsGroupByPayload<T extends RequestLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestLogsGroupByOutputType[P]>
        }
      >
    >


  export type RequestLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    action?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    action?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    action?: boolean
    createdAt?: boolean
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }, ExtArgs["result"]["requestLogs"]>

  export type RequestLogsSelectScalar = {
    id?: boolean
    approvalId?: boolean
    checkerType?: boolean
    approverId?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type RequestLogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "approvalId" | "checkerType" | "approverId" | "action" | "createdAt", ExtArgs["result"]["requestLogs"]>
  export type RequestLogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }
  export type RequestLogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }
  export type RequestLogsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | RequestLogs$approvalArgs<ExtArgs>
    approver?: boolean | RequestLogs$approverArgs<ExtArgs>
  }

  export type $RequestLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestLogs"
    objects: {
      approval: Prisma.$ApprovalTablePayload<ExtArgs> | null
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      approvalId: number | null
      checkerType: string
      approverId: number | null
      action: string
      createdAt: Date
    }, ExtArgs["result"]["requestLogs"]>
    composites: {}
  }

  type RequestLogsGetPayload<S extends boolean | null | undefined | RequestLogsDefaultArgs> = $Result.GetResult<Prisma.$RequestLogsPayload, S>

  type RequestLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestLogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestLogsCountAggregateInputType | true
    }

  export interface RequestLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestLogs'], meta: { name: 'RequestLogs' } }
    /**
     * Find zero or one RequestLogs that matches the filter.
     * @param {RequestLogsFindUniqueArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestLogsFindUniqueArgs>(args: SelectSubset<T, RequestLogsFindUniqueArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestLogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestLogsFindUniqueOrThrowArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindFirstArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestLogsFindFirstArgs>(args?: SelectSubset<T, RequestLogsFindFirstArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindFirstOrThrowArgs} args - Arguments to find a RequestLogs
     * @example
     * // Get one RequestLogs
     * const requestLogs = await prisma.requestLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany()
     * 
     * // Get first 10 RequestLogs
     * const requestLogs = await prisma.requestLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestLogsFindManyArgs>(args?: SelectSubset<T, RequestLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestLogs.
     * @param {RequestLogsCreateArgs} args - Arguments to create a RequestLogs.
     * @example
     * // Create one RequestLogs
     * const RequestLogs = await prisma.requestLogs.create({
     *   data: {
     *     // ... data to create a RequestLogs
     *   }
     * })
     * 
     */
    create<T extends RequestLogsCreateArgs>(args: SelectSubset<T, RequestLogsCreateArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestLogs.
     * @param {RequestLogsCreateManyArgs} args - Arguments to create many RequestLogs.
     * @example
     * // Create many RequestLogs
     * const requestLogs = await prisma.requestLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestLogsCreateManyArgs>(args?: SelectSubset<T, RequestLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestLogs and returns the data saved in the database.
     * @param {RequestLogsCreateManyAndReturnArgs} args - Arguments to create many RequestLogs.
     * @example
     * // Create many RequestLogs
     * const requestLogs = await prisma.requestLogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestLogs and only return the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestLogsCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestLogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestLogs.
     * @param {RequestLogsDeleteArgs} args - Arguments to delete one RequestLogs.
     * @example
     * // Delete one RequestLogs
     * const RequestLogs = await prisma.requestLogs.delete({
     *   where: {
     *     // ... filter to delete one RequestLogs
     *   }
     * })
     * 
     */
    delete<T extends RequestLogsDeleteArgs>(args: SelectSubset<T, RequestLogsDeleteArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestLogs.
     * @param {RequestLogsUpdateArgs} args - Arguments to update one RequestLogs.
     * @example
     * // Update one RequestLogs
     * const requestLogs = await prisma.requestLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestLogsUpdateArgs>(args: SelectSubset<T, RequestLogsUpdateArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestLogs.
     * @param {RequestLogsDeleteManyArgs} args - Arguments to filter RequestLogs to delete.
     * @example
     * // Delete a few RequestLogs
     * const { count } = await prisma.requestLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestLogsDeleteManyArgs>(args?: SelectSubset<T, RequestLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestLogs
     * const requestLogs = await prisma.requestLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestLogsUpdateManyArgs>(args: SelectSubset<T, RequestLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestLogs and returns the data updated in the database.
     * @param {RequestLogsUpdateManyAndReturnArgs} args - Arguments to update many RequestLogs.
     * @example
     * // Update many RequestLogs
     * const requestLogs = await prisma.requestLogs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestLogs and only return the `id`
     * const requestLogsWithIdOnly = await prisma.requestLogs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestLogsUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestLogsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestLogs.
     * @param {RequestLogsUpsertArgs} args - Arguments to update or create a RequestLogs.
     * @example
     * // Update or create a RequestLogs
     * const requestLogs = await prisma.requestLogs.upsert({
     *   create: {
     *     // ... data to create a RequestLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestLogs we want to update
     *   }
     * })
     */
    upsert<T extends RequestLogsUpsertArgs>(args: SelectSubset<T, RequestLogsUpsertArgs<ExtArgs>>): Prisma__RequestLogsClient<$Result.GetResult<Prisma.$RequestLogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsCountArgs} args - Arguments to filter RequestLogs to count.
     * @example
     * // Count the number of RequestLogs
     * const count = await prisma.requestLogs.count({
     *   where: {
     *     // ... the filter for the RequestLogs we want to count
     *   }
     * })
    **/
    count<T extends RequestLogsCountArgs>(
      args?: Subset<T, RequestLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestLogsAggregateArgs>(args: Subset<T, RequestLogsAggregateArgs>): Prisma.PrismaPromise<GetRequestLogsAggregateType<T>>

    /**
     * Group by RequestLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestLogsGroupByArgs['orderBy'] }
        : { orderBy?: RequestLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestLogs model
   */
  readonly fields: RequestLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approval<T extends RequestLogs$approvalArgs<ExtArgs> = {}>(args?: Subset<T, RequestLogs$approvalArgs<ExtArgs>>): Prisma__ApprovalTableClient<$Result.GetResult<Prisma.$ApprovalTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approver<T extends RequestLogs$approverArgs<ExtArgs> = {}>(args?: Subset<T, RequestLogs$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestLogs model
   */
  interface RequestLogsFieldRefs {
    readonly id: FieldRef<"RequestLogs", 'Int'>
    readonly approvalId: FieldRef<"RequestLogs", 'Int'>
    readonly checkerType: FieldRef<"RequestLogs", 'String'>
    readonly approverId: FieldRef<"RequestLogs", 'Int'>
    readonly action: FieldRef<"RequestLogs", 'String'>
    readonly createdAt: FieldRef<"RequestLogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestLogs findUnique
   */
  export type RequestLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs findUniqueOrThrow
   */
  export type RequestLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs findFirst
   */
  export type RequestLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestLogs.
     */
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs findFirstOrThrow
   */
  export type RequestLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestLogs.
     */
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs findMany
   */
  export type RequestLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter, which RequestLogs to fetch.
     */
    where?: RequestLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestLogs to fetch.
     */
    orderBy?: RequestLogsOrderByWithRelationInput | RequestLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestLogs.
     */
    cursor?: RequestLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestLogs.
     */
    skip?: number
    distinct?: RequestLogsScalarFieldEnum | RequestLogsScalarFieldEnum[]
  }

  /**
   * RequestLogs create
   */
  export type RequestLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestLogs.
     */
    data: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
  }

  /**
   * RequestLogs createMany
   */
  export type RequestLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestLogs.
     */
    data: RequestLogsCreateManyInput | RequestLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestLogs createManyAndReturn
   */
  export type RequestLogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * The data used to create many RequestLogs.
     */
    data: RequestLogsCreateManyInput | RequestLogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestLogs update
   */
  export type RequestLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestLogs.
     */
    data: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
    /**
     * Choose, which RequestLogs to update.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs updateMany
   */
  export type RequestLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestLogs.
     */
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyInput>
    /**
     * Filter which RequestLogs to update
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to update.
     */
    limit?: number
  }

  /**
   * RequestLogs updateManyAndReturn
   */
  export type RequestLogsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * The data used to update RequestLogs.
     */
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyInput>
    /**
     * Filter which RequestLogs to update
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestLogs upsert
   */
  export type RequestLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestLogs to update in case it exists.
     */
    where: RequestLogsWhereUniqueInput
    /**
     * In case the RequestLogs found by the `where` argument doesn't exist, create a new RequestLogs with this data.
     */
    create: XOR<RequestLogsCreateInput, RequestLogsUncheckedCreateInput>
    /**
     * In case the RequestLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestLogsUpdateInput, RequestLogsUncheckedUpdateInput>
  }

  /**
   * RequestLogs delete
   */
  export type RequestLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
    /**
     * Filter which RequestLogs to delete.
     */
    where: RequestLogsWhereUniqueInput
  }

  /**
   * RequestLogs deleteMany
   */
  export type RequestLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestLogs to delete
     */
    where?: RequestLogsWhereInput
    /**
     * Limit how many RequestLogs to delete.
     */
    limit?: number
  }

  /**
   * RequestLogs.approval
   */
  export type RequestLogs$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTable
     */
    select?: ApprovalTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTable
     */
    omit?: ApprovalTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTableInclude<ExtArgs> | null
    where?: ApprovalTableWhereInput
  }

  /**
   * RequestLogs.approver
   */
  export type RequestLogs$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequestLogs without action
   */
  export type RequestLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestLogs
     */
    select?: RequestLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestLogs
     */
    omit?: RequestLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestLogsInclude<ExtArgs> | null
  }


  /**
   * Model formTravelOrder
   */

  export type AggregateFormTravelOrder = {
    _count: FormTravelOrderCountAggregateOutputType | null
    _avg: FormTravelOrderAvgAggregateOutputType | null
    _sum: FormTravelOrderSumAggregateOutputType | null
    _min: FormTravelOrderMinAggregateOutputType | null
    _max: FormTravelOrderMaxAggregateOutputType | null
  }

  export type FormTravelOrderAvgAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    mainFormId: number | null
  }

  export type FormTravelOrderSumAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    mainFormId: number | null
  }

  export type FormTravelOrderMinAggregateOutputType = {
    id: number | null
    name: string | null
    position: string | null
    departure_date: Date | null
    current_date: Date | null
    destination: string | null
    purpose_of_travel: string | null
    total_amount: Decimal | null
    createdAt: Date | null
    mainFormId: number | null
  }

  export type FormTravelOrderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    position: string | null
    departure_date: Date | null
    current_date: Date | null
    destination: string | null
    purpose_of_travel: string | null
    total_amount: Decimal | null
    createdAt: Date | null
    mainFormId: number | null
  }

  export type FormTravelOrderCountAggregateOutputType = {
    id: number
    name: number
    position: number
    departure_date: number
    current_date: number
    destination: number
    purpose_of_travel: number
    items: number
    total_amount: number
    createdAt: number
    mainFormId: number
    _all: number
  }


  export type FormTravelOrderAvgAggregateInputType = {
    id?: true
    total_amount?: true
    mainFormId?: true
  }

  export type FormTravelOrderSumAggregateInputType = {
    id?: true
    total_amount?: true
    mainFormId?: true
  }

  export type FormTravelOrderMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    departure_date?: true
    current_date?: true
    destination?: true
    purpose_of_travel?: true
    total_amount?: true
    createdAt?: true
    mainFormId?: true
  }

  export type FormTravelOrderMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    departure_date?: true
    current_date?: true
    destination?: true
    purpose_of_travel?: true
    total_amount?: true
    createdAt?: true
    mainFormId?: true
  }

  export type FormTravelOrderCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    departure_date?: true
    current_date?: true
    destination?: true
    purpose_of_travel?: true
    items?: true
    total_amount?: true
    createdAt?: true
    mainFormId?: true
    _all?: true
  }

  export type FormTravelOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formTravelOrder to aggregate.
     */
    where?: formTravelOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTravelOrders to fetch.
     */
    orderBy?: formTravelOrderOrderByWithRelationInput | formTravelOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formTravelOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTravelOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTravelOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formTravelOrders
    **/
    _count?: true | FormTravelOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormTravelOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormTravelOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTravelOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTravelOrderMaxAggregateInputType
  }

  export type GetFormTravelOrderAggregateType<T extends FormTravelOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTravelOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTravelOrder[P]>
      : GetScalarType<T[P], AggregateFormTravelOrder[P]>
  }




  export type formTravelOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formTravelOrderWhereInput
    orderBy?: formTravelOrderOrderByWithAggregationInput | formTravelOrderOrderByWithAggregationInput[]
    by: FormTravelOrderScalarFieldEnum[] | FormTravelOrderScalarFieldEnum
    having?: formTravelOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTravelOrderCountAggregateInputType | true
    _avg?: FormTravelOrderAvgAggregateInputType
    _sum?: FormTravelOrderSumAggregateInputType
    _min?: FormTravelOrderMinAggregateInputType
    _max?: FormTravelOrderMaxAggregateInputType
  }

  export type FormTravelOrderGroupByOutputType = {
    id: number
    name: string | null
    position: string | null
    departure_date: Date
    current_date: Date
    destination: string | null
    purpose_of_travel: string | null
    items: JsonValue | null
    total_amount: Decimal | null
    createdAt: Date
    mainFormId: number
    _count: FormTravelOrderCountAggregateOutputType | null
    _avg: FormTravelOrderAvgAggregateOutputType | null
    _sum: FormTravelOrderSumAggregateOutputType | null
    _min: FormTravelOrderMinAggregateOutputType | null
    _max: FormTravelOrderMaxAggregateOutputType | null
  }

  type GetFormTravelOrderGroupByPayload<T extends formTravelOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTravelOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTravelOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTravelOrderGroupByOutputType[P]>
            : GetScalarType<T[P], FormTravelOrderGroupByOutputType[P]>
        }
      >
    >


  export type formTravelOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    departure_date?: boolean
    current_date?: boolean
    destination?: boolean
    purpose_of_travel?: boolean
    items?: boolean
    total_amount?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTravelOrder"]>

  export type formTravelOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    departure_date?: boolean
    current_date?: boolean
    destination?: boolean
    purpose_of_travel?: boolean
    items?: boolean
    total_amount?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTravelOrder"]>

  export type formTravelOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    departure_date?: boolean
    current_date?: boolean
    destination?: boolean
    purpose_of_travel?: boolean
    items?: boolean
    total_amount?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTravelOrder"]>

  export type formTravelOrderSelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    departure_date?: boolean
    current_date?: boolean
    destination?: boolean
    purpose_of_travel?: boolean
    items?: boolean
    total_amount?: boolean
    createdAt?: boolean
    mainFormId?: boolean
  }

  export type formTravelOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "position" | "departure_date" | "current_date" | "destination" | "purpose_of_travel" | "items" | "total_amount" | "createdAt" | "mainFormId", ExtArgs["result"]["formTravelOrder"]>
  export type formTravelOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }
  export type formTravelOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }
  export type formTravelOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | formTravelOrder$mainFormArgs<ExtArgs>
  }

  export type $formTravelOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formTravelOrder"
    objects: {
      mainForm: Prisma.$MainRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      position: string | null
      departure_date: Date
      current_date: Date
      destination: string | null
      purpose_of_travel: string | null
      items: Prisma.JsonValue | null
      total_amount: Prisma.Decimal | null
      createdAt: Date
      mainFormId: number
    }, ExtArgs["result"]["formTravelOrder"]>
    composites: {}
  }

  type formTravelOrderGetPayload<S extends boolean | null | undefined | formTravelOrderDefaultArgs> = $Result.GetResult<Prisma.$formTravelOrderPayload, S>

  type formTravelOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formTravelOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormTravelOrderCountAggregateInputType | true
    }

  export interface formTravelOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formTravelOrder'], meta: { name: 'formTravelOrder' } }
    /**
     * Find zero or one FormTravelOrder that matches the filter.
     * @param {formTravelOrderFindUniqueArgs} args - Arguments to find a FormTravelOrder
     * @example
     * // Get one FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formTravelOrderFindUniqueArgs>(args: SelectSubset<T, formTravelOrderFindUniqueArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormTravelOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formTravelOrderFindUniqueOrThrowArgs} args - Arguments to find a FormTravelOrder
     * @example
     * // Get one FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formTravelOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, formTravelOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTravelOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderFindFirstArgs} args - Arguments to find a FormTravelOrder
     * @example
     * // Get one FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formTravelOrderFindFirstArgs>(args?: SelectSubset<T, formTravelOrderFindFirstArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTravelOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderFindFirstOrThrowArgs} args - Arguments to find a FormTravelOrder
     * @example
     * // Get one FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formTravelOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, formTravelOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormTravelOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTravelOrders
     * const formTravelOrders = await prisma.formTravelOrder.findMany()
     * 
     * // Get first 10 FormTravelOrders
     * const formTravelOrders = await prisma.formTravelOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTravelOrderWithIdOnly = await prisma.formTravelOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formTravelOrderFindManyArgs>(args?: SelectSubset<T, formTravelOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormTravelOrder.
     * @param {formTravelOrderCreateArgs} args - Arguments to create a FormTravelOrder.
     * @example
     * // Create one FormTravelOrder
     * const FormTravelOrder = await prisma.formTravelOrder.create({
     *   data: {
     *     // ... data to create a FormTravelOrder
     *   }
     * })
     * 
     */
    create<T extends formTravelOrderCreateArgs>(args: SelectSubset<T, formTravelOrderCreateArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormTravelOrders.
     * @param {formTravelOrderCreateManyArgs} args - Arguments to create many FormTravelOrders.
     * @example
     * // Create many FormTravelOrders
     * const formTravelOrder = await prisma.formTravelOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formTravelOrderCreateManyArgs>(args?: SelectSubset<T, formTravelOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTravelOrders and returns the data saved in the database.
     * @param {formTravelOrderCreateManyAndReturnArgs} args - Arguments to create many FormTravelOrders.
     * @example
     * // Create many FormTravelOrders
     * const formTravelOrder = await prisma.formTravelOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTravelOrders and only return the `id`
     * const formTravelOrderWithIdOnly = await prisma.formTravelOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends formTravelOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, formTravelOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormTravelOrder.
     * @param {formTravelOrderDeleteArgs} args - Arguments to delete one FormTravelOrder.
     * @example
     * // Delete one FormTravelOrder
     * const FormTravelOrder = await prisma.formTravelOrder.delete({
     *   where: {
     *     // ... filter to delete one FormTravelOrder
     *   }
     * })
     * 
     */
    delete<T extends formTravelOrderDeleteArgs>(args: SelectSubset<T, formTravelOrderDeleteArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormTravelOrder.
     * @param {formTravelOrderUpdateArgs} args - Arguments to update one FormTravelOrder.
     * @example
     * // Update one FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formTravelOrderUpdateArgs>(args: SelectSubset<T, formTravelOrderUpdateArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormTravelOrders.
     * @param {formTravelOrderDeleteManyArgs} args - Arguments to filter FormTravelOrders to delete.
     * @example
     * // Delete a few FormTravelOrders
     * const { count } = await prisma.formTravelOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formTravelOrderDeleteManyArgs>(args?: SelectSubset<T, formTravelOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTravelOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTravelOrders
     * const formTravelOrder = await prisma.formTravelOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formTravelOrderUpdateManyArgs>(args: SelectSubset<T, formTravelOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTravelOrders and returns the data updated in the database.
     * @param {formTravelOrderUpdateManyAndReturnArgs} args - Arguments to update many FormTravelOrders.
     * @example
     * // Update many FormTravelOrders
     * const formTravelOrder = await prisma.formTravelOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormTravelOrders and only return the `id`
     * const formTravelOrderWithIdOnly = await prisma.formTravelOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends formTravelOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, formTravelOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormTravelOrder.
     * @param {formTravelOrderUpsertArgs} args - Arguments to update or create a FormTravelOrder.
     * @example
     * // Update or create a FormTravelOrder
     * const formTravelOrder = await prisma.formTravelOrder.upsert({
     *   create: {
     *     // ... data to create a FormTravelOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTravelOrder we want to update
     *   }
     * })
     */
    upsert<T extends formTravelOrderUpsertArgs>(args: SelectSubset<T, formTravelOrderUpsertArgs<ExtArgs>>): Prisma__formTravelOrderClient<$Result.GetResult<Prisma.$formTravelOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormTravelOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderCountArgs} args - Arguments to filter FormTravelOrders to count.
     * @example
     * // Count the number of FormTravelOrders
     * const count = await prisma.formTravelOrder.count({
     *   where: {
     *     // ... the filter for the FormTravelOrders we want to count
     *   }
     * })
    **/
    count<T extends formTravelOrderCountArgs>(
      args?: Subset<T, formTravelOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTravelOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTravelOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTravelOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTravelOrderAggregateArgs>(args: Subset<T, FormTravelOrderAggregateArgs>): Prisma.PrismaPromise<GetFormTravelOrderAggregateType<T>>

    /**
     * Group by FormTravelOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTravelOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formTravelOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formTravelOrderGroupByArgs['orderBy'] }
        : { orderBy?: formTravelOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formTravelOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTravelOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formTravelOrder model
   */
  readonly fields: formTravelOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formTravelOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formTravelOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainForm<T extends formTravelOrder$mainFormArgs<ExtArgs> = {}>(args?: Subset<T, formTravelOrder$mainFormArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formTravelOrder model
   */
  interface formTravelOrderFieldRefs {
    readonly id: FieldRef<"formTravelOrder", 'Int'>
    readonly name: FieldRef<"formTravelOrder", 'String'>
    readonly position: FieldRef<"formTravelOrder", 'String'>
    readonly departure_date: FieldRef<"formTravelOrder", 'DateTime'>
    readonly current_date: FieldRef<"formTravelOrder", 'DateTime'>
    readonly destination: FieldRef<"formTravelOrder", 'String'>
    readonly purpose_of_travel: FieldRef<"formTravelOrder", 'String'>
    readonly items: FieldRef<"formTravelOrder", 'Json'>
    readonly total_amount: FieldRef<"formTravelOrder", 'Decimal'>
    readonly createdAt: FieldRef<"formTravelOrder", 'DateTime'>
    readonly mainFormId: FieldRef<"formTravelOrder", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * formTravelOrder findUnique
   */
  export type formTravelOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter, which formTravelOrder to fetch.
     */
    where: formTravelOrderWhereUniqueInput
  }

  /**
   * formTravelOrder findUniqueOrThrow
   */
  export type formTravelOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter, which formTravelOrder to fetch.
     */
    where: formTravelOrderWhereUniqueInput
  }

  /**
   * formTravelOrder findFirst
   */
  export type formTravelOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter, which formTravelOrder to fetch.
     */
    where?: formTravelOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTravelOrders to fetch.
     */
    orderBy?: formTravelOrderOrderByWithRelationInput | formTravelOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formTravelOrders.
     */
    cursor?: formTravelOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTravelOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTravelOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formTravelOrders.
     */
    distinct?: FormTravelOrderScalarFieldEnum | FormTravelOrderScalarFieldEnum[]
  }

  /**
   * formTravelOrder findFirstOrThrow
   */
  export type formTravelOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter, which formTravelOrder to fetch.
     */
    where?: formTravelOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTravelOrders to fetch.
     */
    orderBy?: formTravelOrderOrderByWithRelationInput | formTravelOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formTravelOrders.
     */
    cursor?: formTravelOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTravelOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTravelOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formTravelOrders.
     */
    distinct?: FormTravelOrderScalarFieldEnum | FormTravelOrderScalarFieldEnum[]
  }

  /**
   * formTravelOrder findMany
   */
  export type formTravelOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter, which formTravelOrders to fetch.
     */
    where?: formTravelOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTravelOrders to fetch.
     */
    orderBy?: formTravelOrderOrderByWithRelationInput | formTravelOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formTravelOrders.
     */
    cursor?: formTravelOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTravelOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTravelOrders.
     */
    skip?: number
    distinct?: FormTravelOrderScalarFieldEnum | FormTravelOrderScalarFieldEnum[]
  }

  /**
   * formTravelOrder create
   */
  export type formTravelOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a formTravelOrder.
     */
    data: XOR<formTravelOrderCreateInput, formTravelOrderUncheckedCreateInput>
  }

  /**
   * formTravelOrder createMany
   */
  export type formTravelOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formTravelOrders.
     */
    data: formTravelOrderCreateManyInput | formTravelOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formTravelOrder createManyAndReturn
   */
  export type formTravelOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * The data used to create many formTravelOrders.
     */
    data: formTravelOrderCreateManyInput | formTravelOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * formTravelOrder update
   */
  export type formTravelOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a formTravelOrder.
     */
    data: XOR<formTravelOrderUpdateInput, formTravelOrderUncheckedUpdateInput>
    /**
     * Choose, which formTravelOrder to update.
     */
    where: formTravelOrderWhereUniqueInput
  }

  /**
   * formTravelOrder updateMany
   */
  export type formTravelOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formTravelOrders.
     */
    data: XOR<formTravelOrderUpdateManyMutationInput, formTravelOrderUncheckedUpdateManyInput>
    /**
     * Filter which formTravelOrders to update
     */
    where?: formTravelOrderWhereInput
    /**
     * Limit how many formTravelOrders to update.
     */
    limit?: number
  }

  /**
   * formTravelOrder updateManyAndReturn
   */
  export type formTravelOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * The data used to update formTravelOrders.
     */
    data: XOR<formTravelOrderUpdateManyMutationInput, formTravelOrderUncheckedUpdateManyInput>
    /**
     * Filter which formTravelOrders to update
     */
    where?: formTravelOrderWhereInput
    /**
     * Limit how many formTravelOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * formTravelOrder upsert
   */
  export type formTravelOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the formTravelOrder to update in case it exists.
     */
    where: formTravelOrderWhereUniqueInput
    /**
     * In case the formTravelOrder found by the `where` argument doesn't exist, create a new formTravelOrder with this data.
     */
    create: XOR<formTravelOrderCreateInput, formTravelOrderUncheckedCreateInput>
    /**
     * In case the formTravelOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formTravelOrderUpdateInput, formTravelOrderUncheckedUpdateInput>
  }

  /**
   * formTravelOrder delete
   */
  export type formTravelOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
    /**
     * Filter which formTravelOrder to delete.
     */
    where: formTravelOrderWhereUniqueInput
  }

  /**
   * formTravelOrder deleteMany
   */
  export type formTravelOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formTravelOrders to delete
     */
    where?: formTravelOrderWhereInput
    /**
     * Limit how many formTravelOrders to delete.
     */
    limit?: number
  }

  /**
   * formTravelOrder.mainForm
   */
  export type formTravelOrder$mainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * formTravelOrder without action
   */
  export type formTravelOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTravelOrder
     */
    select?: formTravelOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTravelOrder
     */
    omit?: formTravelOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTravelOrderInclude<ExtArgs> | null
  }


  /**
   * Model formProposedBudget
   */

  export type AggregateFormProposedBudget = {
    _count: FormProposedBudgetCountAggregateOutputType | null
    _avg: FormProposedBudgetAvgAggregateOutputType | null
    _sum: FormProposedBudgetSumAggregateOutputType | null
    _min: FormProposedBudgetMinAggregateOutputType | null
    _max: FormProposedBudgetMaxAggregateOutputType | null
  }

  export type FormProposedBudgetAvgAggregateOutputType = {
    id: number | null
    budget: Decimal | null
    total_expenses: Decimal | null
    variance: Decimal | null
    proposed_budget: Decimal | null
    mainFormId: number | null
  }

  export type FormProposedBudgetSumAggregateOutputType = {
    id: number | null
    budget: Decimal | null
    total_expenses: Decimal | null
    variance: Decimal | null
    proposed_budget: Decimal | null
    mainFormId: number | null
  }

  export type FormProposedBudgetMinAggregateOutputType = {
    id: number | null
    description: string | null
    budget: Decimal | null
    total_expenses: Decimal | null
    variance: Decimal | null
    proposed_budget: Decimal | null
    remarks: string | null
    expense_type: string | null
    month_of: string | null
    createdAt: Date | null
    mainFormId: number | null
  }

  export type FormProposedBudgetMaxAggregateOutputType = {
    id: number | null
    description: string | null
    budget: Decimal | null
    total_expenses: Decimal | null
    variance: Decimal | null
    proposed_budget: Decimal | null
    remarks: string | null
    expense_type: string | null
    month_of: string | null
    createdAt: Date | null
    mainFormId: number | null
  }

  export type FormProposedBudgetCountAggregateOutputType = {
    id: number
    description: number
    budget: number
    total_expenses: number
    variance: number
    proposed_budget: number
    remarks: number
    expense_type: number
    month_of: number
    createdAt: number
    mainFormId: number
    _all: number
  }


  export type FormProposedBudgetAvgAggregateInputType = {
    id?: true
    budget?: true
    total_expenses?: true
    variance?: true
    proposed_budget?: true
    mainFormId?: true
  }

  export type FormProposedBudgetSumAggregateInputType = {
    id?: true
    budget?: true
    total_expenses?: true
    variance?: true
    proposed_budget?: true
    mainFormId?: true
  }

  export type FormProposedBudgetMinAggregateInputType = {
    id?: true
    description?: true
    budget?: true
    total_expenses?: true
    variance?: true
    proposed_budget?: true
    remarks?: true
    expense_type?: true
    month_of?: true
    createdAt?: true
    mainFormId?: true
  }

  export type FormProposedBudgetMaxAggregateInputType = {
    id?: true
    description?: true
    budget?: true
    total_expenses?: true
    variance?: true
    proposed_budget?: true
    remarks?: true
    expense_type?: true
    month_of?: true
    createdAt?: true
    mainFormId?: true
  }

  export type FormProposedBudgetCountAggregateInputType = {
    id?: true
    description?: true
    budget?: true
    total_expenses?: true
    variance?: true
    proposed_budget?: true
    remarks?: true
    expense_type?: true
    month_of?: true
    createdAt?: true
    mainFormId?: true
    _all?: true
  }

  export type FormProposedBudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formProposedBudget to aggregate.
     */
    where?: formProposedBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formProposedBudgets to fetch.
     */
    orderBy?: formProposedBudgetOrderByWithRelationInput | formProposedBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formProposedBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formProposedBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formProposedBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formProposedBudgets
    **/
    _count?: true | FormProposedBudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormProposedBudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormProposedBudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormProposedBudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormProposedBudgetMaxAggregateInputType
  }

  export type GetFormProposedBudgetAggregateType<T extends FormProposedBudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateFormProposedBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormProposedBudget[P]>
      : GetScalarType<T[P], AggregateFormProposedBudget[P]>
  }




  export type formProposedBudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formProposedBudgetWhereInput
    orderBy?: formProposedBudgetOrderByWithAggregationInput | formProposedBudgetOrderByWithAggregationInput[]
    by: FormProposedBudgetScalarFieldEnum[] | FormProposedBudgetScalarFieldEnum
    having?: formProposedBudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormProposedBudgetCountAggregateInputType | true
    _avg?: FormProposedBudgetAvgAggregateInputType
    _sum?: FormProposedBudgetSumAggregateInputType
    _min?: FormProposedBudgetMinAggregateInputType
    _max?: FormProposedBudgetMaxAggregateInputType
  }

  export type FormProposedBudgetGroupByOutputType = {
    id: number
    description: string | null
    budget: Decimal | null
    total_expenses: Decimal | null
    variance: Decimal | null
    proposed_budget: Decimal | null
    remarks: string | null
    expense_type: string | null
    month_of: string | null
    createdAt: Date
    mainFormId: number
    _count: FormProposedBudgetCountAggregateOutputType | null
    _avg: FormProposedBudgetAvgAggregateOutputType | null
    _sum: FormProposedBudgetSumAggregateOutputType | null
    _min: FormProposedBudgetMinAggregateOutputType | null
    _max: FormProposedBudgetMaxAggregateOutputType | null
  }

  type GetFormProposedBudgetGroupByPayload<T extends formProposedBudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormProposedBudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormProposedBudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormProposedBudgetGroupByOutputType[P]>
            : GetScalarType<T[P], FormProposedBudgetGroupByOutputType[P]>
        }
      >
    >


  export type formProposedBudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    budget?: boolean
    total_expenses?: boolean
    variance?: boolean
    proposed_budget?: boolean
    remarks?: boolean
    expense_type?: boolean
    month_of?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formProposedBudget"]>

  export type formProposedBudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    budget?: boolean
    total_expenses?: boolean
    variance?: boolean
    proposed_budget?: boolean
    remarks?: boolean
    expense_type?: boolean
    month_of?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formProposedBudget"]>

  export type formProposedBudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    budget?: boolean
    total_expenses?: boolean
    variance?: boolean
    proposed_budget?: boolean
    remarks?: boolean
    expense_type?: boolean
    month_of?: boolean
    createdAt?: boolean
    mainFormId?: boolean
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formProposedBudget"]>

  export type formProposedBudgetSelectScalar = {
    id?: boolean
    description?: boolean
    budget?: boolean
    total_expenses?: boolean
    variance?: boolean
    proposed_budget?: boolean
    remarks?: boolean
    expense_type?: boolean
    month_of?: boolean
    createdAt?: boolean
    mainFormId?: boolean
  }

  export type formProposedBudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "budget" | "total_expenses" | "variance" | "proposed_budget" | "remarks" | "expense_type" | "month_of" | "createdAt" | "mainFormId", ExtArgs["result"]["formProposedBudget"]>
  export type formProposedBudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }
  export type formProposedBudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }
  export type formProposedBudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mainForm?: boolean | MainRequestDefaultArgs<ExtArgs>
  }

  export type $formProposedBudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formProposedBudget"
    objects: {
      mainForm: Prisma.$MainRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string | null
      budget: Prisma.Decimal | null
      total_expenses: Prisma.Decimal | null
      variance: Prisma.Decimal | null
      proposed_budget: Prisma.Decimal | null
      remarks: string | null
      expense_type: string | null
      month_of: string | null
      createdAt: Date
      mainFormId: number
    }, ExtArgs["result"]["formProposedBudget"]>
    composites: {}
  }

  type formProposedBudgetGetPayload<S extends boolean | null | undefined | formProposedBudgetDefaultArgs> = $Result.GetResult<Prisma.$formProposedBudgetPayload, S>

  type formProposedBudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formProposedBudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormProposedBudgetCountAggregateInputType | true
    }

  export interface formProposedBudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formProposedBudget'], meta: { name: 'formProposedBudget' } }
    /**
     * Find zero or one FormProposedBudget that matches the filter.
     * @param {formProposedBudgetFindUniqueArgs} args - Arguments to find a FormProposedBudget
     * @example
     * // Get one FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formProposedBudgetFindUniqueArgs>(args: SelectSubset<T, formProposedBudgetFindUniqueArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormProposedBudget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formProposedBudgetFindUniqueOrThrowArgs} args - Arguments to find a FormProposedBudget
     * @example
     * // Get one FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formProposedBudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, formProposedBudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormProposedBudget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetFindFirstArgs} args - Arguments to find a FormProposedBudget
     * @example
     * // Get one FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formProposedBudgetFindFirstArgs>(args?: SelectSubset<T, formProposedBudgetFindFirstArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormProposedBudget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetFindFirstOrThrowArgs} args - Arguments to find a FormProposedBudget
     * @example
     * // Get one FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formProposedBudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, formProposedBudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormProposedBudgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormProposedBudgets
     * const formProposedBudgets = await prisma.formProposedBudget.findMany()
     * 
     * // Get first 10 FormProposedBudgets
     * const formProposedBudgets = await prisma.formProposedBudget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formProposedBudgetWithIdOnly = await prisma.formProposedBudget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formProposedBudgetFindManyArgs>(args?: SelectSubset<T, formProposedBudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormProposedBudget.
     * @param {formProposedBudgetCreateArgs} args - Arguments to create a FormProposedBudget.
     * @example
     * // Create one FormProposedBudget
     * const FormProposedBudget = await prisma.formProposedBudget.create({
     *   data: {
     *     // ... data to create a FormProposedBudget
     *   }
     * })
     * 
     */
    create<T extends formProposedBudgetCreateArgs>(args: SelectSubset<T, formProposedBudgetCreateArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormProposedBudgets.
     * @param {formProposedBudgetCreateManyArgs} args - Arguments to create many FormProposedBudgets.
     * @example
     * // Create many FormProposedBudgets
     * const formProposedBudget = await prisma.formProposedBudget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formProposedBudgetCreateManyArgs>(args?: SelectSubset<T, formProposedBudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormProposedBudgets and returns the data saved in the database.
     * @param {formProposedBudgetCreateManyAndReturnArgs} args - Arguments to create many FormProposedBudgets.
     * @example
     * // Create many FormProposedBudgets
     * const formProposedBudget = await prisma.formProposedBudget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormProposedBudgets and only return the `id`
     * const formProposedBudgetWithIdOnly = await prisma.formProposedBudget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends formProposedBudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, formProposedBudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormProposedBudget.
     * @param {formProposedBudgetDeleteArgs} args - Arguments to delete one FormProposedBudget.
     * @example
     * // Delete one FormProposedBudget
     * const FormProposedBudget = await prisma.formProposedBudget.delete({
     *   where: {
     *     // ... filter to delete one FormProposedBudget
     *   }
     * })
     * 
     */
    delete<T extends formProposedBudgetDeleteArgs>(args: SelectSubset<T, formProposedBudgetDeleteArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormProposedBudget.
     * @param {formProposedBudgetUpdateArgs} args - Arguments to update one FormProposedBudget.
     * @example
     * // Update one FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formProposedBudgetUpdateArgs>(args: SelectSubset<T, formProposedBudgetUpdateArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormProposedBudgets.
     * @param {formProposedBudgetDeleteManyArgs} args - Arguments to filter FormProposedBudgets to delete.
     * @example
     * // Delete a few FormProposedBudgets
     * const { count } = await prisma.formProposedBudget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formProposedBudgetDeleteManyArgs>(args?: SelectSubset<T, formProposedBudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormProposedBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormProposedBudgets
     * const formProposedBudget = await prisma.formProposedBudget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formProposedBudgetUpdateManyArgs>(args: SelectSubset<T, formProposedBudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormProposedBudgets and returns the data updated in the database.
     * @param {formProposedBudgetUpdateManyAndReturnArgs} args - Arguments to update many FormProposedBudgets.
     * @example
     * // Update many FormProposedBudgets
     * const formProposedBudget = await prisma.formProposedBudget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormProposedBudgets and only return the `id`
     * const formProposedBudgetWithIdOnly = await prisma.formProposedBudget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends formProposedBudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, formProposedBudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormProposedBudget.
     * @param {formProposedBudgetUpsertArgs} args - Arguments to update or create a FormProposedBudget.
     * @example
     * // Update or create a FormProposedBudget
     * const formProposedBudget = await prisma.formProposedBudget.upsert({
     *   create: {
     *     // ... data to create a FormProposedBudget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormProposedBudget we want to update
     *   }
     * })
     */
    upsert<T extends formProposedBudgetUpsertArgs>(args: SelectSubset<T, formProposedBudgetUpsertArgs<ExtArgs>>): Prisma__formProposedBudgetClient<$Result.GetResult<Prisma.$formProposedBudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormProposedBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetCountArgs} args - Arguments to filter FormProposedBudgets to count.
     * @example
     * // Count the number of FormProposedBudgets
     * const count = await prisma.formProposedBudget.count({
     *   where: {
     *     // ... the filter for the FormProposedBudgets we want to count
     *   }
     * })
    **/
    count<T extends formProposedBudgetCountArgs>(
      args?: Subset<T, formProposedBudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormProposedBudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormProposedBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormProposedBudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormProposedBudgetAggregateArgs>(args: Subset<T, FormProposedBudgetAggregateArgs>): Prisma.PrismaPromise<GetFormProposedBudgetAggregateType<T>>

    /**
     * Group by FormProposedBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formProposedBudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formProposedBudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formProposedBudgetGroupByArgs['orderBy'] }
        : { orderBy?: formProposedBudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formProposedBudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormProposedBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formProposedBudget model
   */
  readonly fields: formProposedBudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formProposedBudget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formProposedBudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mainForm<T extends MainRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MainRequestDefaultArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formProposedBudget model
   */
  interface formProposedBudgetFieldRefs {
    readonly id: FieldRef<"formProposedBudget", 'Int'>
    readonly description: FieldRef<"formProposedBudget", 'String'>
    readonly budget: FieldRef<"formProposedBudget", 'Decimal'>
    readonly total_expenses: FieldRef<"formProposedBudget", 'Decimal'>
    readonly variance: FieldRef<"formProposedBudget", 'Decimal'>
    readonly proposed_budget: FieldRef<"formProposedBudget", 'Decimal'>
    readonly remarks: FieldRef<"formProposedBudget", 'String'>
    readonly expense_type: FieldRef<"formProposedBudget", 'String'>
    readonly month_of: FieldRef<"formProposedBudget", 'String'>
    readonly createdAt: FieldRef<"formProposedBudget", 'DateTime'>
    readonly mainFormId: FieldRef<"formProposedBudget", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * formProposedBudget findUnique
   */
  export type formProposedBudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter, which formProposedBudget to fetch.
     */
    where: formProposedBudgetWhereUniqueInput
  }

  /**
   * formProposedBudget findUniqueOrThrow
   */
  export type formProposedBudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter, which formProposedBudget to fetch.
     */
    where: formProposedBudgetWhereUniqueInput
  }

  /**
   * formProposedBudget findFirst
   */
  export type formProposedBudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter, which formProposedBudget to fetch.
     */
    where?: formProposedBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formProposedBudgets to fetch.
     */
    orderBy?: formProposedBudgetOrderByWithRelationInput | formProposedBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formProposedBudgets.
     */
    cursor?: formProposedBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formProposedBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formProposedBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formProposedBudgets.
     */
    distinct?: FormProposedBudgetScalarFieldEnum | FormProposedBudgetScalarFieldEnum[]
  }

  /**
   * formProposedBudget findFirstOrThrow
   */
  export type formProposedBudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter, which formProposedBudget to fetch.
     */
    where?: formProposedBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formProposedBudgets to fetch.
     */
    orderBy?: formProposedBudgetOrderByWithRelationInput | formProposedBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formProposedBudgets.
     */
    cursor?: formProposedBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formProposedBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formProposedBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formProposedBudgets.
     */
    distinct?: FormProposedBudgetScalarFieldEnum | FormProposedBudgetScalarFieldEnum[]
  }

  /**
   * formProposedBudget findMany
   */
  export type formProposedBudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter, which formProposedBudgets to fetch.
     */
    where?: formProposedBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formProposedBudgets to fetch.
     */
    orderBy?: formProposedBudgetOrderByWithRelationInput | formProposedBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formProposedBudgets.
     */
    cursor?: formProposedBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formProposedBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formProposedBudgets.
     */
    skip?: number
    distinct?: FormProposedBudgetScalarFieldEnum | FormProposedBudgetScalarFieldEnum[]
  }

  /**
   * formProposedBudget create
   */
  export type formProposedBudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a formProposedBudget.
     */
    data: XOR<formProposedBudgetCreateInput, formProposedBudgetUncheckedCreateInput>
  }

  /**
   * formProposedBudget createMany
   */
  export type formProposedBudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formProposedBudgets.
     */
    data: formProposedBudgetCreateManyInput | formProposedBudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formProposedBudget createManyAndReturn
   */
  export type formProposedBudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * The data used to create many formProposedBudgets.
     */
    data: formProposedBudgetCreateManyInput | formProposedBudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * formProposedBudget update
   */
  export type formProposedBudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a formProposedBudget.
     */
    data: XOR<formProposedBudgetUpdateInput, formProposedBudgetUncheckedUpdateInput>
    /**
     * Choose, which formProposedBudget to update.
     */
    where: formProposedBudgetWhereUniqueInput
  }

  /**
   * formProposedBudget updateMany
   */
  export type formProposedBudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formProposedBudgets.
     */
    data: XOR<formProposedBudgetUpdateManyMutationInput, formProposedBudgetUncheckedUpdateManyInput>
    /**
     * Filter which formProposedBudgets to update
     */
    where?: formProposedBudgetWhereInput
    /**
     * Limit how many formProposedBudgets to update.
     */
    limit?: number
  }

  /**
   * formProposedBudget updateManyAndReturn
   */
  export type formProposedBudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * The data used to update formProposedBudgets.
     */
    data: XOR<formProposedBudgetUpdateManyMutationInput, formProposedBudgetUncheckedUpdateManyInput>
    /**
     * Filter which formProposedBudgets to update
     */
    where?: formProposedBudgetWhereInput
    /**
     * Limit how many formProposedBudgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * formProposedBudget upsert
   */
  export type formProposedBudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the formProposedBudget to update in case it exists.
     */
    where: formProposedBudgetWhereUniqueInput
    /**
     * In case the formProposedBudget found by the `where` argument doesn't exist, create a new formProposedBudget with this data.
     */
    create: XOR<formProposedBudgetCreateInput, formProposedBudgetUncheckedCreateInput>
    /**
     * In case the formProposedBudget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formProposedBudgetUpdateInput, formProposedBudgetUncheckedUpdateInput>
  }

  /**
   * formProposedBudget delete
   */
  export type formProposedBudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
    /**
     * Filter which formProposedBudget to delete.
     */
    where: formProposedBudgetWhereUniqueInput
  }

  /**
   * formProposedBudget deleteMany
   */
  export type formProposedBudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formProposedBudgets to delete
     */
    where?: formProposedBudgetWhereInput
    /**
     * Limit how many formProposedBudgets to delete.
     */
    limit?: number
  }

  /**
   * formProposedBudget without action
   */
  export type formProposedBudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formProposedBudget
     */
    select?: formProposedBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formProposedBudget
     */
    omit?: formProposedBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formProposedBudgetInclude<ExtArgs> | null
  }


  /**
   * Model formTransmittalMemo
   */

  export type AggregateFormTransmittalMemo = {
    _count: FormTransmittalMemoCountAggregateOutputType | null
    _avg: FormTransmittalMemoAvgAggregateOutputType | null
    _sum: FormTransmittalMemoSumAggregateOutputType | null
    _min: FormTransmittalMemoMinAggregateOutputType | null
    _max: FormTransmittalMemoMaxAggregateOutputType | null
  }

  export type FormTransmittalMemoAvgAggregateOutputType = {
    id: number | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormTransmittalMemoSumAggregateOutputType = {
    id: number | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormTransmittalMemoMinAggregateOutputType = {
    id: number | null
    from: string | null
    date: Date | null
    description: string | null
    note: string | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormTransmittalMemoMaxAggregateOutputType = {
    id: number | null
    from: string | null
    date: Date | null
    description: string | null
    note: string | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormTransmittalMemoCountAggregateOutputType = {
    id: number
    from: number
    date: number
    description: number
    note: number
    items: number
    to_id: number
    mainFormId: number
    _all: number
  }


  export type FormTransmittalMemoAvgAggregateInputType = {
    id?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormTransmittalMemoSumAggregateInputType = {
    id?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormTransmittalMemoMinAggregateInputType = {
    id?: true
    from?: true
    date?: true
    description?: true
    note?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormTransmittalMemoMaxAggregateInputType = {
    id?: true
    from?: true
    date?: true
    description?: true
    note?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormTransmittalMemoCountAggregateInputType = {
    id?: true
    from?: true
    date?: true
    description?: true
    note?: true
    items?: true
    to_id?: true
    mainFormId?: true
    _all?: true
  }

  export type FormTransmittalMemoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formTransmittalMemo to aggregate.
     */
    where?: formTransmittalMemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTransmittalMemos to fetch.
     */
    orderBy?: formTransmittalMemoOrderByWithRelationInput | formTransmittalMemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formTransmittalMemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTransmittalMemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTransmittalMemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formTransmittalMemos
    **/
    _count?: true | FormTransmittalMemoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormTransmittalMemoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormTransmittalMemoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTransmittalMemoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTransmittalMemoMaxAggregateInputType
  }

  export type GetFormTransmittalMemoAggregateType<T extends FormTransmittalMemoAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTransmittalMemo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTransmittalMemo[P]>
      : GetScalarType<T[P], AggregateFormTransmittalMemo[P]>
  }




  export type formTransmittalMemoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formTransmittalMemoWhereInput
    orderBy?: formTransmittalMemoOrderByWithAggregationInput | formTransmittalMemoOrderByWithAggregationInput[]
    by: FormTransmittalMemoScalarFieldEnum[] | FormTransmittalMemoScalarFieldEnum
    having?: formTransmittalMemoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTransmittalMemoCountAggregateInputType | true
    _avg?: FormTransmittalMemoAvgAggregateInputType
    _sum?: FormTransmittalMemoSumAggregateInputType
    _min?: FormTransmittalMemoMinAggregateInputType
    _max?: FormTransmittalMemoMaxAggregateInputType
  }

  export type FormTransmittalMemoGroupByOutputType = {
    id: number
    from: string | null
    date: Date
    description: string | null
    note: string | null
    items: JsonValue | null
    to_id: number | null
    mainFormId: number
    _count: FormTransmittalMemoCountAggregateOutputType | null
    _avg: FormTransmittalMemoAvgAggregateOutputType | null
    _sum: FormTransmittalMemoSumAggregateOutputType | null
    _min: FormTransmittalMemoMinAggregateOutputType | null
    _max: FormTransmittalMemoMaxAggregateOutputType | null
  }

  type GetFormTransmittalMemoGroupByPayload<T extends formTransmittalMemoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTransmittalMemoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTransmittalMemoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTransmittalMemoGroupByOutputType[P]>
            : GetScalarType<T[P], FormTransmittalMemoGroupByOutputType[P]>
        }
      >
    >


  export type formTransmittalMemoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    description?: boolean
    note?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTransmittalMemo"]>

  export type formTransmittalMemoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    description?: boolean
    note?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTransmittalMemo"]>

  export type formTransmittalMemoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    description?: boolean
    note?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formTransmittalMemo"]>

  export type formTransmittalMemoSelectScalar = {
    id?: boolean
    from?: boolean
    date?: boolean
    description?: boolean
    note?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
  }

  export type formTransmittalMemoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from" | "date" | "description" | "note" | "items" | "to_id" | "mainFormId", ExtArgs["result"]["formTransmittalMemo"]>
  export type formTransmittalMemoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }
  export type formTransmittalMemoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }
  export type formTransmittalMemoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formTransmittalMemo$requestToArgs<ExtArgs>
    mainForm?: boolean | formTransmittalMemo$mainFormArgs<ExtArgs>
  }

  export type $formTransmittalMemoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formTransmittalMemo"
    objects: {
      requestTo: Prisma.$UserPayload<ExtArgs> | null
      mainForm: Prisma.$MainRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      from: string | null
      date: Date
      description: string | null
      note: string | null
      items: Prisma.JsonValue | null
      to_id: number | null
      mainFormId: number
    }, ExtArgs["result"]["formTransmittalMemo"]>
    composites: {}
  }

  type formTransmittalMemoGetPayload<S extends boolean | null | undefined | formTransmittalMemoDefaultArgs> = $Result.GetResult<Prisma.$formTransmittalMemoPayload, S>

  type formTransmittalMemoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formTransmittalMemoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormTransmittalMemoCountAggregateInputType | true
    }

  export interface formTransmittalMemoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formTransmittalMemo'], meta: { name: 'formTransmittalMemo' } }
    /**
     * Find zero or one FormTransmittalMemo that matches the filter.
     * @param {formTransmittalMemoFindUniqueArgs} args - Arguments to find a FormTransmittalMemo
     * @example
     * // Get one FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formTransmittalMemoFindUniqueArgs>(args: SelectSubset<T, formTransmittalMemoFindUniqueArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormTransmittalMemo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formTransmittalMemoFindUniqueOrThrowArgs} args - Arguments to find a FormTransmittalMemo
     * @example
     * // Get one FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formTransmittalMemoFindUniqueOrThrowArgs>(args: SelectSubset<T, formTransmittalMemoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTransmittalMemo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoFindFirstArgs} args - Arguments to find a FormTransmittalMemo
     * @example
     * // Get one FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formTransmittalMemoFindFirstArgs>(args?: SelectSubset<T, formTransmittalMemoFindFirstArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTransmittalMemo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoFindFirstOrThrowArgs} args - Arguments to find a FormTransmittalMemo
     * @example
     * // Get one FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formTransmittalMemoFindFirstOrThrowArgs>(args?: SelectSubset<T, formTransmittalMemoFindFirstOrThrowArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormTransmittalMemos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTransmittalMemos
     * const formTransmittalMemos = await prisma.formTransmittalMemo.findMany()
     * 
     * // Get first 10 FormTransmittalMemos
     * const formTransmittalMemos = await prisma.formTransmittalMemo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTransmittalMemoWithIdOnly = await prisma.formTransmittalMemo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formTransmittalMemoFindManyArgs>(args?: SelectSubset<T, formTransmittalMemoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormTransmittalMemo.
     * @param {formTransmittalMemoCreateArgs} args - Arguments to create a FormTransmittalMemo.
     * @example
     * // Create one FormTransmittalMemo
     * const FormTransmittalMemo = await prisma.formTransmittalMemo.create({
     *   data: {
     *     // ... data to create a FormTransmittalMemo
     *   }
     * })
     * 
     */
    create<T extends formTransmittalMemoCreateArgs>(args: SelectSubset<T, formTransmittalMemoCreateArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormTransmittalMemos.
     * @param {formTransmittalMemoCreateManyArgs} args - Arguments to create many FormTransmittalMemos.
     * @example
     * // Create many FormTransmittalMemos
     * const formTransmittalMemo = await prisma.formTransmittalMemo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formTransmittalMemoCreateManyArgs>(args?: SelectSubset<T, formTransmittalMemoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTransmittalMemos and returns the data saved in the database.
     * @param {formTransmittalMemoCreateManyAndReturnArgs} args - Arguments to create many FormTransmittalMemos.
     * @example
     * // Create many FormTransmittalMemos
     * const formTransmittalMemo = await prisma.formTransmittalMemo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTransmittalMemos and only return the `id`
     * const formTransmittalMemoWithIdOnly = await prisma.formTransmittalMemo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends formTransmittalMemoCreateManyAndReturnArgs>(args?: SelectSubset<T, formTransmittalMemoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormTransmittalMemo.
     * @param {formTransmittalMemoDeleteArgs} args - Arguments to delete one FormTransmittalMemo.
     * @example
     * // Delete one FormTransmittalMemo
     * const FormTransmittalMemo = await prisma.formTransmittalMemo.delete({
     *   where: {
     *     // ... filter to delete one FormTransmittalMemo
     *   }
     * })
     * 
     */
    delete<T extends formTransmittalMemoDeleteArgs>(args: SelectSubset<T, formTransmittalMemoDeleteArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormTransmittalMemo.
     * @param {formTransmittalMemoUpdateArgs} args - Arguments to update one FormTransmittalMemo.
     * @example
     * // Update one FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formTransmittalMemoUpdateArgs>(args: SelectSubset<T, formTransmittalMemoUpdateArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormTransmittalMemos.
     * @param {formTransmittalMemoDeleteManyArgs} args - Arguments to filter FormTransmittalMemos to delete.
     * @example
     * // Delete a few FormTransmittalMemos
     * const { count } = await prisma.formTransmittalMemo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formTransmittalMemoDeleteManyArgs>(args?: SelectSubset<T, formTransmittalMemoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTransmittalMemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTransmittalMemos
     * const formTransmittalMemo = await prisma.formTransmittalMemo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formTransmittalMemoUpdateManyArgs>(args: SelectSubset<T, formTransmittalMemoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTransmittalMemos and returns the data updated in the database.
     * @param {formTransmittalMemoUpdateManyAndReturnArgs} args - Arguments to update many FormTransmittalMemos.
     * @example
     * // Update many FormTransmittalMemos
     * const formTransmittalMemo = await prisma.formTransmittalMemo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormTransmittalMemos and only return the `id`
     * const formTransmittalMemoWithIdOnly = await prisma.formTransmittalMemo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends formTransmittalMemoUpdateManyAndReturnArgs>(args: SelectSubset<T, formTransmittalMemoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormTransmittalMemo.
     * @param {formTransmittalMemoUpsertArgs} args - Arguments to update or create a FormTransmittalMemo.
     * @example
     * // Update or create a FormTransmittalMemo
     * const formTransmittalMemo = await prisma.formTransmittalMemo.upsert({
     *   create: {
     *     // ... data to create a FormTransmittalMemo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTransmittalMemo we want to update
     *   }
     * })
     */
    upsert<T extends formTransmittalMemoUpsertArgs>(args: SelectSubset<T, formTransmittalMemoUpsertArgs<ExtArgs>>): Prisma__formTransmittalMemoClient<$Result.GetResult<Prisma.$formTransmittalMemoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormTransmittalMemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoCountArgs} args - Arguments to filter FormTransmittalMemos to count.
     * @example
     * // Count the number of FormTransmittalMemos
     * const count = await prisma.formTransmittalMemo.count({
     *   where: {
     *     // ... the filter for the FormTransmittalMemos we want to count
     *   }
     * })
    **/
    count<T extends formTransmittalMemoCountArgs>(
      args?: Subset<T, formTransmittalMemoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTransmittalMemoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTransmittalMemo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTransmittalMemoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTransmittalMemoAggregateArgs>(args: Subset<T, FormTransmittalMemoAggregateArgs>): Prisma.PrismaPromise<GetFormTransmittalMemoAggregateType<T>>

    /**
     * Group by FormTransmittalMemo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formTransmittalMemoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formTransmittalMemoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formTransmittalMemoGroupByArgs['orderBy'] }
        : { orderBy?: formTransmittalMemoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formTransmittalMemoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTransmittalMemoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formTransmittalMemo model
   */
  readonly fields: formTransmittalMemoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formTransmittalMemo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formTransmittalMemoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestTo<T extends formTransmittalMemo$requestToArgs<ExtArgs> = {}>(args?: Subset<T, formTransmittalMemo$requestToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mainForm<T extends formTransmittalMemo$mainFormArgs<ExtArgs> = {}>(args?: Subset<T, formTransmittalMemo$mainFormArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formTransmittalMemo model
   */
  interface formTransmittalMemoFieldRefs {
    readonly id: FieldRef<"formTransmittalMemo", 'Int'>
    readonly from: FieldRef<"formTransmittalMemo", 'String'>
    readonly date: FieldRef<"formTransmittalMemo", 'DateTime'>
    readonly description: FieldRef<"formTransmittalMemo", 'String'>
    readonly note: FieldRef<"formTransmittalMemo", 'String'>
    readonly items: FieldRef<"formTransmittalMemo", 'Json'>
    readonly to_id: FieldRef<"formTransmittalMemo", 'Int'>
    readonly mainFormId: FieldRef<"formTransmittalMemo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * formTransmittalMemo findUnique
   */
  export type formTransmittalMemoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter, which formTransmittalMemo to fetch.
     */
    where: formTransmittalMemoWhereUniqueInput
  }

  /**
   * formTransmittalMemo findUniqueOrThrow
   */
  export type formTransmittalMemoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter, which formTransmittalMemo to fetch.
     */
    where: formTransmittalMemoWhereUniqueInput
  }

  /**
   * formTransmittalMemo findFirst
   */
  export type formTransmittalMemoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter, which formTransmittalMemo to fetch.
     */
    where?: formTransmittalMemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTransmittalMemos to fetch.
     */
    orderBy?: formTransmittalMemoOrderByWithRelationInput | formTransmittalMemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formTransmittalMemos.
     */
    cursor?: formTransmittalMemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTransmittalMemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTransmittalMemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formTransmittalMemos.
     */
    distinct?: FormTransmittalMemoScalarFieldEnum | FormTransmittalMemoScalarFieldEnum[]
  }

  /**
   * formTransmittalMemo findFirstOrThrow
   */
  export type formTransmittalMemoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter, which formTransmittalMemo to fetch.
     */
    where?: formTransmittalMemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTransmittalMemos to fetch.
     */
    orderBy?: formTransmittalMemoOrderByWithRelationInput | formTransmittalMemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formTransmittalMemos.
     */
    cursor?: formTransmittalMemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTransmittalMemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTransmittalMemos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formTransmittalMemos.
     */
    distinct?: FormTransmittalMemoScalarFieldEnum | FormTransmittalMemoScalarFieldEnum[]
  }

  /**
   * formTransmittalMemo findMany
   */
  export type formTransmittalMemoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter, which formTransmittalMemos to fetch.
     */
    where?: formTransmittalMemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formTransmittalMemos to fetch.
     */
    orderBy?: formTransmittalMemoOrderByWithRelationInput | formTransmittalMemoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formTransmittalMemos.
     */
    cursor?: formTransmittalMemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formTransmittalMemos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formTransmittalMemos.
     */
    skip?: number
    distinct?: FormTransmittalMemoScalarFieldEnum | FormTransmittalMemoScalarFieldEnum[]
  }

  /**
   * formTransmittalMemo create
   */
  export type formTransmittalMemoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * The data needed to create a formTransmittalMemo.
     */
    data: XOR<formTransmittalMemoCreateInput, formTransmittalMemoUncheckedCreateInput>
  }

  /**
   * formTransmittalMemo createMany
   */
  export type formTransmittalMemoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formTransmittalMemos.
     */
    data: formTransmittalMemoCreateManyInput | formTransmittalMemoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formTransmittalMemo createManyAndReturn
   */
  export type formTransmittalMemoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * The data used to create many formTransmittalMemos.
     */
    data: formTransmittalMemoCreateManyInput | formTransmittalMemoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * formTransmittalMemo update
   */
  export type formTransmittalMemoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * The data needed to update a formTransmittalMemo.
     */
    data: XOR<formTransmittalMemoUpdateInput, formTransmittalMemoUncheckedUpdateInput>
    /**
     * Choose, which formTransmittalMemo to update.
     */
    where: formTransmittalMemoWhereUniqueInput
  }

  /**
   * formTransmittalMemo updateMany
   */
  export type formTransmittalMemoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formTransmittalMemos.
     */
    data: XOR<formTransmittalMemoUpdateManyMutationInput, formTransmittalMemoUncheckedUpdateManyInput>
    /**
     * Filter which formTransmittalMemos to update
     */
    where?: formTransmittalMemoWhereInput
    /**
     * Limit how many formTransmittalMemos to update.
     */
    limit?: number
  }

  /**
   * formTransmittalMemo updateManyAndReturn
   */
  export type formTransmittalMemoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * The data used to update formTransmittalMemos.
     */
    data: XOR<formTransmittalMemoUpdateManyMutationInput, formTransmittalMemoUncheckedUpdateManyInput>
    /**
     * Filter which formTransmittalMemos to update
     */
    where?: formTransmittalMemoWhereInput
    /**
     * Limit how many formTransmittalMemos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * formTransmittalMemo upsert
   */
  export type formTransmittalMemoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * The filter to search for the formTransmittalMemo to update in case it exists.
     */
    where: formTransmittalMemoWhereUniqueInput
    /**
     * In case the formTransmittalMemo found by the `where` argument doesn't exist, create a new formTransmittalMemo with this data.
     */
    create: XOR<formTransmittalMemoCreateInput, formTransmittalMemoUncheckedCreateInput>
    /**
     * In case the formTransmittalMemo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formTransmittalMemoUpdateInput, formTransmittalMemoUncheckedUpdateInput>
  }

  /**
   * formTransmittalMemo delete
   */
  export type formTransmittalMemoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
    /**
     * Filter which formTransmittalMemo to delete.
     */
    where: formTransmittalMemoWhereUniqueInput
  }

  /**
   * formTransmittalMemo deleteMany
   */
  export type formTransmittalMemoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formTransmittalMemos to delete
     */
    where?: formTransmittalMemoWhereInput
    /**
     * Limit how many formTransmittalMemos to delete.
     */
    limit?: number
  }

  /**
   * formTransmittalMemo.requestTo
   */
  export type formTransmittalMemo$requestToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * formTransmittalMemo.mainForm
   */
  export type formTransmittalMemo$mainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * formTransmittalMemo without action
   */
  export type formTransmittalMemoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formTransmittalMemo
     */
    select?: formTransmittalMemoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formTransmittalMemo
     */
    omit?: formTransmittalMemoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formTransmittalMemoInclude<ExtArgs> | null
  }


  /**
   * Model formDisburse
   */

  export type AggregateFormDisburse = {
    _count: FormDisburseCountAggregateOutputType | null
    _avg: FormDisburseAvgAggregateOutputType | null
    _sum: FormDisburseSumAggregateOutputType | null
    _min: FormDisburseMinAggregateOutputType | null
    _max: FormDisburseMaxAggregateOutputType | null
  }

  export type FormDisburseAvgAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormDisburseSumAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormDisburseMinAggregateOutputType = {
    id: number | null
    from: string | null
    date: Date | null
    subject: string | null
    description: string | null
    note: string | null
    total_amount: Decimal | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormDisburseMaxAggregateOutputType = {
    id: number | null
    from: string | null
    date: Date | null
    subject: string | null
    description: string | null
    note: string | null
    total_amount: Decimal | null
    to_id: number | null
    mainFormId: number | null
  }

  export type FormDisburseCountAggregateOutputType = {
    id: number
    from: number
    date: number
    subject: number
    description: number
    note: number
    total_amount: number
    items: number
    to_id: number
    mainFormId: number
    _all: number
  }


  export type FormDisburseAvgAggregateInputType = {
    id?: true
    total_amount?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormDisburseSumAggregateInputType = {
    id?: true
    total_amount?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormDisburseMinAggregateInputType = {
    id?: true
    from?: true
    date?: true
    subject?: true
    description?: true
    note?: true
    total_amount?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormDisburseMaxAggregateInputType = {
    id?: true
    from?: true
    date?: true
    subject?: true
    description?: true
    note?: true
    total_amount?: true
    to_id?: true
    mainFormId?: true
  }

  export type FormDisburseCountAggregateInputType = {
    id?: true
    from?: true
    date?: true
    subject?: true
    description?: true
    note?: true
    total_amount?: true
    items?: true
    to_id?: true
    mainFormId?: true
    _all?: true
  }

  export type FormDisburseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formDisburse to aggregate.
     */
    where?: formDisburseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formDisburses to fetch.
     */
    orderBy?: formDisburseOrderByWithRelationInput | formDisburseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formDisburseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formDisburses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formDisburses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formDisburses
    **/
    _count?: true | FormDisburseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormDisburseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormDisburseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormDisburseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormDisburseMaxAggregateInputType
  }

  export type GetFormDisburseAggregateType<T extends FormDisburseAggregateArgs> = {
        [P in keyof T & keyof AggregateFormDisburse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormDisburse[P]>
      : GetScalarType<T[P], AggregateFormDisburse[P]>
  }




  export type formDisburseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formDisburseWhereInput
    orderBy?: formDisburseOrderByWithAggregationInput | formDisburseOrderByWithAggregationInput[]
    by: FormDisburseScalarFieldEnum[] | FormDisburseScalarFieldEnum
    having?: formDisburseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormDisburseCountAggregateInputType | true
    _avg?: FormDisburseAvgAggregateInputType
    _sum?: FormDisburseSumAggregateInputType
    _min?: FormDisburseMinAggregateInputType
    _max?: FormDisburseMaxAggregateInputType
  }

  export type FormDisburseGroupByOutputType = {
    id: number
    from: string | null
    date: Date
    subject: string | null
    description: string | null
    note: string | null
    total_amount: Decimal | null
    items: JsonValue | null
    to_id: number | null
    mainFormId: number
    _count: FormDisburseCountAggregateOutputType | null
    _avg: FormDisburseAvgAggregateOutputType | null
    _sum: FormDisburseSumAggregateOutputType | null
    _min: FormDisburseMinAggregateOutputType | null
    _max: FormDisburseMaxAggregateOutputType | null
  }

  type GetFormDisburseGroupByPayload<T extends formDisburseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormDisburseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormDisburseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormDisburseGroupByOutputType[P]>
            : GetScalarType<T[P], FormDisburseGroupByOutputType[P]>
        }
      >
    >


  export type formDisburseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    subject?: boolean
    description?: boolean
    note?: boolean
    total_amount?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formDisburse"]>

  export type formDisburseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    subject?: boolean
    description?: boolean
    note?: boolean
    total_amount?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formDisburse"]>

  export type formDisburseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    date?: boolean
    subject?: boolean
    description?: boolean
    note?: boolean
    total_amount?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }, ExtArgs["result"]["formDisburse"]>

  export type formDisburseSelectScalar = {
    id?: boolean
    from?: boolean
    date?: boolean
    subject?: boolean
    description?: boolean
    note?: boolean
    total_amount?: boolean
    items?: boolean
    to_id?: boolean
    mainFormId?: boolean
  }

  export type formDisburseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from" | "date" | "subject" | "description" | "note" | "total_amount" | "items" | "to_id" | "mainFormId", ExtArgs["result"]["formDisburse"]>
  export type formDisburseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }
  export type formDisburseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }
  export type formDisburseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestTo?: boolean | formDisburse$requestToArgs<ExtArgs>
    mainForm?: boolean | formDisburse$mainFormArgs<ExtArgs>
  }

  export type $formDisbursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formDisburse"
    objects: {
      requestTo: Prisma.$UserPayload<ExtArgs> | null
      mainForm: Prisma.$MainRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      from: string | null
      date: Date
      subject: string | null
      description: string | null
      note: string | null
      total_amount: Prisma.Decimal | null
      items: Prisma.JsonValue | null
      to_id: number | null
      mainFormId: number
    }, ExtArgs["result"]["formDisburse"]>
    composites: {}
  }

  type formDisburseGetPayload<S extends boolean | null | undefined | formDisburseDefaultArgs> = $Result.GetResult<Prisma.$formDisbursePayload, S>

  type formDisburseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formDisburseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormDisburseCountAggregateInputType | true
    }

  export interface formDisburseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formDisburse'], meta: { name: 'formDisburse' } }
    /**
     * Find zero or one FormDisburse that matches the filter.
     * @param {formDisburseFindUniqueArgs} args - Arguments to find a FormDisburse
     * @example
     * // Get one FormDisburse
     * const formDisburse = await prisma.formDisburse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formDisburseFindUniqueArgs>(args: SelectSubset<T, formDisburseFindUniqueArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormDisburse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formDisburseFindUniqueOrThrowArgs} args - Arguments to find a FormDisburse
     * @example
     * // Get one FormDisburse
     * const formDisburse = await prisma.formDisburse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formDisburseFindUniqueOrThrowArgs>(args: SelectSubset<T, formDisburseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormDisburse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseFindFirstArgs} args - Arguments to find a FormDisburse
     * @example
     * // Get one FormDisburse
     * const formDisburse = await prisma.formDisburse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formDisburseFindFirstArgs>(args?: SelectSubset<T, formDisburseFindFirstArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormDisburse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseFindFirstOrThrowArgs} args - Arguments to find a FormDisburse
     * @example
     * // Get one FormDisburse
     * const formDisburse = await prisma.formDisburse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formDisburseFindFirstOrThrowArgs>(args?: SelectSubset<T, formDisburseFindFirstOrThrowArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormDisburses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormDisburses
     * const formDisburses = await prisma.formDisburse.findMany()
     * 
     * // Get first 10 FormDisburses
     * const formDisburses = await prisma.formDisburse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formDisburseWithIdOnly = await prisma.formDisburse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formDisburseFindManyArgs>(args?: SelectSubset<T, formDisburseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormDisburse.
     * @param {formDisburseCreateArgs} args - Arguments to create a FormDisburse.
     * @example
     * // Create one FormDisburse
     * const FormDisburse = await prisma.formDisburse.create({
     *   data: {
     *     // ... data to create a FormDisburse
     *   }
     * })
     * 
     */
    create<T extends formDisburseCreateArgs>(args: SelectSubset<T, formDisburseCreateArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormDisburses.
     * @param {formDisburseCreateManyArgs} args - Arguments to create many FormDisburses.
     * @example
     * // Create many FormDisburses
     * const formDisburse = await prisma.formDisburse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formDisburseCreateManyArgs>(args?: SelectSubset<T, formDisburseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormDisburses and returns the data saved in the database.
     * @param {formDisburseCreateManyAndReturnArgs} args - Arguments to create many FormDisburses.
     * @example
     * // Create many FormDisburses
     * const formDisburse = await prisma.formDisburse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormDisburses and only return the `id`
     * const formDisburseWithIdOnly = await prisma.formDisburse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends formDisburseCreateManyAndReturnArgs>(args?: SelectSubset<T, formDisburseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormDisburse.
     * @param {formDisburseDeleteArgs} args - Arguments to delete one FormDisburse.
     * @example
     * // Delete one FormDisburse
     * const FormDisburse = await prisma.formDisburse.delete({
     *   where: {
     *     // ... filter to delete one FormDisburse
     *   }
     * })
     * 
     */
    delete<T extends formDisburseDeleteArgs>(args: SelectSubset<T, formDisburseDeleteArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormDisburse.
     * @param {formDisburseUpdateArgs} args - Arguments to update one FormDisburse.
     * @example
     * // Update one FormDisburse
     * const formDisburse = await prisma.formDisburse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formDisburseUpdateArgs>(args: SelectSubset<T, formDisburseUpdateArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormDisburses.
     * @param {formDisburseDeleteManyArgs} args - Arguments to filter FormDisburses to delete.
     * @example
     * // Delete a few FormDisburses
     * const { count } = await prisma.formDisburse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formDisburseDeleteManyArgs>(args?: SelectSubset<T, formDisburseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormDisburses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormDisburses
     * const formDisburse = await prisma.formDisburse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formDisburseUpdateManyArgs>(args: SelectSubset<T, formDisburseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormDisburses and returns the data updated in the database.
     * @param {formDisburseUpdateManyAndReturnArgs} args - Arguments to update many FormDisburses.
     * @example
     * // Update many FormDisburses
     * const formDisburse = await prisma.formDisburse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormDisburses and only return the `id`
     * const formDisburseWithIdOnly = await prisma.formDisburse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends formDisburseUpdateManyAndReturnArgs>(args: SelectSubset<T, formDisburseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormDisburse.
     * @param {formDisburseUpsertArgs} args - Arguments to update or create a FormDisburse.
     * @example
     * // Update or create a FormDisburse
     * const formDisburse = await prisma.formDisburse.upsert({
     *   create: {
     *     // ... data to create a FormDisburse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormDisburse we want to update
     *   }
     * })
     */
    upsert<T extends formDisburseUpsertArgs>(args: SelectSubset<T, formDisburseUpsertArgs<ExtArgs>>): Prisma__formDisburseClient<$Result.GetResult<Prisma.$formDisbursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormDisburses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseCountArgs} args - Arguments to filter FormDisburses to count.
     * @example
     * // Count the number of FormDisburses
     * const count = await prisma.formDisburse.count({
     *   where: {
     *     // ... the filter for the FormDisburses we want to count
     *   }
     * })
    **/
    count<T extends formDisburseCountArgs>(
      args?: Subset<T, formDisburseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormDisburseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormDisburse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDisburseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormDisburseAggregateArgs>(args: Subset<T, FormDisburseAggregateArgs>): Prisma.PrismaPromise<GetFormDisburseAggregateType<T>>

    /**
     * Group by FormDisburse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formDisburseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formDisburseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formDisburseGroupByArgs['orderBy'] }
        : { orderBy?: formDisburseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formDisburseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormDisburseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formDisburse model
   */
  readonly fields: formDisburseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formDisburse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formDisburseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestTo<T extends formDisburse$requestToArgs<ExtArgs> = {}>(args?: Subset<T, formDisburse$requestToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mainForm<T extends formDisburse$mainFormArgs<ExtArgs> = {}>(args?: Subset<T, formDisburse$mainFormArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formDisburse model
   */
  interface formDisburseFieldRefs {
    readonly id: FieldRef<"formDisburse", 'Int'>
    readonly from: FieldRef<"formDisburse", 'String'>
    readonly date: FieldRef<"formDisburse", 'DateTime'>
    readonly subject: FieldRef<"formDisburse", 'String'>
    readonly description: FieldRef<"formDisburse", 'String'>
    readonly note: FieldRef<"formDisburse", 'String'>
    readonly total_amount: FieldRef<"formDisburse", 'Decimal'>
    readonly items: FieldRef<"formDisburse", 'Json'>
    readonly to_id: FieldRef<"formDisburse", 'Int'>
    readonly mainFormId: FieldRef<"formDisburse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * formDisburse findUnique
   */
  export type formDisburseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter, which formDisburse to fetch.
     */
    where: formDisburseWhereUniqueInput
  }

  /**
   * formDisburse findUniqueOrThrow
   */
  export type formDisburseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter, which formDisburse to fetch.
     */
    where: formDisburseWhereUniqueInput
  }

  /**
   * formDisburse findFirst
   */
  export type formDisburseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter, which formDisburse to fetch.
     */
    where?: formDisburseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formDisburses to fetch.
     */
    orderBy?: formDisburseOrderByWithRelationInput | formDisburseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formDisburses.
     */
    cursor?: formDisburseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formDisburses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formDisburses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formDisburses.
     */
    distinct?: FormDisburseScalarFieldEnum | FormDisburseScalarFieldEnum[]
  }

  /**
   * formDisburse findFirstOrThrow
   */
  export type formDisburseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter, which formDisburse to fetch.
     */
    where?: formDisburseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formDisburses to fetch.
     */
    orderBy?: formDisburseOrderByWithRelationInput | formDisburseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formDisburses.
     */
    cursor?: formDisburseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formDisburses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formDisburses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formDisburses.
     */
    distinct?: FormDisburseScalarFieldEnum | FormDisburseScalarFieldEnum[]
  }

  /**
   * formDisburse findMany
   */
  export type formDisburseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter, which formDisburses to fetch.
     */
    where?: formDisburseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formDisburses to fetch.
     */
    orderBy?: formDisburseOrderByWithRelationInput | formDisburseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formDisburses.
     */
    cursor?: formDisburseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formDisburses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formDisburses.
     */
    skip?: number
    distinct?: FormDisburseScalarFieldEnum | FormDisburseScalarFieldEnum[]
  }

  /**
   * formDisburse create
   */
  export type formDisburseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * The data needed to create a formDisburse.
     */
    data: XOR<formDisburseCreateInput, formDisburseUncheckedCreateInput>
  }

  /**
   * formDisburse createMany
   */
  export type formDisburseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formDisburses.
     */
    data: formDisburseCreateManyInput | formDisburseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formDisburse createManyAndReturn
   */
  export type formDisburseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * The data used to create many formDisburses.
     */
    data: formDisburseCreateManyInput | formDisburseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * formDisburse update
   */
  export type formDisburseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * The data needed to update a formDisburse.
     */
    data: XOR<formDisburseUpdateInput, formDisburseUncheckedUpdateInput>
    /**
     * Choose, which formDisburse to update.
     */
    where: formDisburseWhereUniqueInput
  }

  /**
   * formDisburse updateMany
   */
  export type formDisburseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formDisburses.
     */
    data: XOR<formDisburseUpdateManyMutationInput, formDisburseUncheckedUpdateManyInput>
    /**
     * Filter which formDisburses to update
     */
    where?: formDisburseWhereInput
    /**
     * Limit how many formDisburses to update.
     */
    limit?: number
  }

  /**
   * formDisburse updateManyAndReturn
   */
  export type formDisburseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * The data used to update formDisburses.
     */
    data: XOR<formDisburseUpdateManyMutationInput, formDisburseUncheckedUpdateManyInput>
    /**
     * Filter which formDisburses to update
     */
    where?: formDisburseWhereInput
    /**
     * Limit how many formDisburses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * formDisburse upsert
   */
  export type formDisburseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * The filter to search for the formDisburse to update in case it exists.
     */
    where: formDisburseWhereUniqueInput
    /**
     * In case the formDisburse found by the `where` argument doesn't exist, create a new formDisburse with this data.
     */
    create: XOR<formDisburseCreateInput, formDisburseUncheckedCreateInput>
    /**
     * In case the formDisburse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formDisburseUpdateInput, formDisburseUncheckedUpdateInput>
  }

  /**
   * formDisburse delete
   */
  export type formDisburseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
    /**
     * Filter which formDisburse to delete.
     */
    where: formDisburseWhereUniqueInput
  }

  /**
   * formDisburse deleteMany
   */
  export type formDisburseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formDisburses to delete
     */
    where?: formDisburseWhereInput
    /**
     * Limit how many formDisburses to delete.
     */
    limit?: number
  }

  /**
   * formDisburse.requestTo
   */
  export type formDisburse$requestToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * formDisburse.mainForm
   */
  export type formDisburse$mainFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * formDisburse without action
   */
  export type formDisburseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formDisburse
     */
    select?: formDisburseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formDisburse
     */
    omit?: formDisburseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formDisburseInclude<ExtArgs> | null
  }


  /**
   * Model CountSheet
   */

  export type AggregateCountSheet = {
    _count: CountSheetCountAggregateOutputType | null
    _avg: CountSheetAvgAggregateOutputType | null
    _sum: CountSheetSumAggregateOutputType | null
    _min: CountSheetMinAggregateOutputType | null
    _max: CountSheetMaxAggregateOutputType | null
  }

  export type CountSheetAvgAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    fundAmount: Decimal | null
    repFund: Decimal | null
    totalFund: Decimal | null
    cashShort: Decimal | null
  }

  export type CountSheetSumAggregateOutputType = {
    id: number | null
    mainFormId: number | null
    fundAmount: Decimal | null
    repFund: Decimal | null
    totalFund: Decimal | null
    cashShort: Decimal | null
  }

  export type CountSheetMinAggregateOutputType = {
    id: number | null
    fundType: string | null
    mainFormId: number | null
    office: string | null
    dateCount: Date | null
    fundName: string | null
    fundAmount: Decimal | null
    reference: string | null
    repFund: Decimal | null
    totalFund: Decimal | null
    cashShort: Decimal | null
  }

  export type CountSheetMaxAggregateOutputType = {
    id: number | null
    fundType: string | null
    mainFormId: number | null
    office: string | null
    dateCount: Date | null
    fundName: string | null
    fundAmount: Decimal | null
    reference: string | null
    repFund: Decimal | null
    totalFund: Decimal | null
    cashShort: Decimal | null
  }

  export type CountSheetCountAggregateOutputType = {
    id: number
    fundType: number
    mainFormId: number
    office: number
    dateCount: number
    fundName: number
    fundAmount: number
    reference: number
    cashDemo: number
    repFund: number
    totalFund: number
    cashShort: number
    _all: number
  }


  export type CountSheetAvgAggregateInputType = {
    id?: true
    mainFormId?: true
    fundAmount?: true
    repFund?: true
    totalFund?: true
    cashShort?: true
  }

  export type CountSheetSumAggregateInputType = {
    id?: true
    mainFormId?: true
    fundAmount?: true
    repFund?: true
    totalFund?: true
    cashShort?: true
  }

  export type CountSheetMinAggregateInputType = {
    id?: true
    fundType?: true
    mainFormId?: true
    office?: true
    dateCount?: true
    fundName?: true
    fundAmount?: true
    reference?: true
    repFund?: true
    totalFund?: true
    cashShort?: true
  }

  export type CountSheetMaxAggregateInputType = {
    id?: true
    fundType?: true
    mainFormId?: true
    office?: true
    dateCount?: true
    fundName?: true
    fundAmount?: true
    reference?: true
    repFund?: true
    totalFund?: true
    cashShort?: true
  }

  export type CountSheetCountAggregateInputType = {
    id?: true
    fundType?: true
    mainFormId?: true
    office?: true
    dateCount?: true
    fundName?: true
    fundAmount?: true
    reference?: true
    cashDemo?: true
    repFund?: true
    totalFund?: true
    cashShort?: true
    _all?: true
  }

  export type CountSheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountSheet to aggregate.
     */
    where?: CountSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountSheets to fetch.
     */
    orderBy?: CountSheetOrderByWithRelationInput | CountSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountSheets
    **/
    _count?: true | CountSheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountSheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountSheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountSheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountSheetMaxAggregateInputType
  }

  export type GetCountSheetAggregateType<T extends CountSheetAggregateArgs> = {
        [P in keyof T & keyof AggregateCountSheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountSheet[P]>
      : GetScalarType<T[P], AggregateCountSheet[P]>
  }




  export type CountSheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountSheetWhereInput
    orderBy?: CountSheetOrderByWithAggregationInput | CountSheetOrderByWithAggregationInput[]
    by: CountSheetScalarFieldEnum[] | CountSheetScalarFieldEnum
    having?: CountSheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountSheetCountAggregateInputType | true
    _avg?: CountSheetAvgAggregateInputType
    _sum?: CountSheetSumAggregateInputType
    _min?: CountSheetMinAggregateInputType
    _max?: CountSheetMaxAggregateInputType
  }

  export type CountSheetGroupByOutputType = {
    id: number
    fundType: string
    mainFormId: number | null
    office: string
    dateCount: Date
    fundName: string
    fundAmount: Decimal
    reference: string | null
    cashDemo: JsonValue | null
    repFund: Decimal
    totalFund: Decimal
    cashShort: Decimal | null
    _count: CountSheetCountAggregateOutputType | null
    _avg: CountSheetAvgAggregateOutputType | null
    _sum: CountSheetSumAggregateOutputType | null
    _min: CountSheetMinAggregateOutputType | null
    _max: CountSheetMaxAggregateOutputType | null
  }

  type GetCountSheetGroupByPayload<T extends CountSheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountSheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountSheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountSheetGroupByOutputType[P]>
            : GetScalarType<T[P], CountSheetGroupByOutputType[P]>
        }
      >
    >


  export type CountSheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundType?: boolean
    mainFormId?: boolean
    office?: boolean
    dateCount?: boolean
    fundName?: boolean
    fundAmount?: boolean
    reference?: boolean
    cashDemo?: boolean
    repFund?: boolean
    totalFund?: boolean
    cashShort?: boolean
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
    CashCountSheet?: boolean | CountSheet$CashCountSheetArgs<ExtArgs>
    TravelCountSheet?: boolean | CountSheet$TravelCountSheetArgs<ExtArgs>
    _count?: boolean | CountSheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countSheet"]>

  export type CountSheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundType?: boolean
    mainFormId?: boolean
    office?: boolean
    dateCount?: boolean
    fundName?: boolean
    fundAmount?: boolean
    reference?: boolean
    cashDemo?: boolean
    repFund?: boolean
    totalFund?: boolean
    cashShort?: boolean
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
  }, ExtArgs["result"]["countSheet"]>

  export type CountSheetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fundType?: boolean
    mainFormId?: boolean
    office?: boolean
    dateCount?: boolean
    fundName?: boolean
    fundAmount?: boolean
    reference?: boolean
    cashDemo?: boolean
    repFund?: boolean
    totalFund?: boolean
    cashShort?: boolean
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
  }, ExtArgs["result"]["countSheet"]>

  export type CountSheetSelectScalar = {
    id?: boolean
    fundType?: boolean
    mainFormId?: boolean
    office?: boolean
    dateCount?: boolean
    fundName?: boolean
    fundAmount?: boolean
    reference?: boolean
    cashDemo?: boolean
    repFund?: boolean
    totalFund?: boolean
    cashShort?: boolean
  }

  export type CountSheetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fundType" | "mainFormId" | "office" | "dateCount" | "fundName" | "fundAmount" | "reference" | "cashDemo" | "repFund" | "totalFund" | "cashShort", ExtArgs["result"]["countSheet"]>
  export type CountSheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
    CashCountSheet?: boolean | CountSheet$CashCountSheetArgs<ExtArgs>
    TravelCountSheet?: boolean | CountSheet$TravelCountSheetArgs<ExtArgs>
    _count?: boolean | CountSheetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountSheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
  }
  export type CountSheetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaincountSheet?: boolean | CountSheet$MaincountSheetArgs<ExtArgs>
  }

  export type $CountSheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountSheet"
    objects: {
      MaincountSheet: Prisma.$MainRequestPayload<ExtArgs> | null
      CashCountSheet: Prisma.$CashFundPayload<ExtArgs>[]
      TravelCountSheet: Prisma.$TravelFundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fundType: string
      mainFormId: number | null
      office: string
      dateCount: Date
      fundName: string
      fundAmount: Prisma.Decimal
      reference: string | null
      cashDemo: Prisma.JsonValue | null
      repFund: Prisma.Decimal
      totalFund: Prisma.Decimal
      cashShort: Prisma.Decimal | null
    }, ExtArgs["result"]["countSheet"]>
    composites: {}
  }

  type CountSheetGetPayload<S extends boolean | null | undefined | CountSheetDefaultArgs> = $Result.GetResult<Prisma.$CountSheetPayload, S>

  type CountSheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountSheetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountSheetCountAggregateInputType | true
    }

  export interface CountSheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountSheet'], meta: { name: 'CountSheet' } }
    /**
     * Find zero or one CountSheet that matches the filter.
     * @param {CountSheetFindUniqueArgs} args - Arguments to find a CountSheet
     * @example
     * // Get one CountSheet
     * const countSheet = await prisma.countSheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountSheetFindUniqueArgs>(args: SelectSubset<T, CountSheetFindUniqueArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountSheet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountSheetFindUniqueOrThrowArgs} args - Arguments to find a CountSheet
     * @example
     * // Get one CountSheet
     * const countSheet = await prisma.countSheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountSheetFindUniqueOrThrowArgs>(args: SelectSubset<T, CountSheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountSheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetFindFirstArgs} args - Arguments to find a CountSheet
     * @example
     * // Get one CountSheet
     * const countSheet = await prisma.countSheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountSheetFindFirstArgs>(args?: SelectSubset<T, CountSheetFindFirstArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountSheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetFindFirstOrThrowArgs} args - Arguments to find a CountSheet
     * @example
     * // Get one CountSheet
     * const countSheet = await prisma.countSheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountSheetFindFirstOrThrowArgs>(args?: SelectSubset<T, CountSheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountSheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountSheets
     * const countSheets = await prisma.countSheet.findMany()
     * 
     * // Get first 10 CountSheets
     * const countSheets = await prisma.countSheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countSheetWithIdOnly = await prisma.countSheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountSheetFindManyArgs>(args?: SelectSubset<T, CountSheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountSheet.
     * @param {CountSheetCreateArgs} args - Arguments to create a CountSheet.
     * @example
     * // Create one CountSheet
     * const CountSheet = await prisma.countSheet.create({
     *   data: {
     *     // ... data to create a CountSheet
     *   }
     * })
     * 
     */
    create<T extends CountSheetCreateArgs>(args: SelectSubset<T, CountSheetCreateArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountSheets.
     * @param {CountSheetCreateManyArgs} args - Arguments to create many CountSheets.
     * @example
     * // Create many CountSheets
     * const countSheet = await prisma.countSheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountSheetCreateManyArgs>(args?: SelectSubset<T, CountSheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountSheets and returns the data saved in the database.
     * @param {CountSheetCreateManyAndReturnArgs} args - Arguments to create many CountSheets.
     * @example
     * // Create many CountSheets
     * const countSheet = await prisma.countSheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountSheets and only return the `id`
     * const countSheetWithIdOnly = await prisma.countSheet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountSheetCreateManyAndReturnArgs>(args?: SelectSubset<T, CountSheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountSheet.
     * @param {CountSheetDeleteArgs} args - Arguments to delete one CountSheet.
     * @example
     * // Delete one CountSheet
     * const CountSheet = await prisma.countSheet.delete({
     *   where: {
     *     // ... filter to delete one CountSheet
     *   }
     * })
     * 
     */
    delete<T extends CountSheetDeleteArgs>(args: SelectSubset<T, CountSheetDeleteArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountSheet.
     * @param {CountSheetUpdateArgs} args - Arguments to update one CountSheet.
     * @example
     * // Update one CountSheet
     * const countSheet = await prisma.countSheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountSheetUpdateArgs>(args: SelectSubset<T, CountSheetUpdateArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountSheets.
     * @param {CountSheetDeleteManyArgs} args - Arguments to filter CountSheets to delete.
     * @example
     * // Delete a few CountSheets
     * const { count } = await prisma.countSheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountSheetDeleteManyArgs>(args?: SelectSubset<T, CountSheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountSheets
     * const countSheet = await prisma.countSheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountSheetUpdateManyArgs>(args: SelectSubset<T, CountSheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountSheets and returns the data updated in the database.
     * @param {CountSheetUpdateManyAndReturnArgs} args - Arguments to update many CountSheets.
     * @example
     * // Update many CountSheets
     * const countSheet = await prisma.countSheet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountSheets and only return the `id`
     * const countSheetWithIdOnly = await prisma.countSheet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountSheetUpdateManyAndReturnArgs>(args: SelectSubset<T, CountSheetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountSheet.
     * @param {CountSheetUpsertArgs} args - Arguments to update or create a CountSheet.
     * @example
     * // Update or create a CountSheet
     * const countSheet = await prisma.countSheet.upsert({
     *   create: {
     *     // ... data to create a CountSheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountSheet we want to update
     *   }
     * })
     */
    upsert<T extends CountSheetUpsertArgs>(args: SelectSubset<T, CountSheetUpsertArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetCountArgs} args - Arguments to filter CountSheets to count.
     * @example
     * // Count the number of CountSheets
     * const count = await prisma.countSheet.count({
     *   where: {
     *     // ... the filter for the CountSheets we want to count
     *   }
     * })
    **/
    count<T extends CountSheetCountArgs>(
      args?: Subset<T, CountSheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountSheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountSheetAggregateArgs>(args: Subset<T, CountSheetAggregateArgs>): Prisma.PrismaPromise<GetCountSheetAggregateType<T>>

    /**
     * Group by CountSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountSheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountSheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountSheetGroupByArgs['orderBy'] }
        : { orderBy?: CountSheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountSheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountSheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountSheet model
   */
  readonly fields: CountSheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountSheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountSheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaincountSheet<T extends CountSheet$MaincountSheetArgs<ExtArgs> = {}>(args?: Subset<T, CountSheet$MaincountSheetArgs<ExtArgs>>): Prisma__MainRequestClient<$Result.GetResult<Prisma.$MainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CashCountSheet<T extends CountSheet$CashCountSheetArgs<ExtArgs> = {}>(args?: Subset<T, CountSheet$CashCountSheetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TravelCountSheet<T extends CountSheet$TravelCountSheetArgs<ExtArgs> = {}>(args?: Subset<T, CountSheet$TravelCountSheetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountSheet model
   */
  interface CountSheetFieldRefs {
    readonly id: FieldRef<"CountSheet", 'Int'>
    readonly fundType: FieldRef<"CountSheet", 'String'>
    readonly mainFormId: FieldRef<"CountSheet", 'Int'>
    readonly office: FieldRef<"CountSheet", 'String'>
    readonly dateCount: FieldRef<"CountSheet", 'DateTime'>
    readonly fundName: FieldRef<"CountSheet", 'String'>
    readonly fundAmount: FieldRef<"CountSheet", 'Decimal'>
    readonly reference: FieldRef<"CountSheet", 'String'>
    readonly cashDemo: FieldRef<"CountSheet", 'Json'>
    readonly repFund: FieldRef<"CountSheet", 'Decimal'>
    readonly totalFund: FieldRef<"CountSheet", 'Decimal'>
    readonly cashShort: FieldRef<"CountSheet", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CountSheet findUnique
   */
  export type CountSheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter, which CountSheet to fetch.
     */
    where: CountSheetWhereUniqueInput
  }

  /**
   * CountSheet findUniqueOrThrow
   */
  export type CountSheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter, which CountSheet to fetch.
     */
    where: CountSheetWhereUniqueInput
  }

  /**
   * CountSheet findFirst
   */
  export type CountSheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter, which CountSheet to fetch.
     */
    where?: CountSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountSheets to fetch.
     */
    orderBy?: CountSheetOrderByWithRelationInput | CountSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountSheets.
     */
    cursor?: CountSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountSheets.
     */
    distinct?: CountSheetScalarFieldEnum | CountSheetScalarFieldEnum[]
  }

  /**
   * CountSheet findFirstOrThrow
   */
  export type CountSheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter, which CountSheet to fetch.
     */
    where?: CountSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountSheets to fetch.
     */
    orderBy?: CountSheetOrderByWithRelationInput | CountSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountSheets.
     */
    cursor?: CountSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountSheets.
     */
    distinct?: CountSheetScalarFieldEnum | CountSheetScalarFieldEnum[]
  }

  /**
   * CountSheet findMany
   */
  export type CountSheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter, which CountSheets to fetch.
     */
    where?: CountSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountSheets to fetch.
     */
    orderBy?: CountSheetOrderByWithRelationInput | CountSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountSheets.
     */
    cursor?: CountSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountSheets.
     */
    skip?: number
    distinct?: CountSheetScalarFieldEnum | CountSheetScalarFieldEnum[]
  }

  /**
   * CountSheet create
   */
  export type CountSheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * The data needed to create a CountSheet.
     */
    data: XOR<CountSheetCreateInput, CountSheetUncheckedCreateInput>
  }

  /**
   * CountSheet createMany
   */
  export type CountSheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountSheets.
     */
    data: CountSheetCreateManyInput | CountSheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountSheet createManyAndReturn
   */
  export type CountSheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * The data used to create many CountSheets.
     */
    data: CountSheetCreateManyInput | CountSheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountSheet update
   */
  export type CountSheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * The data needed to update a CountSheet.
     */
    data: XOR<CountSheetUpdateInput, CountSheetUncheckedUpdateInput>
    /**
     * Choose, which CountSheet to update.
     */
    where: CountSheetWhereUniqueInput
  }

  /**
   * CountSheet updateMany
   */
  export type CountSheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountSheets.
     */
    data: XOR<CountSheetUpdateManyMutationInput, CountSheetUncheckedUpdateManyInput>
    /**
     * Filter which CountSheets to update
     */
    where?: CountSheetWhereInput
    /**
     * Limit how many CountSheets to update.
     */
    limit?: number
  }

  /**
   * CountSheet updateManyAndReturn
   */
  export type CountSheetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * The data used to update CountSheets.
     */
    data: XOR<CountSheetUpdateManyMutationInput, CountSheetUncheckedUpdateManyInput>
    /**
     * Filter which CountSheets to update
     */
    where?: CountSheetWhereInput
    /**
     * Limit how many CountSheets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountSheet upsert
   */
  export type CountSheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * The filter to search for the CountSheet to update in case it exists.
     */
    where: CountSheetWhereUniqueInput
    /**
     * In case the CountSheet found by the `where` argument doesn't exist, create a new CountSheet with this data.
     */
    create: XOR<CountSheetCreateInput, CountSheetUncheckedCreateInput>
    /**
     * In case the CountSheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountSheetUpdateInput, CountSheetUncheckedUpdateInput>
  }

  /**
   * CountSheet delete
   */
  export type CountSheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    /**
     * Filter which CountSheet to delete.
     */
    where: CountSheetWhereUniqueInput
  }

  /**
   * CountSheet deleteMany
   */
  export type CountSheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountSheets to delete
     */
    where?: CountSheetWhereInput
    /**
     * Limit how many CountSheets to delete.
     */
    limit?: number
  }

  /**
   * CountSheet.MaincountSheet
   */
  export type CountSheet$MaincountSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MainRequest
     */
    select?: MainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MainRequest
     */
    omit?: MainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MainRequestInclude<ExtArgs> | null
    where?: MainRequestWhereInput
  }

  /**
   * CountSheet.CashCountSheet
   */
  export type CountSheet$CashCountSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    where?: CashFundWhereInput
    orderBy?: CashFundOrderByWithRelationInput | CashFundOrderByWithRelationInput[]
    cursor?: CashFundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashFundScalarFieldEnum | CashFundScalarFieldEnum[]
  }

  /**
   * CountSheet.TravelCountSheet
   */
  export type CountSheet$TravelCountSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    where?: TravelFundWhereInput
    orderBy?: TravelFundOrderByWithRelationInput | TravelFundOrderByWithRelationInput[]
    cursor?: TravelFundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TravelFundScalarFieldEnum | TravelFundScalarFieldEnum[]
  }

  /**
   * CountSheet without action
   */
  export type CountSheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
  }


  /**
   * Model CashFund
   */

  export type AggregateCashFund = {
    _count: CashFundCountAggregateOutputType | null
    _avg: CashFundAvgAggregateOutputType | null
    _sum: CashFundSumAggregateOutputType | null
    _min: CashFundMinAggregateOutputType | null
    _max: CashFundMaxAggregateOutputType | null
  }

  export type CashFundAvgAggregateOutputType = {
    id: number | null
    countId: number | null
    fundAmount: Decimal | null
    miscExp: Decimal | null
    billFee: Decimal | null
    telFee: Decimal | null
    dueMh: Decimal | null
  }

  export type CashFundSumAggregateOutputType = {
    id: number | null
    countId: number | null
    fundAmount: Decimal | null
    miscExp: Decimal | null
    billFee: Decimal | null
    telFee: Decimal | null
    dueMh: Decimal | null
  }

  export type CashFundMinAggregateOutputType = {
    id: number | null
    countId: number | null
    startDate: Date | null
    endDate: Date | null
    reqDate: Date | null
    payee: string | null
    remarks: string | null
    fundAmount: Decimal | null
    miscExp: Decimal | null
    billFee: Decimal | null
    telFee: Decimal | null
    dueMh: Decimal | null
  }

  export type CashFundMaxAggregateOutputType = {
    id: number | null
    countId: number | null
    startDate: Date | null
    endDate: Date | null
    reqDate: Date | null
    payee: string | null
    remarks: string | null
    fundAmount: Decimal | null
    miscExp: Decimal | null
    billFee: Decimal | null
    telFee: Decimal | null
    dueMh: Decimal | null
  }

  export type CashFundCountAggregateOutputType = {
    id: number
    countId: number
    startDate: number
    endDate: number
    reqDate: number
    payee: number
    remarks: number
    fundAmount: number
    miscExp: number
    billFee: number
    telFee: number
    dueMh: number
    _all: number
  }


  export type CashFundAvgAggregateInputType = {
    id?: true
    countId?: true
    fundAmount?: true
    miscExp?: true
    billFee?: true
    telFee?: true
    dueMh?: true
  }

  export type CashFundSumAggregateInputType = {
    id?: true
    countId?: true
    fundAmount?: true
    miscExp?: true
    billFee?: true
    telFee?: true
    dueMh?: true
  }

  export type CashFundMinAggregateInputType = {
    id?: true
    countId?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    payee?: true
    remarks?: true
    fundAmount?: true
    miscExp?: true
    billFee?: true
    telFee?: true
    dueMh?: true
  }

  export type CashFundMaxAggregateInputType = {
    id?: true
    countId?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    payee?: true
    remarks?: true
    fundAmount?: true
    miscExp?: true
    billFee?: true
    telFee?: true
    dueMh?: true
  }

  export type CashFundCountAggregateInputType = {
    id?: true
    countId?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    payee?: true
    remarks?: true
    fundAmount?: true
    miscExp?: true
    billFee?: true
    telFee?: true
    dueMh?: true
    _all?: true
  }

  export type CashFundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFund to aggregate.
     */
    where?: CashFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFunds to fetch.
     */
    orderBy?: CashFundOrderByWithRelationInput | CashFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashFunds
    **/
    _count?: true | CashFundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashFundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashFundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashFundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashFundMaxAggregateInputType
  }

  export type GetCashFundAggregateType<T extends CashFundAggregateArgs> = {
        [P in keyof T & keyof AggregateCashFund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashFund[P]>
      : GetScalarType<T[P], AggregateCashFund[P]>
  }




  export type CashFundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFundWhereInput
    orderBy?: CashFundOrderByWithAggregationInput | CashFundOrderByWithAggregationInput[]
    by: CashFundScalarFieldEnum[] | CashFundScalarFieldEnum
    having?: CashFundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashFundCountAggregateInputType | true
    _avg?: CashFundAvgAggregateInputType
    _sum?: CashFundSumAggregateInputType
    _min?: CashFundMinAggregateInputType
    _max?: CashFundMaxAggregateInputType
  }

  export type CashFundGroupByOutputType = {
    id: number
    countId: number | null
    startDate: Date
    endDate: Date
    reqDate: Date
    payee: string
    remarks: string | null
    fundAmount: Decimal
    miscExp: Decimal | null
    billFee: Decimal | null
    telFee: Decimal | null
    dueMh: Decimal | null
    _count: CashFundCountAggregateOutputType | null
    _avg: CashFundAvgAggregateOutputType | null
    _sum: CashFundSumAggregateOutputType | null
    _min: CashFundMinAggregateOutputType | null
    _max: CashFundMaxAggregateOutputType | null
  }

  type GetCashFundGroupByPayload<T extends CashFundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashFundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashFundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashFundGroupByOutputType[P]>
            : GetScalarType<T[P], CashFundGroupByOutputType[P]>
        }
      >
    >


  export type CashFundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    payee?: boolean
    remarks?: boolean
    fundAmount?: boolean
    miscExp?: boolean
    billFee?: boolean
    telFee?: boolean
    dueMh?: boolean
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }, ExtArgs["result"]["cashFund"]>

  export type CashFundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    payee?: boolean
    remarks?: boolean
    fundAmount?: boolean
    miscExp?: boolean
    billFee?: boolean
    telFee?: boolean
    dueMh?: boolean
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }, ExtArgs["result"]["cashFund"]>

  export type CashFundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    payee?: boolean
    remarks?: boolean
    fundAmount?: boolean
    miscExp?: boolean
    billFee?: boolean
    telFee?: boolean
    dueMh?: boolean
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }, ExtArgs["result"]["cashFund"]>

  export type CashFundSelectScalar = {
    id?: boolean
    countId?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    payee?: boolean
    remarks?: boolean
    fundAmount?: boolean
    miscExp?: boolean
    billFee?: boolean
    telFee?: boolean
    dueMh?: boolean
  }

  export type CashFundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countId" | "startDate" | "endDate" | "reqDate" | "payee" | "remarks" | "fundAmount" | "miscExp" | "billFee" | "telFee" | "dueMh", ExtArgs["result"]["cashFund"]>
  export type CashFundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }
  export type CashFundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }
  export type CashFundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CashSheet?: boolean | CashFund$CashSheetArgs<ExtArgs>
  }

  export type $CashFundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashFund"
    objects: {
      CashSheet: Prisma.$CountSheetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countId: number | null
      startDate: Date
      endDate: Date
      reqDate: Date
      payee: string
      remarks: string | null
      fundAmount: Prisma.Decimal
      miscExp: Prisma.Decimal | null
      billFee: Prisma.Decimal | null
      telFee: Prisma.Decimal | null
      dueMh: Prisma.Decimal | null
    }, ExtArgs["result"]["cashFund"]>
    composites: {}
  }

  type CashFundGetPayload<S extends boolean | null | undefined | CashFundDefaultArgs> = $Result.GetResult<Prisma.$CashFundPayload, S>

  type CashFundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashFundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashFundCountAggregateInputType | true
    }

  export interface CashFundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashFund'], meta: { name: 'CashFund' } }
    /**
     * Find zero or one CashFund that matches the filter.
     * @param {CashFundFindUniqueArgs} args - Arguments to find a CashFund
     * @example
     * // Get one CashFund
     * const cashFund = await prisma.cashFund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashFundFindUniqueArgs>(args: SelectSubset<T, CashFundFindUniqueArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashFund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashFundFindUniqueOrThrowArgs} args - Arguments to find a CashFund
     * @example
     * // Get one CashFund
     * const cashFund = await prisma.cashFund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashFundFindUniqueOrThrowArgs>(args: SelectSubset<T, CashFundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashFund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundFindFirstArgs} args - Arguments to find a CashFund
     * @example
     * // Get one CashFund
     * const cashFund = await prisma.cashFund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashFundFindFirstArgs>(args?: SelectSubset<T, CashFundFindFirstArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashFund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundFindFirstOrThrowArgs} args - Arguments to find a CashFund
     * @example
     * // Get one CashFund
     * const cashFund = await prisma.cashFund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashFundFindFirstOrThrowArgs>(args?: SelectSubset<T, CashFundFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashFunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashFunds
     * const cashFunds = await prisma.cashFund.findMany()
     * 
     * // Get first 10 CashFunds
     * const cashFunds = await prisma.cashFund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashFundWithIdOnly = await prisma.cashFund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashFundFindManyArgs>(args?: SelectSubset<T, CashFundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashFund.
     * @param {CashFundCreateArgs} args - Arguments to create a CashFund.
     * @example
     * // Create one CashFund
     * const CashFund = await prisma.cashFund.create({
     *   data: {
     *     // ... data to create a CashFund
     *   }
     * })
     * 
     */
    create<T extends CashFundCreateArgs>(args: SelectSubset<T, CashFundCreateArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashFunds.
     * @param {CashFundCreateManyArgs} args - Arguments to create many CashFunds.
     * @example
     * // Create many CashFunds
     * const cashFund = await prisma.cashFund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashFundCreateManyArgs>(args?: SelectSubset<T, CashFundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashFunds and returns the data saved in the database.
     * @param {CashFundCreateManyAndReturnArgs} args - Arguments to create many CashFunds.
     * @example
     * // Create many CashFunds
     * const cashFund = await prisma.cashFund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashFunds and only return the `id`
     * const cashFundWithIdOnly = await prisma.cashFund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashFundCreateManyAndReturnArgs>(args?: SelectSubset<T, CashFundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashFund.
     * @param {CashFundDeleteArgs} args - Arguments to delete one CashFund.
     * @example
     * // Delete one CashFund
     * const CashFund = await prisma.cashFund.delete({
     *   where: {
     *     // ... filter to delete one CashFund
     *   }
     * })
     * 
     */
    delete<T extends CashFundDeleteArgs>(args: SelectSubset<T, CashFundDeleteArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashFund.
     * @param {CashFundUpdateArgs} args - Arguments to update one CashFund.
     * @example
     * // Update one CashFund
     * const cashFund = await prisma.cashFund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashFundUpdateArgs>(args: SelectSubset<T, CashFundUpdateArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashFunds.
     * @param {CashFundDeleteManyArgs} args - Arguments to filter CashFunds to delete.
     * @example
     * // Delete a few CashFunds
     * const { count } = await prisma.cashFund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashFundDeleteManyArgs>(args?: SelectSubset<T, CashFundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashFunds
     * const cashFund = await prisma.cashFund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashFundUpdateManyArgs>(args: SelectSubset<T, CashFundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashFunds and returns the data updated in the database.
     * @param {CashFundUpdateManyAndReturnArgs} args - Arguments to update many CashFunds.
     * @example
     * // Update many CashFunds
     * const cashFund = await prisma.cashFund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashFunds and only return the `id`
     * const cashFundWithIdOnly = await prisma.cashFund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashFundUpdateManyAndReturnArgs>(args: SelectSubset<T, CashFundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashFund.
     * @param {CashFundUpsertArgs} args - Arguments to update or create a CashFund.
     * @example
     * // Update or create a CashFund
     * const cashFund = await prisma.cashFund.upsert({
     *   create: {
     *     // ... data to create a CashFund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashFund we want to update
     *   }
     * })
     */
    upsert<T extends CashFundUpsertArgs>(args: SelectSubset<T, CashFundUpsertArgs<ExtArgs>>): Prisma__CashFundClient<$Result.GetResult<Prisma.$CashFundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundCountArgs} args - Arguments to filter CashFunds to count.
     * @example
     * // Count the number of CashFunds
     * const count = await prisma.cashFund.count({
     *   where: {
     *     // ... the filter for the CashFunds we want to count
     *   }
     * })
    **/
    count<T extends CashFundCountArgs>(
      args?: Subset<T, CashFundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashFundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashFundAggregateArgs>(args: Subset<T, CashFundAggregateArgs>): Prisma.PrismaPromise<GetCashFundAggregateType<T>>

    /**
     * Group by CashFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashFundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashFundGroupByArgs['orderBy'] }
        : { orderBy?: CashFundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashFundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashFundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashFund model
   */
  readonly fields: CashFundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashFund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashFundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CashSheet<T extends CashFund$CashSheetArgs<ExtArgs> = {}>(args?: Subset<T, CashFund$CashSheetArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashFund model
   */
  interface CashFundFieldRefs {
    readonly id: FieldRef<"CashFund", 'Int'>
    readonly countId: FieldRef<"CashFund", 'Int'>
    readonly startDate: FieldRef<"CashFund", 'DateTime'>
    readonly endDate: FieldRef<"CashFund", 'DateTime'>
    readonly reqDate: FieldRef<"CashFund", 'DateTime'>
    readonly payee: FieldRef<"CashFund", 'String'>
    readonly remarks: FieldRef<"CashFund", 'String'>
    readonly fundAmount: FieldRef<"CashFund", 'Decimal'>
    readonly miscExp: FieldRef<"CashFund", 'Decimal'>
    readonly billFee: FieldRef<"CashFund", 'Decimal'>
    readonly telFee: FieldRef<"CashFund", 'Decimal'>
    readonly dueMh: FieldRef<"CashFund", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CashFund findUnique
   */
  export type CashFundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter, which CashFund to fetch.
     */
    where: CashFundWhereUniqueInput
  }

  /**
   * CashFund findUniqueOrThrow
   */
  export type CashFundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter, which CashFund to fetch.
     */
    where: CashFundWhereUniqueInput
  }

  /**
   * CashFund findFirst
   */
  export type CashFundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter, which CashFund to fetch.
     */
    where?: CashFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFunds to fetch.
     */
    orderBy?: CashFundOrderByWithRelationInput | CashFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFunds.
     */
    cursor?: CashFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFunds.
     */
    distinct?: CashFundScalarFieldEnum | CashFundScalarFieldEnum[]
  }

  /**
   * CashFund findFirstOrThrow
   */
  export type CashFundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter, which CashFund to fetch.
     */
    where?: CashFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFunds to fetch.
     */
    orderBy?: CashFundOrderByWithRelationInput | CashFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFunds.
     */
    cursor?: CashFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFunds.
     */
    distinct?: CashFundScalarFieldEnum | CashFundScalarFieldEnum[]
  }

  /**
   * CashFund findMany
   */
  export type CashFundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter, which CashFunds to fetch.
     */
    where?: CashFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFunds to fetch.
     */
    orderBy?: CashFundOrderByWithRelationInput | CashFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashFunds.
     */
    cursor?: CashFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFunds.
     */
    skip?: number
    distinct?: CashFundScalarFieldEnum | CashFundScalarFieldEnum[]
  }

  /**
   * CashFund create
   */
  export type CashFundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * The data needed to create a CashFund.
     */
    data: XOR<CashFundCreateInput, CashFundUncheckedCreateInput>
  }

  /**
   * CashFund createMany
   */
  export type CashFundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashFunds.
     */
    data: CashFundCreateManyInput | CashFundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashFund createManyAndReturn
   */
  export type CashFundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * The data used to create many CashFunds.
     */
    data: CashFundCreateManyInput | CashFundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashFund update
   */
  export type CashFundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * The data needed to update a CashFund.
     */
    data: XOR<CashFundUpdateInput, CashFundUncheckedUpdateInput>
    /**
     * Choose, which CashFund to update.
     */
    where: CashFundWhereUniqueInput
  }

  /**
   * CashFund updateMany
   */
  export type CashFundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashFunds.
     */
    data: XOR<CashFundUpdateManyMutationInput, CashFundUncheckedUpdateManyInput>
    /**
     * Filter which CashFunds to update
     */
    where?: CashFundWhereInput
    /**
     * Limit how many CashFunds to update.
     */
    limit?: number
  }

  /**
   * CashFund updateManyAndReturn
   */
  export type CashFundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * The data used to update CashFunds.
     */
    data: XOR<CashFundUpdateManyMutationInput, CashFundUncheckedUpdateManyInput>
    /**
     * Filter which CashFunds to update
     */
    where?: CashFundWhereInput
    /**
     * Limit how many CashFunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashFund upsert
   */
  export type CashFundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * The filter to search for the CashFund to update in case it exists.
     */
    where: CashFundWhereUniqueInput
    /**
     * In case the CashFund found by the `where` argument doesn't exist, create a new CashFund with this data.
     */
    create: XOR<CashFundCreateInput, CashFundUncheckedCreateInput>
    /**
     * In case the CashFund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashFundUpdateInput, CashFundUncheckedUpdateInput>
  }

  /**
   * CashFund delete
   */
  export type CashFundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
    /**
     * Filter which CashFund to delete.
     */
    where: CashFundWhereUniqueInput
  }

  /**
   * CashFund deleteMany
   */
  export type CashFundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFunds to delete
     */
    where?: CashFundWhereInput
    /**
     * Limit how many CashFunds to delete.
     */
    limit?: number
  }

  /**
   * CashFund.CashSheet
   */
  export type CashFund$CashSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    where?: CountSheetWhereInput
  }

  /**
   * CashFund without action
   */
  export type CashFundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFund
     */
    select?: CashFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashFund
     */
    omit?: CashFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFundInclude<ExtArgs> | null
  }


  /**
   * Model TravelFund
   */

  export type AggregateTravelFund = {
    _count: TravelFundCountAggregateOutputType | null
    _avg: TravelFundAvgAggregateOutputType | null
    _sum: TravelFundSumAggregateOutputType | null
    _min: TravelFundMinAggregateOutputType | null
    _max: TravelFundMaxAggregateOutputType | null
  }

  export type TravelFundAvgAggregateOutputType = {
    id: number | null
    countId: number | null
    fuel: Decimal | null
    litigation: Decimal | null
    totalFee: Decimal | null
  }

  export type TravelFundSumAggregateOutputType = {
    id: number | null
    countId: number | null
    fuel: Decimal | null
    litigation: Decimal | null
    totalFee: Decimal | null
  }

  export type TravelFundMinAggregateOutputType = {
    id: number | null
    countId: number | null
    startDate: Date | null
    endDate: Date | null
    reqDate: Date | null
    travelling: string | null
    fuel: Decimal | null
    litigation: Decimal | null
    totalFee: Decimal | null
    kilometer: string | null
    remarks: string | null
  }

  export type TravelFundMaxAggregateOutputType = {
    id: number | null
    countId: number | null
    startDate: Date | null
    endDate: Date | null
    reqDate: Date | null
    travelling: string | null
    fuel: Decimal | null
    litigation: Decimal | null
    totalFee: Decimal | null
    kilometer: string | null
    remarks: string | null
  }

  export type TravelFundCountAggregateOutputType = {
    id: number
    countId: number
    tagsField: number
    startDate: number
    endDate: number
    reqDate: number
    travelling: number
    fuel: number
    repair: number
    litigation: number
    totalFee: number
    kilometer: number
    remarks: number
    _all: number
  }


  export type TravelFundAvgAggregateInputType = {
    id?: true
    countId?: true
    fuel?: true
    litigation?: true
    totalFee?: true
  }

  export type TravelFundSumAggregateInputType = {
    id?: true
    countId?: true
    fuel?: true
    litigation?: true
    totalFee?: true
  }

  export type TravelFundMinAggregateInputType = {
    id?: true
    countId?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    travelling?: true
    fuel?: true
    litigation?: true
    totalFee?: true
    kilometer?: true
    remarks?: true
  }

  export type TravelFundMaxAggregateInputType = {
    id?: true
    countId?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    travelling?: true
    fuel?: true
    litigation?: true
    totalFee?: true
    kilometer?: true
    remarks?: true
  }

  export type TravelFundCountAggregateInputType = {
    id?: true
    countId?: true
    tagsField?: true
    startDate?: true
    endDate?: true
    reqDate?: true
    travelling?: true
    fuel?: true
    repair?: true
    litigation?: true
    totalFee?: true
    kilometer?: true
    remarks?: true
    _all?: true
  }

  export type TravelFundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelFund to aggregate.
     */
    where?: TravelFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelFunds to fetch.
     */
    orderBy?: TravelFundOrderByWithRelationInput | TravelFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TravelFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TravelFunds
    **/
    _count?: true | TravelFundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TravelFundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TravelFundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TravelFundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TravelFundMaxAggregateInputType
  }

  export type GetTravelFundAggregateType<T extends TravelFundAggregateArgs> = {
        [P in keyof T & keyof AggregateTravelFund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTravelFund[P]>
      : GetScalarType<T[P], AggregateTravelFund[P]>
  }




  export type TravelFundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelFundWhereInput
    orderBy?: TravelFundOrderByWithAggregationInput | TravelFundOrderByWithAggregationInput[]
    by: TravelFundScalarFieldEnum[] | TravelFundScalarFieldEnum
    having?: TravelFundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TravelFundCountAggregateInputType | true
    _avg?: TravelFundAvgAggregateInputType
    _sum?: TravelFundSumAggregateInputType
    _min?: TravelFundMinAggregateInputType
    _max?: TravelFundMaxAggregateInputType
  }

  export type TravelFundGroupByOutputType = {
    id: number
    countId: number | null
    tagsField: string[]
    startDate: Date
    endDate: Date
    reqDate: Date
    travelling: string | null
    fuel: Decimal | null
    repair: string[]
    litigation: Decimal | null
    totalFee: Decimal
    kilometer: string | null
    remarks: string | null
    _count: TravelFundCountAggregateOutputType | null
    _avg: TravelFundAvgAggregateOutputType | null
    _sum: TravelFundSumAggregateOutputType | null
    _min: TravelFundMinAggregateOutputType | null
    _max: TravelFundMaxAggregateOutputType | null
  }

  type GetTravelFundGroupByPayload<T extends TravelFundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TravelFundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TravelFundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TravelFundGroupByOutputType[P]>
            : GetScalarType<T[P], TravelFundGroupByOutputType[P]>
        }
      >
    >


  export type TravelFundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    tagsField?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    travelling?: boolean
    fuel?: boolean
    repair?: boolean
    litigation?: boolean
    totalFee?: boolean
    kilometer?: boolean
    remarks?: boolean
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }, ExtArgs["result"]["travelFund"]>

  export type TravelFundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    tagsField?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    travelling?: boolean
    fuel?: boolean
    repair?: boolean
    litigation?: boolean
    totalFee?: boolean
    kilometer?: boolean
    remarks?: boolean
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }, ExtArgs["result"]["travelFund"]>

  export type TravelFundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countId?: boolean
    tagsField?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    travelling?: boolean
    fuel?: boolean
    repair?: boolean
    litigation?: boolean
    totalFee?: boolean
    kilometer?: boolean
    remarks?: boolean
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }, ExtArgs["result"]["travelFund"]>

  export type TravelFundSelectScalar = {
    id?: boolean
    countId?: boolean
    tagsField?: boolean
    startDate?: boolean
    endDate?: boolean
    reqDate?: boolean
    travelling?: boolean
    fuel?: boolean
    repair?: boolean
    litigation?: boolean
    totalFee?: boolean
    kilometer?: boolean
    remarks?: boolean
  }

  export type TravelFundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countId" | "tagsField" | "startDate" | "endDate" | "reqDate" | "travelling" | "fuel" | "repair" | "litigation" | "totalFee" | "kilometer" | "remarks", ExtArgs["result"]["travelFund"]>
  export type TravelFundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }
  export type TravelFundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }
  export type TravelFundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TravelSheet?: boolean | TravelFund$TravelSheetArgs<ExtArgs>
  }

  export type $TravelFundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TravelFund"
    objects: {
      TravelSheet: Prisma.$CountSheetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countId: number | null
      tagsField: string[]
      startDate: Date
      endDate: Date
      reqDate: Date
      travelling: string | null
      fuel: Prisma.Decimal | null
      repair: string[]
      litigation: Prisma.Decimal | null
      totalFee: Prisma.Decimal
      kilometer: string | null
      remarks: string | null
    }, ExtArgs["result"]["travelFund"]>
    composites: {}
  }

  type TravelFundGetPayload<S extends boolean | null | undefined | TravelFundDefaultArgs> = $Result.GetResult<Prisma.$TravelFundPayload, S>

  type TravelFundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TravelFundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TravelFundCountAggregateInputType | true
    }

  export interface TravelFundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TravelFund'], meta: { name: 'TravelFund' } }
    /**
     * Find zero or one TravelFund that matches the filter.
     * @param {TravelFundFindUniqueArgs} args - Arguments to find a TravelFund
     * @example
     * // Get one TravelFund
     * const travelFund = await prisma.travelFund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TravelFundFindUniqueArgs>(args: SelectSubset<T, TravelFundFindUniqueArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TravelFund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TravelFundFindUniqueOrThrowArgs} args - Arguments to find a TravelFund
     * @example
     * // Get one TravelFund
     * const travelFund = await prisma.travelFund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TravelFundFindUniqueOrThrowArgs>(args: SelectSubset<T, TravelFundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TravelFund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundFindFirstArgs} args - Arguments to find a TravelFund
     * @example
     * // Get one TravelFund
     * const travelFund = await prisma.travelFund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TravelFundFindFirstArgs>(args?: SelectSubset<T, TravelFundFindFirstArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TravelFund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundFindFirstOrThrowArgs} args - Arguments to find a TravelFund
     * @example
     * // Get one TravelFund
     * const travelFund = await prisma.travelFund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TravelFundFindFirstOrThrowArgs>(args?: SelectSubset<T, TravelFundFindFirstOrThrowArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TravelFunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TravelFunds
     * const travelFunds = await prisma.travelFund.findMany()
     * 
     * // Get first 10 TravelFunds
     * const travelFunds = await prisma.travelFund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const travelFundWithIdOnly = await prisma.travelFund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TravelFundFindManyArgs>(args?: SelectSubset<T, TravelFundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TravelFund.
     * @param {TravelFundCreateArgs} args - Arguments to create a TravelFund.
     * @example
     * // Create one TravelFund
     * const TravelFund = await prisma.travelFund.create({
     *   data: {
     *     // ... data to create a TravelFund
     *   }
     * })
     * 
     */
    create<T extends TravelFundCreateArgs>(args: SelectSubset<T, TravelFundCreateArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TravelFunds.
     * @param {TravelFundCreateManyArgs} args - Arguments to create many TravelFunds.
     * @example
     * // Create many TravelFunds
     * const travelFund = await prisma.travelFund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TravelFundCreateManyArgs>(args?: SelectSubset<T, TravelFundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TravelFunds and returns the data saved in the database.
     * @param {TravelFundCreateManyAndReturnArgs} args - Arguments to create many TravelFunds.
     * @example
     * // Create many TravelFunds
     * const travelFund = await prisma.travelFund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TravelFunds and only return the `id`
     * const travelFundWithIdOnly = await prisma.travelFund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TravelFundCreateManyAndReturnArgs>(args?: SelectSubset<T, TravelFundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TravelFund.
     * @param {TravelFundDeleteArgs} args - Arguments to delete one TravelFund.
     * @example
     * // Delete one TravelFund
     * const TravelFund = await prisma.travelFund.delete({
     *   where: {
     *     // ... filter to delete one TravelFund
     *   }
     * })
     * 
     */
    delete<T extends TravelFundDeleteArgs>(args: SelectSubset<T, TravelFundDeleteArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TravelFund.
     * @param {TravelFundUpdateArgs} args - Arguments to update one TravelFund.
     * @example
     * // Update one TravelFund
     * const travelFund = await prisma.travelFund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TravelFundUpdateArgs>(args: SelectSubset<T, TravelFundUpdateArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TravelFunds.
     * @param {TravelFundDeleteManyArgs} args - Arguments to filter TravelFunds to delete.
     * @example
     * // Delete a few TravelFunds
     * const { count } = await prisma.travelFund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TravelFundDeleteManyArgs>(args?: SelectSubset<T, TravelFundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TravelFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TravelFunds
     * const travelFund = await prisma.travelFund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TravelFundUpdateManyArgs>(args: SelectSubset<T, TravelFundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TravelFunds and returns the data updated in the database.
     * @param {TravelFundUpdateManyAndReturnArgs} args - Arguments to update many TravelFunds.
     * @example
     * // Update many TravelFunds
     * const travelFund = await prisma.travelFund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TravelFunds and only return the `id`
     * const travelFundWithIdOnly = await prisma.travelFund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TravelFundUpdateManyAndReturnArgs>(args: SelectSubset<T, TravelFundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TravelFund.
     * @param {TravelFundUpsertArgs} args - Arguments to update or create a TravelFund.
     * @example
     * // Update or create a TravelFund
     * const travelFund = await prisma.travelFund.upsert({
     *   create: {
     *     // ... data to create a TravelFund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TravelFund we want to update
     *   }
     * })
     */
    upsert<T extends TravelFundUpsertArgs>(args: SelectSubset<T, TravelFundUpsertArgs<ExtArgs>>): Prisma__TravelFundClient<$Result.GetResult<Prisma.$TravelFundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TravelFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundCountArgs} args - Arguments to filter TravelFunds to count.
     * @example
     * // Count the number of TravelFunds
     * const count = await prisma.travelFund.count({
     *   where: {
     *     // ... the filter for the TravelFunds we want to count
     *   }
     * })
    **/
    count<T extends TravelFundCountArgs>(
      args?: Subset<T, TravelFundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TravelFundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TravelFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TravelFundAggregateArgs>(args: Subset<T, TravelFundAggregateArgs>): Prisma.PrismaPromise<GetTravelFundAggregateType<T>>

    /**
     * Group by TravelFund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelFundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TravelFundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TravelFundGroupByArgs['orderBy'] }
        : { orderBy?: TravelFundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TravelFundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTravelFundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TravelFund model
   */
  readonly fields: TravelFundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TravelFund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TravelFundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TravelSheet<T extends TravelFund$TravelSheetArgs<ExtArgs> = {}>(args?: Subset<T, TravelFund$TravelSheetArgs<ExtArgs>>): Prisma__CountSheetClient<$Result.GetResult<Prisma.$CountSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TravelFund model
   */
  interface TravelFundFieldRefs {
    readonly id: FieldRef<"TravelFund", 'Int'>
    readonly countId: FieldRef<"TravelFund", 'Int'>
    readonly tagsField: FieldRef<"TravelFund", 'String[]'>
    readonly startDate: FieldRef<"TravelFund", 'DateTime'>
    readonly endDate: FieldRef<"TravelFund", 'DateTime'>
    readonly reqDate: FieldRef<"TravelFund", 'DateTime'>
    readonly travelling: FieldRef<"TravelFund", 'String'>
    readonly fuel: FieldRef<"TravelFund", 'Decimal'>
    readonly repair: FieldRef<"TravelFund", 'String[]'>
    readonly litigation: FieldRef<"TravelFund", 'Decimal'>
    readonly totalFee: FieldRef<"TravelFund", 'Decimal'>
    readonly kilometer: FieldRef<"TravelFund", 'String'>
    readonly remarks: FieldRef<"TravelFund", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TravelFund findUnique
   */
  export type TravelFundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter, which TravelFund to fetch.
     */
    where: TravelFundWhereUniqueInput
  }

  /**
   * TravelFund findUniqueOrThrow
   */
  export type TravelFundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter, which TravelFund to fetch.
     */
    where: TravelFundWhereUniqueInput
  }

  /**
   * TravelFund findFirst
   */
  export type TravelFundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter, which TravelFund to fetch.
     */
    where?: TravelFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelFunds to fetch.
     */
    orderBy?: TravelFundOrderByWithRelationInput | TravelFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelFunds.
     */
    cursor?: TravelFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelFunds.
     */
    distinct?: TravelFundScalarFieldEnum | TravelFundScalarFieldEnum[]
  }

  /**
   * TravelFund findFirstOrThrow
   */
  export type TravelFundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter, which TravelFund to fetch.
     */
    where?: TravelFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelFunds to fetch.
     */
    orderBy?: TravelFundOrderByWithRelationInput | TravelFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelFunds.
     */
    cursor?: TravelFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelFunds.
     */
    distinct?: TravelFundScalarFieldEnum | TravelFundScalarFieldEnum[]
  }

  /**
   * TravelFund findMany
   */
  export type TravelFundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter, which TravelFunds to fetch.
     */
    where?: TravelFundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelFunds to fetch.
     */
    orderBy?: TravelFundOrderByWithRelationInput | TravelFundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TravelFunds.
     */
    cursor?: TravelFundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelFunds.
     */
    skip?: number
    distinct?: TravelFundScalarFieldEnum | TravelFundScalarFieldEnum[]
  }

  /**
   * TravelFund create
   */
  export type TravelFundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * The data needed to create a TravelFund.
     */
    data: XOR<TravelFundCreateInput, TravelFundUncheckedCreateInput>
  }

  /**
   * TravelFund createMany
   */
  export type TravelFundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TravelFunds.
     */
    data: TravelFundCreateManyInput | TravelFundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TravelFund createManyAndReturn
   */
  export type TravelFundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * The data used to create many TravelFunds.
     */
    data: TravelFundCreateManyInput | TravelFundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TravelFund update
   */
  export type TravelFundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * The data needed to update a TravelFund.
     */
    data: XOR<TravelFundUpdateInput, TravelFundUncheckedUpdateInput>
    /**
     * Choose, which TravelFund to update.
     */
    where: TravelFundWhereUniqueInput
  }

  /**
   * TravelFund updateMany
   */
  export type TravelFundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TravelFunds.
     */
    data: XOR<TravelFundUpdateManyMutationInput, TravelFundUncheckedUpdateManyInput>
    /**
     * Filter which TravelFunds to update
     */
    where?: TravelFundWhereInput
    /**
     * Limit how many TravelFunds to update.
     */
    limit?: number
  }

  /**
   * TravelFund updateManyAndReturn
   */
  export type TravelFundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * The data used to update TravelFunds.
     */
    data: XOR<TravelFundUpdateManyMutationInput, TravelFundUncheckedUpdateManyInput>
    /**
     * Filter which TravelFunds to update
     */
    where?: TravelFundWhereInput
    /**
     * Limit how many TravelFunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TravelFund upsert
   */
  export type TravelFundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * The filter to search for the TravelFund to update in case it exists.
     */
    where: TravelFundWhereUniqueInput
    /**
     * In case the TravelFund found by the `where` argument doesn't exist, create a new TravelFund with this data.
     */
    create: XOR<TravelFundCreateInput, TravelFundUncheckedCreateInput>
    /**
     * In case the TravelFund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TravelFundUpdateInput, TravelFundUncheckedUpdateInput>
  }

  /**
   * TravelFund delete
   */
  export type TravelFundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
    /**
     * Filter which TravelFund to delete.
     */
    where: TravelFundWhereUniqueInput
  }

  /**
   * TravelFund deleteMany
   */
  export type TravelFundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelFunds to delete
     */
    where?: TravelFundWhereInput
    /**
     * Limit how many TravelFunds to delete.
     */
    limit?: number
  }

  /**
   * TravelFund.TravelSheet
   */
  export type TravelFund$TravelSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountSheet
     */
    select?: CountSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountSheet
     */
    omit?: CountSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountSheetInclude<ExtArgs> | null
    where?: CountSheetWhereInput
  }

  /**
   * TravelFund without action
   */
  export type TravelFundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelFund
     */
    select?: TravelFundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TravelFund
     */
    omit?: TravelFundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelFundInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role',
    branchId: 'branchId',
    signatureUrl: 'signatureUrl',
    position: 'position',
    initial: 'initial',
    approver: 'approver',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    branchCode: 'branchCode',
    branchName: 'branchName',
    bom: 'bom',
    faa: 'faa',
    telephone: 'telephone',
    address: 'address',
    companyName: 'companyName',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const RequestTypeScalarFieldEnum: {
    id: 'id',
    requestName: 'requestName',
    notedById: 'notedById',
    checkedById: 'checkedById',
    checkedBy2Id: 'checkedBy2Id',
    recomApprovalId: 'recomApprovalId',
    recomApproval2Id: 'recomApproval2Id',
    approveById: 'approveById',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type RequestTypeScalarFieldEnum = (typeof RequestTypeScalarFieldEnum)[keyof typeof RequestTypeScalarFieldEnum]


  export const MainRequestScalarFieldEnum: {
    id: 'id',
    referenceCode: 'referenceCode',
    requestTypeId: 'requestTypeId',
    requestById: 'requestById',
    requestFromId: 'requestFromId',
    status: 'status',
    requestDate: 'requestDate',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type MainRequestScalarFieldEnum = (typeof MainRequestScalarFieldEnum)[keyof typeof MainRequestScalarFieldEnum]


  export const FormFundTransferScalarFieldEnum: {
    id: 'id',
    mainRequestID: 'mainRequestID',
    requestToId: 'requestToId',
    requestContent: 'requestContent',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type FormFundTransferScalarFieldEnum = (typeof FormFundTransferScalarFieldEnum)[keyof typeof FormFundTransferScalarFieldEnum]


  export const ApprovalTableScalarFieldEnum: {
    id: 'id',
    mainFormId: 'mainFormId',
    notedBy: 'notedBy',
    checkedBy: 'checkedBy',
    checkedBy2: 'checkedBy2',
    recomApproval: 'recomApproval',
    recomApproval2: 'recomApproval2',
    approveBy: 'approveBy',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type ApprovalTableScalarFieldEnum = (typeof ApprovalTableScalarFieldEnum)[keyof typeof ApprovalTableScalarFieldEnum]


  export const RequestLogsScalarFieldEnum: {
    id: 'id',
    approvalId: 'approvalId',
    checkerType: 'checkerType',
    approverId: 'approverId',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type RequestLogsScalarFieldEnum = (typeof RequestLogsScalarFieldEnum)[keyof typeof RequestLogsScalarFieldEnum]


  export const FormTravelOrderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    departure_date: 'departure_date',
    current_date: 'current_date',
    destination: 'destination',
    purpose_of_travel: 'purpose_of_travel',
    items: 'items',
    total_amount: 'total_amount',
    createdAt: 'createdAt',
    mainFormId: 'mainFormId'
  };

  export type FormTravelOrderScalarFieldEnum = (typeof FormTravelOrderScalarFieldEnum)[keyof typeof FormTravelOrderScalarFieldEnum]


  export const FormProposedBudgetScalarFieldEnum: {
    id: 'id',
    description: 'description',
    budget: 'budget',
    total_expenses: 'total_expenses',
    variance: 'variance',
    proposed_budget: 'proposed_budget',
    remarks: 'remarks',
    expense_type: 'expense_type',
    month_of: 'month_of',
    createdAt: 'createdAt',
    mainFormId: 'mainFormId'
  };

  export type FormProposedBudgetScalarFieldEnum = (typeof FormProposedBudgetScalarFieldEnum)[keyof typeof FormProposedBudgetScalarFieldEnum]


  export const FormTransmittalMemoScalarFieldEnum: {
    id: 'id',
    from: 'from',
    date: 'date',
    description: 'description',
    note: 'note',
    items: 'items',
    to_id: 'to_id',
    mainFormId: 'mainFormId'
  };

  export type FormTransmittalMemoScalarFieldEnum = (typeof FormTransmittalMemoScalarFieldEnum)[keyof typeof FormTransmittalMemoScalarFieldEnum]


  export const FormDisburseScalarFieldEnum: {
    id: 'id',
    from: 'from',
    date: 'date',
    subject: 'subject',
    description: 'description',
    note: 'note',
    total_amount: 'total_amount',
    items: 'items',
    to_id: 'to_id',
    mainFormId: 'mainFormId'
  };

  export type FormDisburseScalarFieldEnum = (typeof FormDisburseScalarFieldEnum)[keyof typeof FormDisburseScalarFieldEnum]


  export const CountSheetScalarFieldEnum: {
    id: 'id',
    fundType: 'fundType',
    mainFormId: 'mainFormId',
    office: 'office',
    dateCount: 'dateCount',
    fundName: 'fundName',
    fundAmount: 'fundAmount',
    reference: 'reference',
    cashDemo: 'cashDemo',
    repFund: 'repFund',
    totalFund: 'totalFund',
    cashShort: 'cashShort'
  };

  export type CountSheetScalarFieldEnum = (typeof CountSheetScalarFieldEnum)[keyof typeof CountSheetScalarFieldEnum]


  export const CashFundScalarFieldEnum: {
    id: 'id',
    countId: 'countId',
    startDate: 'startDate',
    endDate: 'endDate',
    reqDate: 'reqDate',
    payee: 'payee',
    remarks: 'remarks',
    fundAmount: 'fundAmount',
    miscExp: 'miscExp',
    billFee: 'billFee',
    telFee: 'telFee',
    dueMh: 'dueMh'
  };

  export type CashFundScalarFieldEnum = (typeof CashFundScalarFieldEnum)[keyof typeof CashFundScalarFieldEnum]


  export const TravelFundScalarFieldEnum: {
    id: 'id',
    countId: 'countId',
    tagsField: 'tagsField',
    startDate: 'startDate',
    endDate: 'endDate',
    reqDate: 'reqDate',
    travelling: 'travelling',
    fuel: 'fuel',
    repair: 'repair',
    litigation: 'litigation',
    totalFee: 'totalFee',
    kilometer: 'kilometer',
    remarks: 'remarks'
  };

  export type TravelFundScalarFieldEnum = (typeof TravelFundScalarFieldEnum)[keyof typeof TravelFundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Statuses'
   */
  export type EnumStatusesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Statuses'>
    


  /**
   * Reference to a field of type 'Statuses[]'
   */
  export type ListEnumStatusesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Statuses[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    signatureUrl?: StringNullableFilter<"User"> | string | null
    position?: StringNullableFilter<"User"> | string | null
    initial?: StringNullableFilter<"User"> | string | null
    approver?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    notedByForTypes?: RequestTypeListRelationFilter
    checkedByForTypes?: RequestTypeListRelationFilter
    checkedBy2ForTypes?: RequestTypeListRelationFilter
    recomApprovalForTypes?: RequestTypeListRelationFilter
    recomApproval2ForTypes?: RequestTypeListRelationFilter
    approveByForTypes?: RequestTypeListRelationFilter
    formRequestFundTo?: FormFundTransferListRelationFilter
    formRequestTransmittalTo?: FormTransmittalMemoListRelationFilter
    formRequestDisburseTo?: FormDisburseListRelationFilter
    requestLogs?: RequestLogsListRelationFilter
    mainForm?: MainRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    initial?: SortOrderInput | SortOrder
    approver?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    notedByForTypes?: RequestTypeOrderByRelationAggregateInput
    checkedByForTypes?: RequestTypeOrderByRelationAggregateInput
    checkedBy2ForTypes?: RequestTypeOrderByRelationAggregateInput
    recomApprovalForTypes?: RequestTypeOrderByRelationAggregateInput
    recomApproval2ForTypes?: RequestTypeOrderByRelationAggregateInput
    approveByForTypes?: RequestTypeOrderByRelationAggregateInput
    formRequestFundTo?: FormFundTransferOrderByRelationAggregateInput
    formRequestTransmittalTo?: formTransmittalMemoOrderByRelationAggregateInput
    formRequestDisburseTo?: formDisburseOrderByRelationAggregateInput
    requestLogs?: RequestLogsOrderByRelationAggregateInput
    mainForm?: MainRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    signatureUrl?: StringNullableFilter<"User"> | string | null
    position?: StringNullableFilter<"User"> | string | null
    initial?: StringNullableFilter<"User"> | string | null
    approver?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    notedByForTypes?: RequestTypeListRelationFilter
    checkedByForTypes?: RequestTypeListRelationFilter
    checkedBy2ForTypes?: RequestTypeListRelationFilter
    recomApprovalForTypes?: RequestTypeListRelationFilter
    recomApproval2ForTypes?: RequestTypeListRelationFilter
    approveByForTypes?: RequestTypeListRelationFilter
    formRequestFundTo?: FormFundTransferListRelationFilter
    formRequestTransmittalTo?: FormTransmittalMemoListRelationFilter
    formRequestDisburseTo?: FormDisburseListRelationFilter
    requestLogs?: RequestLogsListRelationFilter
    mainForm?: MainRequestListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    initial?: SortOrderInput | SortOrder
    approver?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    signatureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    position?: StringNullableWithAggregatesFilter<"User"> | string | null
    initial?: StringNullableWithAggregatesFilter<"User"> | string | null
    approver?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    branchCode?: StringFilter<"Branch"> | string
    branchName?: StringFilter<"Branch"> | string
    bom?: StringFilter<"Branch"> | string
    faa?: StringFilter<"Branch"> | string
    telephone?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    companyName?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updateAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    main?: MainRequestListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    main?: MainRequestOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    branchCode?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    branchName?: StringFilter<"Branch"> | string
    bom?: StringFilter<"Branch"> | string
    faa?: StringFilter<"Branch"> | string
    telephone?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    companyName?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updateAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    main?: MainRequestListRelationFilter
  }, "id" | "branchCode">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    branchCode?: StringWithAggregatesFilter<"Branch"> | string
    branchName?: StringWithAggregatesFilter<"Branch"> | string
    bom?: StringWithAggregatesFilter<"Branch"> | string
    faa?: StringWithAggregatesFilter<"Branch"> | string
    telephone?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringWithAggregatesFilter<"Branch"> | string
    companyName?: StringWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type RequestTypeWhereInput = {
    AND?: RequestTypeWhereInput | RequestTypeWhereInput[]
    OR?: RequestTypeWhereInput[]
    NOT?: RequestTypeWhereInput | RequestTypeWhereInput[]
    id?: IntFilter<"RequestType"> | number
    requestName?: StringFilter<"RequestType"> | string
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
    notedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    checkedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    checkedBy2?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    recomApproval?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    recomApproval2?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approveBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainRequests?: MainRequestListRelationFilter
  }

  export type RequestTypeOrderByWithRelationInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    checkedBy2Id?: SortOrderInput | SortOrder
    recomApprovalId?: SortOrderInput | SortOrder
    recomApproval2Id?: SortOrderInput | SortOrder
    approveById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    notedBy?: UserOrderByWithRelationInput
    checkedBy?: UserOrderByWithRelationInput
    checkedBy2?: UserOrderByWithRelationInput
    recomApproval?: UserOrderByWithRelationInput
    recomApproval2?: UserOrderByWithRelationInput
    approveBy?: UserOrderByWithRelationInput
    mainRequests?: MainRequestOrderByRelationAggregateInput
  }

  export type RequestTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    requestName?: string
    AND?: RequestTypeWhereInput | RequestTypeWhereInput[]
    OR?: RequestTypeWhereInput[]
    NOT?: RequestTypeWhereInput | RequestTypeWhereInput[]
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
    notedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    checkedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    checkedBy2?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    recomApproval?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    recomApproval2?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approveBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainRequests?: MainRequestListRelationFilter
  }, "id" | "requestName">

  export type RequestTypeOrderByWithAggregationInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrderInput | SortOrder
    checkedById?: SortOrderInput | SortOrder
    checkedBy2Id?: SortOrderInput | SortOrder
    recomApprovalId?: SortOrderInput | SortOrder
    recomApproval2Id?: SortOrderInput | SortOrder
    approveById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: RequestTypeCountOrderByAggregateInput
    _avg?: RequestTypeAvgOrderByAggregateInput
    _max?: RequestTypeMaxOrderByAggregateInput
    _min?: RequestTypeMinOrderByAggregateInput
    _sum?: RequestTypeSumOrderByAggregateInput
  }

  export type RequestTypeScalarWhereWithAggregatesInput = {
    AND?: RequestTypeScalarWhereWithAggregatesInput | RequestTypeScalarWhereWithAggregatesInput[]
    OR?: RequestTypeScalarWhereWithAggregatesInput[]
    NOT?: RequestTypeScalarWhereWithAggregatesInput | RequestTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestType"> | number
    requestName?: StringWithAggregatesFilter<"RequestType"> | string
    notedById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    checkedById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    approveById?: IntNullableWithAggregatesFilter<"RequestType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RequestType"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"RequestType"> | Date | string
  }

  export type MainRequestWhereInput = {
    AND?: MainRequestWhereInput | MainRequestWhereInput[]
    OR?: MainRequestWhereInput[]
    NOT?: MainRequestWhereInput | MainRequestWhereInput[]
    id?: IntFilter<"MainRequest"> | number
    referenceCode?: StringFilter<"MainRequest"> | string
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
    requestType?: XOR<RequestTypeNullableScalarRelationFilter, RequestTypeWhereInput> | null
    fundTransfer?: XOR<FormFundTransferNullableScalarRelationFilter, FormFundTransferWhereInput> | null
    requestBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestFrom?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    approval?: ApprovalTableListRelationFilter
    travelOrder?: XOR<FormTravelOrderNullableScalarRelationFilter, formTravelOrderWhereInput> | null
    transmittalMemo?: XOR<FormTransmittalMemoNullableScalarRelationFilter, formTransmittalMemoWhereInput> | null
    proposedBudget?: FormProposedBudgetListRelationFilter
    disburse?: XOR<FormDisburseNullableScalarRelationFilter, formDisburseWhereInput> | null
    countSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }

  export type MainRequestOrderByWithRelationInput = {
    id?: SortOrder
    referenceCode?: SortOrder
    requestTypeId?: SortOrderInput | SortOrder
    requestById?: SortOrderInput | SortOrder
    requestFromId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    requestType?: RequestTypeOrderByWithRelationInput
    fundTransfer?: FormFundTransferOrderByWithRelationInput
    requestBy?: UserOrderByWithRelationInput
    requestFrom?: BranchOrderByWithRelationInput
    approval?: ApprovalTableOrderByRelationAggregateInput
    travelOrder?: formTravelOrderOrderByWithRelationInput
    transmittalMemo?: formTransmittalMemoOrderByWithRelationInput
    proposedBudget?: formProposedBudgetOrderByRelationAggregateInput
    disburse?: formDisburseOrderByWithRelationInput
    countSheet?: CountSheetOrderByWithRelationInput
  }

  export type MainRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceCode?: string
    AND?: MainRequestWhereInput | MainRequestWhereInput[]
    OR?: MainRequestWhereInput[]
    NOT?: MainRequestWhereInput | MainRequestWhereInput[]
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
    requestType?: XOR<RequestTypeNullableScalarRelationFilter, RequestTypeWhereInput> | null
    fundTransfer?: XOR<FormFundTransferNullableScalarRelationFilter, FormFundTransferWhereInput> | null
    requestBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    requestFrom?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    approval?: ApprovalTableListRelationFilter
    travelOrder?: XOR<FormTravelOrderNullableScalarRelationFilter, formTravelOrderWhereInput> | null
    transmittalMemo?: XOR<FormTransmittalMemoNullableScalarRelationFilter, formTransmittalMemoWhereInput> | null
    proposedBudget?: FormProposedBudgetListRelationFilter
    disburse?: XOR<FormDisburseNullableScalarRelationFilter, formDisburseWhereInput> | null
    countSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }, "id" | "referenceCode">

  export type MainRequestOrderByWithAggregationInput = {
    id?: SortOrder
    referenceCode?: SortOrder
    requestTypeId?: SortOrderInput | SortOrder
    requestById?: SortOrderInput | SortOrder
    requestFromId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: MainRequestCountOrderByAggregateInput
    _avg?: MainRequestAvgOrderByAggregateInput
    _max?: MainRequestMaxOrderByAggregateInput
    _min?: MainRequestMinOrderByAggregateInput
    _sum?: MainRequestSumOrderByAggregateInput
  }

  export type MainRequestScalarWhereWithAggregatesInput = {
    AND?: MainRequestScalarWhereWithAggregatesInput | MainRequestScalarWhereWithAggregatesInput[]
    OR?: MainRequestScalarWhereWithAggregatesInput[]
    NOT?: MainRequestScalarWhereWithAggregatesInput | MainRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MainRequest"> | number
    referenceCode?: StringWithAggregatesFilter<"MainRequest"> | string
    requestTypeId?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    requestById?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableWithAggregatesFilter<"MainRequest"> | number | null
    status?: EnumStatusesWithAggregatesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"MainRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"MainRequest"> | Date | string
  }

  export type FormFundTransferWhereInput = {
    AND?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    OR?: FormFundTransferWhereInput[]
    NOT?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    id?: IntFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FormFundTransferOrderByWithRelationInput = {
    id?: SortOrder
    mainRequestID?: SortOrderInput | SortOrder
    requestToId?: SortOrderInput | SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    mainRequest?: MainRequestOrderByWithRelationInput
    requestTo?: UserOrderByWithRelationInput
  }

  export type FormFundTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainRequestID?: number
    AND?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    OR?: FormFundTransferWhereInput[]
    NOT?: FormFundTransferWhereInput | FormFundTransferWhereInput[]
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "mainRequestID">

  export type FormFundTransferOrderByWithAggregationInput = {
    id?: SortOrder
    mainRequestID?: SortOrderInput | SortOrder
    requestToId?: SortOrderInput | SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: FormFundTransferCountOrderByAggregateInput
    _avg?: FormFundTransferAvgOrderByAggregateInput
    _max?: FormFundTransferMaxOrderByAggregateInput
    _min?: FormFundTransferMinOrderByAggregateInput
    _sum?: FormFundTransferSumOrderByAggregateInput
  }

  export type FormFundTransferScalarWhereWithAggregatesInput = {
    AND?: FormFundTransferScalarWhereWithAggregatesInput | FormFundTransferScalarWhereWithAggregatesInput[]
    OR?: FormFundTransferScalarWhereWithAggregatesInput[]
    NOT?: FormFundTransferScalarWhereWithAggregatesInput | FormFundTransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableWithAggregatesFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableWithAggregatesFilter<"FormFundTransfer"> | number | null
    requestContent?: StringWithAggregatesFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"FormFundTransfer"> | Date | string
  }

  export type ApprovalTableWhereInput = {
    AND?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    OR?: ApprovalTableWhereInput[]
    NOT?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    id?: IntFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestLogs?: RequestLogsListRelationFilter
  }

  export type ApprovalTableOrderByWithRelationInput = {
    id?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    mainRequest?: MainRequestOrderByWithRelationInput
    requestLogs?: RequestLogsOrderByRelationAggregateInput
  }

  export type ApprovalTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    OR?: ApprovalTableWhereInput[]
    NOT?: ApprovalTableWhereInput | ApprovalTableWhereInput[]
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    mainRequest?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    requestLogs?: RequestLogsListRelationFilter
  }, "id" | "mainFormId">

  export type ApprovalTableOrderByWithAggregationInput = {
    id?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: ApprovalTableCountOrderByAggregateInput
    _avg?: ApprovalTableAvgOrderByAggregateInput
    _max?: ApprovalTableMaxOrderByAggregateInput
    _min?: ApprovalTableMinOrderByAggregateInput
    _sum?: ApprovalTableSumOrderByAggregateInput
  }

  export type ApprovalTableScalarWhereWithAggregatesInput = {
    AND?: ApprovalTableScalarWhereWithAggregatesInput | ApprovalTableScalarWhereWithAggregatesInput[]
    OR?: ApprovalTableScalarWhereWithAggregatesInput[]
    NOT?: ApprovalTableScalarWhereWithAggregatesInput | ApprovalTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableWithAggregatesFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesWithAggregatesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"ApprovalTable"> | Date | string
  }

  export type RequestLogsWhereInput = {
    AND?: RequestLogsWhereInput | RequestLogsWhereInput[]
    OR?: RequestLogsWhereInput[]
    NOT?: RequestLogsWhereInput | RequestLogsWhereInput[]
    id?: IntFilter<"RequestLogs"> | number
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    action?: StringFilter<"RequestLogs"> | string
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
    approval?: XOR<ApprovalTableNullableScalarRelationFilter, ApprovalTableWhereInput> | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RequestLogsOrderByWithRelationInput = {
    id?: SortOrder
    approvalId?: SortOrderInput | SortOrder
    checkerType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    approval?: ApprovalTableOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type RequestLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestLogsWhereInput | RequestLogsWhereInput[]
    OR?: RequestLogsWhereInput[]
    NOT?: RequestLogsWhereInput | RequestLogsWhereInput[]
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    action?: StringFilter<"RequestLogs"> | string
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
    approval?: XOR<ApprovalTableNullableScalarRelationFilter, ApprovalTableWhereInput> | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RequestLogsOrderByWithAggregationInput = {
    id?: SortOrder
    approvalId?: SortOrderInput | SortOrder
    checkerType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: RequestLogsCountOrderByAggregateInput
    _avg?: RequestLogsAvgOrderByAggregateInput
    _max?: RequestLogsMaxOrderByAggregateInput
    _min?: RequestLogsMinOrderByAggregateInput
    _sum?: RequestLogsSumOrderByAggregateInput
  }

  export type RequestLogsScalarWhereWithAggregatesInput = {
    AND?: RequestLogsScalarWhereWithAggregatesInput | RequestLogsScalarWhereWithAggregatesInput[]
    OR?: RequestLogsScalarWhereWithAggregatesInput[]
    NOT?: RequestLogsScalarWhereWithAggregatesInput | RequestLogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestLogs"> | number
    approvalId?: IntNullableWithAggregatesFilter<"RequestLogs"> | number | null
    checkerType?: StringWithAggregatesFilter<"RequestLogs"> | string
    approverId?: IntNullableWithAggregatesFilter<"RequestLogs"> | number | null
    action?: StringWithAggregatesFilter<"RequestLogs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequestLogs"> | Date | string
  }

  export type formTravelOrderWhereInput = {
    AND?: formTravelOrderWhereInput | formTravelOrderWhereInput[]
    OR?: formTravelOrderWhereInput[]
    NOT?: formTravelOrderWhereInput | formTravelOrderWhereInput[]
    id?: IntFilter<"formTravelOrder"> | number
    name?: StringNullableFilter<"formTravelOrder"> | string | null
    position?: StringNullableFilter<"formTravelOrder"> | string | null
    departure_date?: DateTimeFilter<"formTravelOrder"> | Date | string
    current_date?: DateTimeFilter<"formTravelOrder"> | Date | string
    destination?: StringNullableFilter<"formTravelOrder"> | string | null
    purpose_of_travel?: StringNullableFilter<"formTravelOrder"> | string | null
    items?: JsonNullableFilter<"formTravelOrder">
    total_amount?: DecimalNullableFilter<"formTravelOrder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"formTravelOrder"> | Date | string
    mainFormId?: IntFilter<"formTravelOrder"> | number
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }

  export type formTravelOrderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    departure_date?: SortOrder
    current_date?: SortOrder
    destination?: SortOrderInput | SortOrder
    purpose_of_travel?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
    mainForm?: MainRequestOrderByWithRelationInput
  }

  export type formTravelOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: formTravelOrderWhereInput | formTravelOrderWhereInput[]
    OR?: formTravelOrderWhereInput[]
    NOT?: formTravelOrderWhereInput | formTravelOrderWhereInput[]
    name?: StringNullableFilter<"formTravelOrder"> | string | null
    position?: StringNullableFilter<"formTravelOrder"> | string | null
    departure_date?: DateTimeFilter<"formTravelOrder"> | Date | string
    current_date?: DateTimeFilter<"formTravelOrder"> | Date | string
    destination?: StringNullableFilter<"formTravelOrder"> | string | null
    purpose_of_travel?: StringNullableFilter<"formTravelOrder"> | string | null
    items?: JsonNullableFilter<"formTravelOrder">
    total_amount?: DecimalNullableFilter<"formTravelOrder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"formTravelOrder"> | Date | string
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }, "id" | "mainFormId">

  export type formTravelOrderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    departure_date?: SortOrder
    current_date?: SortOrder
    destination?: SortOrderInput | SortOrder
    purpose_of_travel?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
    _count?: formTravelOrderCountOrderByAggregateInput
    _avg?: formTravelOrderAvgOrderByAggregateInput
    _max?: formTravelOrderMaxOrderByAggregateInput
    _min?: formTravelOrderMinOrderByAggregateInput
    _sum?: formTravelOrderSumOrderByAggregateInput
  }

  export type formTravelOrderScalarWhereWithAggregatesInput = {
    AND?: formTravelOrderScalarWhereWithAggregatesInput | formTravelOrderScalarWhereWithAggregatesInput[]
    OR?: formTravelOrderScalarWhereWithAggregatesInput[]
    NOT?: formTravelOrderScalarWhereWithAggregatesInput | formTravelOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formTravelOrder"> | number
    name?: StringNullableWithAggregatesFilter<"formTravelOrder"> | string | null
    position?: StringNullableWithAggregatesFilter<"formTravelOrder"> | string | null
    departure_date?: DateTimeWithAggregatesFilter<"formTravelOrder"> | Date | string
    current_date?: DateTimeWithAggregatesFilter<"formTravelOrder"> | Date | string
    destination?: StringNullableWithAggregatesFilter<"formTravelOrder"> | string | null
    purpose_of_travel?: StringNullableWithAggregatesFilter<"formTravelOrder"> | string | null
    items?: JsonNullableWithAggregatesFilter<"formTravelOrder">
    total_amount?: DecimalNullableWithAggregatesFilter<"formTravelOrder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"formTravelOrder"> | Date | string
    mainFormId?: IntWithAggregatesFilter<"formTravelOrder"> | number
  }

  export type formProposedBudgetWhereInput = {
    AND?: formProposedBudgetWhereInput | formProposedBudgetWhereInput[]
    OR?: formProposedBudgetWhereInput[]
    NOT?: formProposedBudgetWhereInput | formProposedBudgetWhereInput[]
    id?: IntFilter<"formProposedBudget"> | number
    description?: StringNullableFilter<"formProposedBudget"> | string | null
    budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    total_expenses?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"formProposedBudget"> | string | null
    expense_type?: StringNullableFilter<"formProposedBudget"> | string | null
    month_of?: StringNullableFilter<"formProposedBudget"> | string | null
    createdAt?: DateTimeFilter<"formProposedBudget"> | Date | string
    mainFormId?: IntFilter<"formProposedBudget"> | number
    mainForm?: XOR<MainRequestScalarRelationFilter, MainRequestWhereInput>
  }

  export type formProposedBudgetOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    total_expenses?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    proposed_budget?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    expense_type?: SortOrderInput | SortOrder
    month_of?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
    mainForm?: MainRequestOrderByWithRelationInput
  }

  export type formProposedBudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: formProposedBudgetWhereInput | formProposedBudgetWhereInput[]
    OR?: formProposedBudgetWhereInput[]
    NOT?: formProposedBudgetWhereInput | formProposedBudgetWhereInput[]
    description?: StringNullableFilter<"formProposedBudget"> | string | null
    budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    total_expenses?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"formProposedBudget"> | string | null
    expense_type?: StringNullableFilter<"formProposedBudget"> | string | null
    month_of?: StringNullableFilter<"formProposedBudget"> | string | null
    createdAt?: DateTimeFilter<"formProposedBudget"> | Date | string
    mainFormId?: IntFilter<"formProposedBudget"> | number
    mainForm?: XOR<MainRequestScalarRelationFilter, MainRequestWhereInput>
  }, "id">

  export type formProposedBudgetOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    total_expenses?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    proposed_budget?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    expense_type?: SortOrderInput | SortOrder
    month_of?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
    _count?: formProposedBudgetCountOrderByAggregateInput
    _avg?: formProposedBudgetAvgOrderByAggregateInput
    _max?: formProposedBudgetMaxOrderByAggregateInput
    _min?: formProposedBudgetMinOrderByAggregateInput
    _sum?: formProposedBudgetSumOrderByAggregateInput
  }

  export type formProposedBudgetScalarWhereWithAggregatesInput = {
    AND?: formProposedBudgetScalarWhereWithAggregatesInput | formProposedBudgetScalarWhereWithAggregatesInput[]
    OR?: formProposedBudgetScalarWhereWithAggregatesInput[]
    NOT?: formProposedBudgetScalarWhereWithAggregatesInput | formProposedBudgetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formProposedBudget"> | number
    description?: StringNullableWithAggregatesFilter<"formProposedBudget"> | string | null
    budget?: DecimalNullableWithAggregatesFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    total_expenses?: DecimalNullableWithAggregatesFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableWithAggregatesFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: DecimalNullableWithAggregatesFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableWithAggregatesFilter<"formProposedBudget"> | string | null
    expense_type?: StringNullableWithAggregatesFilter<"formProposedBudget"> | string | null
    month_of?: StringNullableWithAggregatesFilter<"formProposedBudget"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"formProposedBudget"> | Date | string
    mainFormId?: IntWithAggregatesFilter<"formProposedBudget"> | number
  }

  export type formTransmittalMemoWhereInput = {
    AND?: formTransmittalMemoWhereInput | formTransmittalMemoWhereInput[]
    OR?: formTransmittalMemoWhereInput[]
    NOT?: formTransmittalMemoWhereInput | formTransmittalMemoWhereInput[]
    id?: IntFilter<"formTransmittalMemo"> | number
    from?: StringNullableFilter<"formTransmittalMemo"> | string | null
    date?: DateTimeFilter<"formTransmittalMemo"> | Date | string
    description?: StringNullableFilter<"formTransmittalMemo"> | string | null
    note?: StringNullableFilter<"formTransmittalMemo"> | string | null
    items?: JsonNullableFilter<"formTransmittalMemo">
    to_id?: IntNullableFilter<"formTransmittalMemo"> | number | null
    mainFormId?: IntFilter<"formTransmittalMemo"> | number
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }

  export type formTransmittalMemoOrderByWithRelationInput = {
    id?: SortOrder
    from?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    to_id?: SortOrderInput | SortOrder
    mainFormId?: SortOrder
    requestTo?: UserOrderByWithRelationInput
    mainForm?: MainRequestOrderByWithRelationInput
  }

  export type formTransmittalMemoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: formTransmittalMemoWhereInput | formTransmittalMemoWhereInput[]
    OR?: formTransmittalMemoWhereInput[]
    NOT?: formTransmittalMemoWhereInput | formTransmittalMemoWhereInput[]
    from?: StringNullableFilter<"formTransmittalMemo"> | string | null
    date?: DateTimeFilter<"formTransmittalMemo"> | Date | string
    description?: StringNullableFilter<"formTransmittalMemo"> | string | null
    note?: StringNullableFilter<"formTransmittalMemo"> | string | null
    items?: JsonNullableFilter<"formTransmittalMemo">
    to_id?: IntNullableFilter<"formTransmittalMemo"> | number | null
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }, "id" | "mainFormId">

  export type formTransmittalMemoOrderByWithAggregationInput = {
    id?: SortOrder
    from?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    to_id?: SortOrderInput | SortOrder
    mainFormId?: SortOrder
    _count?: formTransmittalMemoCountOrderByAggregateInput
    _avg?: formTransmittalMemoAvgOrderByAggregateInput
    _max?: formTransmittalMemoMaxOrderByAggregateInput
    _min?: formTransmittalMemoMinOrderByAggregateInput
    _sum?: formTransmittalMemoSumOrderByAggregateInput
  }

  export type formTransmittalMemoScalarWhereWithAggregatesInput = {
    AND?: formTransmittalMemoScalarWhereWithAggregatesInput | formTransmittalMemoScalarWhereWithAggregatesInput[]
    OR?: formTransmittalMemoScalarWhereWithAggregatesInput[]
    NOT?: formTransmittalMemoScalarWhereWithAggregatesInput | formTransmittalMemoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formTransmittalMemo"> | number
    from?: StringNullableWithAggregatesFilter<"formTransmittalMemo"> | string | null
    date?: DateTimeWithAggregatesFilter<"formTransmittalMemo"> | Date | string
    description?: StringNullableWithAggregatesFilter<"formTransmittalMemo"> | string | null
    note?: StringNullableWithAggregatesFilter<"formTransmittalMemo"> | string | null
    items?: JsonNullableWithAggregatesFilter<"formTransmittalMemo">
    to_id?: IntNullableWithAggregatesFilter<"formTransmittalMemo"> | number | null
    mainFormId?: IntWithAggregatesFilter<"formTransmittalMemo"> | number
  }

  export type formDisburseWhereInput = {
    AND?: formDisburseWhereInput | formDisburseWhereInput[]
    OR?: formDisburseWhereInput[]
    NOT?: formDisburseWhereInput | formDisburseWhereInput[]
    id?: IntFilter<"formDisburse"> | number
    from?: StringNullableFilter<"formDisburse"> | string | null
    date?: DateTimeFilter<"formDisburse"> | Date | string
    subject?: StringNullableFilter<"formDisburse"> | string | null
    description?: StringNullableFilter<"formDisburse"> | string | null
    note?: StringNullableFilter<"formDisburse"> | string | null
    total_amount?: DecimalNullableFilter<"formDisburse"> | Decimal | DecimalJsLike | number | string | null
    items?: JsonNullableFilter<"formDisburse">
    to_id?: IntNullableFilter<"formDisburse"> | number | null
    mainFormId?: IntFilter<"formDisburse"> | number
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }

  export type formDisburseOrderByWithRelationInput = {
    id?: SortOrder
    from?: SortOrderInput | SortOrder
    date?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    to_id?: SortOrderInput | SortOrder
    mainFormId?: SortOrder
    requestTo?: UserOrderByWithRelationInput
    mainForm?: MainRequestOrderByWithRelationInput
  }

  export type formDisburseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: formDisburseWhereInput | formDisburseWhereInput[]
    OR?: formDisburseWhereInput[]
    NOT?: formDisburseWhereInput | formDisburseWhereInput[]
    from?: StringNullableFilter<"formDisburse"> | string | null
    date?: DateTimeFilter<"formDisburse"> | Date | string
    subject?: StringNullableFilter<"formDisburse"> | string | null
    description?: StringNullableFilter<"formDisburse"> | string | null
    note?: StringNullableFilter<"formDisburse"> | string | null
    total_amount?: DecimalNullableFilter<"formDisburse"> | Decimal | DecimalJsLike | number | string | null
    items?: JsonNullableFilter<"formDisburse">
    to_id?: IntNullableFilter<"formDisburse"> | number | null
    requestTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mainForm?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
  }, "id" | "mainFormId">

  export type formDisburseOrderByWithAggregationInput = {
    id?: SortOrder
    from?: SortOrderInput | SortOrder
    date?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    to_id?: SortOrderInput | SortOrder
    mainFormId?: SortOrder
    _count?: formDisburseCountOrderByAggregateInput
    _avg?: formDisburseAvgOrderByAggregateInput
    _max?: formDisburseMaxOrderByAggregateInput
    _min?: formDisburseMinOrderByAggregateInput
    _sum?: formDisburseSumOrderByAggregateInput
  }

  export type formDisburseScalarWhereWithAggregatesInput = {
    AND?: formDisburseScalarWhereWithAggregatesInput | formDisburseScalarWhereWithAggregatesInput[]
    OR?: formDisburseScalarWhereWithAggregatesInput[]
    NOT?: formDisburseScalarWhereWithAggregatesInput | formDisburseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formDisburse"> | number
    from?: StringNullableWithAggregatesFilter<"formDisburse"> | string | null
    date?: DateTimeWithAggregatesFilter<"formDisburse"> | Date | string
    subject?: StringNullableWithAggregatesFilter<"formDisburse"> | string | null
    description?: StringNullableWithAggregatesFilter<"formDisburse"> | string | null
    note?: StringNullableWithAggregatesFilter<"formDisburse"> | string | null
    total_amount?: DecimalNullableWithAggregatesFilter<"formDisburse"> | Decimal | DecimalJsLike | number | string | null
    items?: JsonNullableWithAggregatesFilter<"formDisburse">
    to_id?: IntNullableWithAggregatesFilter<"formDisburse"> | number | null
    mainFormId?: IntWithAggregatesFilter<"formDisburse"> | number
  }

  export type CountSheetWhereInput = {
    AND?: CountSheetWhereInput | CountSheetWhereInput[]
    OR?: CountSheetWhereInput[]
    NOT?: CountSheetWhereInput | CountSheetWhereInput[]
    id?: IntFilter<"CountSheet"> | number
    fundType?: StringFilter<"CountSheet"> | string
    mainFormId?: IntNullableFilter<"CountSheet"> | number | null
    office?: StringFilter<"CountSheet"> | string
    dateCount?: DateTimeFilter<"CountSheet"> | Date | string
    fundName?: StringFilter<"CountSheet"> | string
    fundAmount?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"CountSheet"> | string | null
    cashDemo?: JsonNullableFilter<"CountSheet">
    repFund?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    cashShort?: DecimalNullableFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    CashCountSheet?: CashFundListRelationFilter
    TravelCountSheet?: TravelFundListRelationFilter
  }

  export type CountSheetOrderByWithRelationInput = {
    id?: SortOrder
    fundType?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    office?: SortOrder
    dateCount?: SortOrder
    fundName?: SortOrder
    fundAmount?: SortOrder
    reference?: SortOrderInput | SortOrder
    cashDemo?: SortOrderInput | SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrderInput | SortOrder
    MaincountSheet?: MainRequestOrderByWithRelationInput
    CashCountSheet?: CashFundOrderByRelationAggregateInput
    TravelCountSheet?: TravelFundOrderByRelationAggregateInput
  }

  export type CountSheetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mainFormId?: number
    AND?: CountSheetWhereInput | CountSheetWhereInput[]
    OR?: CountSheetWhereInput[]
    NOT?: CountSheetWhereInput | CountSheetWhereInput[]
    fundType?: StringFilter<"CountSheet"> | string
    office?: StringFilter<"CountSheet"> | string
    dateCount?: DateTimeFilter<"CountSheet"> | Date | string
    fundName?: StringFilter<"CountSheet"> | string
    fundAmount?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"CountSheet"> | string | null
    cashDemo?: JsonNullableFilter<"CountSheet">
    repFund?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    cashShort?: DecimalNullableFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: XOR<MainRequestNullableScalarRelationFilter, MainRequestWhereInput> | null
    CashCountSheet?: CashFundListRelationFilter
    TravelCountSheet?: TravelFundListRelationFilter
  }, "id" | "mainFormId">

  export type CountSheetOrderByWithAggregationInput = {
    id?: SortOrder
    fundType?: SortOrder
    mainFormId?: SortOrderInput | SortOrder
    office?: SortOrder
    dateCount?: SortOrder
    fundName?: SortOrder
    fundAmount?: SortOrder
    reference?: SortOrderInput | SortOrder
    cashDemo?: SortOrderInput | SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrderInput | SortOrder
    _count?: CountSheetCountOrderByAggregateInput
    _avg?: CountSheetAvgOrderByAggregateInput
    _max?: CountSheetMaxOrderByAggregateInput
    _min?: CountSheetMinOrderByAggregateInput
    _sum?: CountSheetSumOrderByAggregateInput
  }

  export type CountSheetScalarWhereWithAggregatesInput = {
    AND?: CountSheetScalarWhereWithAggregatesInput | CountSheetScalarWhereWithAggregatesInput[]
    OR?: CountSheetScalarWhereWithAggregatesInput[]
    NOT?: CountSheetScalarWhereWithAggregatesInput | CountSheetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CountSheet"> | number
    fundType?: StringWithAggregatesFilter<"CountSheet"> | string
    mainFormId?: IntNullableWithAggregatesFilter<"CountSheet"> | number | null
    office?: StringWithAggregatesFilter<"CountSheet"> | string
    dateCount?: DateTimeWithAggregatesFilter<"CountSheet"> | Date | string
    fundName?: StringWithAggregatesFilter<"CountSheet"> | string
    fundAmount?: DecimalWithAggregatesFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"CountSheet"> | string | null
    cashDemo?: JsonNullableWithAggregatesFilter<"CountSheet">
    repFund?: DecimalWithAggregatesFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalWithAggregatesFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string
    cashShort?: DecimalNullableWithAggregatesFilter<"CountSheet"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundWhereInput = {
    AND?: CashFundWhereInput | CashFundWhereInput[]
    OR?: CashFundWhereInput[]
    NOT?: CashFundWhereInput | CashFundWhereInput[]
    id?: IntFilter<"CashFund"> | number
    countId?: IntNullableFilter<"CashFund"> | number | null
    startDate?: DateTimeFilter<"CashFund"> | Date | string
    endDate?: DateTimeFilter<"CashFund"> | Date | string
    reqDate?: DateTimeFilter<"CashFund"> | Date | string
    payee?: StringFilter<"CashFund"> | string
    remarks?: StringNullableFilter<"CashFund"> | string | null
    fundAmount?: DecimalFilter<"CashFund"> | Decimal | DecimalJsLike | number | string
    miscExp?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    billFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    telFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    dueMh?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    CashSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }

  export type CashFundOrderByWithRelationInput = {
    id?: SortOrder
    countId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    payee?: SortOrder
    remarks?: SortOrderInput | SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrderInput | SortOrder
    billFee?: SortOrderInput | SortOrder
    telFee?: SortOrderInput | SortOrder
    dueMh?: SortOrderInput | SortOrder
    CashSheet?: CountSheetOrderByWithRelationInput
  }

  export type CashFundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CashFundWhereInput | CashFundWhereInput[]
    OR?: CashFundWhereInput[]
    NOT?: CashFundWhereInput | CashFundWhereInput[]
    countId?: IntNullableFilter<"CashFund"> | number | null
    startDate?: DateTimeFilter<"CashFund"> | Date | string
    endDate?: DateTimeFilter<"CashFund"> | Date | string
    reqDate?: DateTimeFilter<"CashFund"> | Date | string
    payee?: StringFilter<"CashFund"> | string
    remarks?: StringNullableFilter<"CashFund"> | string | null
    fundAmount?: DecimalFilter<"CashFund"> | Decimal | DecimalJsLike | number | string
    miscExp?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    billFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    telFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    dueMh?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    CashSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }, "id">

  export type CashFundOrderByWithAggregationInput = {
    id?: SortOrder
    countId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    payee?: SortOrder
    remarks?: SortOrderInput | SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrderInput | SortOrder
    billFee?: SortOrderInput | SortOrder
    telFee?: SortOrderInput | SortOrder
    dueMh?: SortOrderInput | SortOrder
    _count?: CashFundCountOrderByAggregateInput
    _avg?: CashFundAvgOrderByAggregateInput
    _max?: CashFundMaxOrderByAggregateInput
    _min?: CashFundMinOrderByAggregateInput
    _sum?: CashFundSumOrderByAggregateInput
  }

  export type CashFundScalarWhereWithAggregatesInput = {
    AND?: CashFundScalarWhereWithAggregatesInput | CashFundScalarWhereWithAggregatesInput[]
    OR?: CashFundScalarWhereWithAggregatesInput[]
    NOT?: CashFundScalarWhereWithAggregatesInput | CashFundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CashFund"> | number
    countId?: IntNullableWithAggregatesFilter<"CashFund"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"CashFund"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"CashFund"> | Date | string
    reqDate?: DateTimeWithAggregatesFilter<"CashFund"> | Date | string
    payee?: StringWithAggregatesFilter<"CashFund"> | string
    remarks?: StringNullableWithAggregatesFilter<"CashFund"> | string | null
    fundAmount?: DecimalWithAggregatesFilter<"CashFund"> | Decimal | DecimalJsLike | number | string
    miscExp?: DecimalNullableWithAggregatesFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    billFee?: DecimalNullableWithAggregatesFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    telFee?: DecimalNullableWithAggregatesFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    dueMh?: DecimalNullableWithAggregatesFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TravelFundWhereInput = {
    AND?: TravelFundWhereInput | TravelFundWhereInput[]
    OR?: TravelFundWhereInput[]
    NOT?: TravelFundWhereInput | TravelFundWhereInput[]
    id?: IntFilter<"TravelFund"> | number
    countId?: IntNullableFilter<"TravelFund"> | number | null
    tagsField?: StringNullableListFilter<"TravelFund">
    startDate?: DateTimeFilter<"TravelFund"> | Date | string
    endDate?: DateTimeFilter<"TravelFund"> | Date | string
    reqDate?: DateTimeFilter<"TravelFund"> | Date | string
    travelling?: StringNullableFilter<"TravelFund"> | string | null
    fuel?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    repair?: StringNullableListFilter<"TravelFund">
    litigation?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string
    kilometer?: StringNullableFilter<"TravelFund"> | string | null
    remarks?: StringNullableFilter<"TravelFund"> | string | null
    TravelSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }

  export type TravelFundOrderByWithRelationInput = {
    id?: SortOrder
    countId?: SortOrderInput | SortOrder
    tagsField?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    travelling?: SortOrderInput | SortOrder
    fuel?: SortOrderInput | SortOrder
    repair?: SortOrder
    litigation?: SortOrderInput | SortOrder
    totalFee?: SortOrder
    kilometer?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    TravelSheet?: CountSheetOrderByWithRelationInput
  }

  export type TravelFundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TravelFundWhereInput | TravelFundWhereInput[]
    OR?: TravelFundWhereInput[]
    NOT?: TravelFundWhereInput | TravelFundWhereInput[]
    countId?: IntNullableFilter<"TravelFund"> | number | null
    tagsField?: StringNullableListFilter<"TravelFund">
    startDate?: DateTimeFilter<"TravelFund"> | Date | string
    endDate?: DateTimeFilter<"TravelFund"> | Date | string
    reqDate?: DateTimeFilter<"TravelFund"> | Date | string
    travelling?: StringNullableFilter<"TravelFund"> | string | null
    fuel?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    repair?: StringNullableListFilter<"TravelFund">
    litigation?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string
    kilometer?: StringNullableFilter<"TravelFund"> | string | null
    remarks?: StringNullableFilter<"TravelFund"> | string | null
    TravelSheet?: XOR<CountSheetNullableScalarRelationFilter, CountSheetWhereInput> | null
  }, "id">

  export type TravelFundOrderByWithAggregationInput = {
    id?: SortOrder
    countId?: SortOrderInput | SortOrder
    tagsField?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    travelling?: SortOrderInput | SortOrder
    fuel?: SortOrderInput | SortOrder
    repair?: SortOrder
    litigation?: SortOrderInput | SortOrder
    totalFee?: SortOrder
    kilometer?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: TravelFundCountOrderByAggregateInput
    _avg?: TravelFundAvgOrderByAggregateInput
    _max?: TravelFundMaxOrderByAggregateInput
    _min?: TravelFundMinOrderByAggregateInput
    _sum?: TravelFundSumOrderByAggregateInput
  }

  export type TravelFundScalarWhereWithAggregatesInput = {
    AND?: TravelFundScalarWhereWithAggregatesInput | TravelFundScalarWhereWithAggregatesInput[]
    OR?: TravelFundScalarWhereWithAggregatesInput[]
    NOT?: TravelFundScalarWhereWithAggregatesInput | TravelFundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TravelFund"> | number
    countId?: IntNullableWithAggregatesFilter<"TravelFund"> | number | null
    tagsField?: StringNullableListFilter<"TravelFund">
    startDate?: DateTimeWithAggregatesFilter<"TravelFund"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TravelFund"> | Date | string
    reqDate?: DateTimeWithAggregatesFilter<"TravelFund"> | Date | string
    travelling?: StringNullableWithAggregatesFilter<"TravelFund"> | string | null
    fuel?: DecimalNullableWithAggregatesFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    repair?: StringNullableListFilter<"TravelFund">
    litigation?: DecimalNullableWithAggregatesFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalWithAggregatesFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string
    kilometer?: StringNullableWithAggregatesFilter<"TravelFund"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"TravelFund"> | string | null
  }

  export type UserCreateInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    main?: MainRequestCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    main?: MainRequestUncheckedCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUpdateInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    main?: MainRequestUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    main?: MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeCreateInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUpdateInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeCreateManyInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeUpdateManyMutationInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestCreateInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUpdateInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestCreateManyInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestUpdateManyMutationInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferCreateInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutFundTransferInput
    requestTo?: UserCreateNestedOneWithoutFormRequestFundToInput
  }

  export type FormFundTransferUncheckedCreateInput = {
    id?: number
    mainRequestID?: number | null
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferUpdateInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutFundTransferNestedInput
    requestTo?: UserUpdateOneWithoutFormRequestFundToNestedInput
  }

  export type FormFundTransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferCreateManyInput = {
    id?: number
    mainRequestID?: number | null
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferUpdateManyMutationInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableCreateInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutApprovalInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUpdateInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutApprovalNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableCreateManyInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovalTableUpdateManyMutationInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateInput = {
    checkerType: string
    action: string
    createdAt?: Date | string
    approval?: ApprovalTableCreateNestedOneWithoutRequestLogsInput
    approver?: UserCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    approverId?: number | null
    action: string
    createdAt?: Date | string
  }

  export type RequestLogsUpdateInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUpdateOneWithoutRequestLogsNestedInput
    approver?: UserUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateManyInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    approverId?: number | null
    action: string
    createdAt?: Date | string
  }

  export type RequestLogsUpdateManyMutationInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formTravelOrderCreateInput = {
    name?: string | null
    position?: string | null
    departure_date: Date | string
    current_date: Date | string
    destination?: string | null
    purpose_of_travel?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    mainForm?: MainRequestCreateNestedOneWithoutTravelOrderInput
  }

  export type formTravelOrderUncheckedCreateInput = {
    id?: number
    name?: string | null
    position?: string | null
    departure_date: Date | string
    current_date: Date | string
    destination?: string | null
    purpose_of_travel?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    mainFormId: number
  }

  export type formTravelOrderUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainForm?: MainRequestUpdateOneWithoutTravelOrderNestedInput
  }

  export type formTravelOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formTravelOrderCreateManyInput = {
    id?: number
    name?: string | null
    position?: string | null
    departure_date: Date | string
    current_date: Date | string
    destination?: string | null
    purpose_of_travel?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    mainFormId: number
  }

  export type formTravelOrderUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formTravelOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formProposedBudgetCreateInput = {
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
    mainForm: MainRequestCreateNestedOneWithoutProposedBudgetInput
  }

  export type formProposedBudgetUncheckedCreateInput = {
    id?: number
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
    mainFormId: number
  }

  export type formProposedBudgetUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainForm?: MainRequestUpdateOneRequiredWithoutProposedBudgetNestedInput
  }

  export type formProposedBudgetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formProposedBudgetCreateManyInput = {
    id?: number
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
    mainFormId: number
  }

  export type formProposedBudgetUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formProposedBudgetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formTransmittalMemoCreateInput = {
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserCreateNestedOneWithoutFormRequestTransmittalToInput
    mainForm?: MainRequestCreateNestedOneWithoutTransmittalMemoInput
  }

  export type formTransmittalMemoUncheckedCreateInput = {
    id?: number
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
    mainFormId: number
  }

  export type formTransmittalMemoUpdateInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserUpdateOneWithoutFormRequestTransmittalToNestedInput
    mainForm?: MainRequestUpdateOneWithoutTransmittalMemoNestedInput
  }

  export type formTransmittalMemoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formTransmittalMemoCreateManyInput = {
    id?: number
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
    mainFormId: number
  }

  export type formTransmittalMemoUpdateManyMutationInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type formTransmittalMemoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formDisburseCreateInput = {
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserCreateNestedOneWithoutFormRequestDisburseToInput
    mainForm?: MainRequestCreateNestedOneWithoutDisburseInput
  }

  export type formDisburseUncheckedCreateInput = {
    id?: number
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
    mainFormId: number
  }

  export type formDisburseUpdateInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserUpdateOneWithoutFormRequestDisburseToNestedInput
    mainForm?: MainRequestUpdateOneWithoutDisburseNestedInput
  }

  export type formDisburseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formDisburseCreateManyInput = {
    id?: number
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
    mainFormId: number
  }

  export type formDisburseUpdateManyMutationInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type formDisburseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type CountSheetCreateInput = {
    fundType: string
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestCreateNestedOneWithoutCountSheetInput
    CashCountSheet?: CashFundCreateNestedManyWithoutCashSheetInput
    TravelCountSheet?: TravelFundCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetUncheckedCreateInput = {
    id?: number
    fundType: string
    mainFormId?: number | null
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedCreateNestedManyWithoutCashSheetInput
    TravelCountSheet?: TravelFundUncheckedCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetUpdateInput = {
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestUpdateOneWithoutCountSheetNestedInput
    CashCountSheet?: CashFundUpdateManyWithoutCashSheetNestedInput
    TravelCountSheet?: TravelFundUpdateManyWithoutTravelSheetNestedInput
  }

  export type CountSheetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundType?: StringFieldUpdateOperationsInput | string
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedUpdateManyWithoutCashSheetNestedInput
    TravelCountSheet?: TravelFundUncheckedUpdateManyWithoutTravelSheetNestedInput
  }

  export type CountSheetCreateManyInput = {
    id?: number
    fundType: string
    mainFormId?: number | null
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
  }

  export type CountSheetUpdateManyMutationInput = {
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CountSheetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundType?: StringFieldUpdateOperationsInput | string
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundCreateInput = {
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
    CashSheet?: CountSheetCreateNestedOneWithoutCashCountSheetInput
  }

  export type CashFundUncheckedCreateInput = {
    id?: number
    countId?: number | null
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CashSheet?: CountSheetUpdateOneWithoutCashCountSheetNestedInput
  }

  export type CashFundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundCreateManyInput = {
    id?: number
    countId?: number | null
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countId?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TravelFundCreateInput = {
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
    TravelSheet?: CountSheetCreateNestedOneWithoutTravelCountSheetInput
  }

  export type TravelFundUncheckedCreateInput = {
    id?: number
    countId?: number | null
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
  }

  export type TravelFundUpdateInput = {
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    TravelSheet?: CountSheetUpdateOneWithoutTravelCountSheetNestedInput
  }

  export type TravelFundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countId?: NullableIntFieldUpdateOperationsInput | number | null
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TravelFundCreateManyInput = {
    id?: number
    countId?: number | null
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
  }

  export type TravelFundUpdateManyMutationInput = {
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TravelFundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countId?: NullableIntFieldUpdateOperationsInput | number | null
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type RequestTypeListRelationFilter = {
    every?: RequestTypeWhereInput
    some?: RequestTypeWhereInput
    none?: RequestTypeWhereInput
  }

  export type FormFundTransferListRelationFilter = {
    every?: FormFundTransferWhereInput
    some?: FormFundTransferWhereInput
    none?: FormFundTransferWhereInput
  }

  export type FormTransmittalMemoListRelationFilter = {
    every?: formTransmittalMemoWhereInput
    some?: formTransmittalMemoWhereInput
    none?: formTransmittalMemoWhereInput
  }

  export type FormDisburseListRelationFilter = {
    every?: formDisburseWhereInput
    some?: formDisburseWhereInput
    none?: formDisburseWhereInput
  }

  export type RequestLogsListRelationFilter = {
    every?: RequestLogsWhereInput
    some?: RequestLogsWhereInput
    none?: RequestLogsWhereInput
  }

  export type MainRequestListRelationFilter = {
    every?: MainRequestWhereInput
    some?: MainRequestWhereInput
    none?: MainRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RequestTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormFundTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formTransmittalMemoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formDisburseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    signatureUrl?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    approver?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    signatureUrl?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    approver?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    signatureUrl?: SortOrder
    position?: SortOrder
    initial?: SortOrder
    approver?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    branchCode?: SortOrder
    branchName?: SortOrder
    bom?: SortOrder
    faa?: SortOrder
    telephone?: SortOrder
    address?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RequestTypeCountOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
  }

  export type RequestTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeMinOrderByAggregateInput = {
    id?: SortOrder
    requestName?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RequestTypeSumOrderByAggregateInput = {
    id?: SortOrder
    notedById?: SortOrder
    checkedById?: SortOrder
    checkedBy2Id?: SortOrder
    recomApprovalId?: SortOrder
    recomApproval2Id?: SortOrder
    approveById?: SortOrder
  }

  export type EnumStatusesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesFilter<$PrismaModel> | $Enums.Statuses
  }

  export type RequestTypeNullableScalarRelationFilter = {
    is?: RequestTypeWhereInput | null
    isNot?: RequestTypeWhereInput | null
  }

  export type FormFundTransferNullableScalarRelationFilter = {
    is?: FormFundTransferWhereInput | null
    isNot?: FormFundTransferWhereInput | null
  }

  export type ApprovalTableListRelationFilter = {
    every?: ApprovalTableWhereInput
    some?: ApprovalTableWhereInput
    none?: ApprovalTableWhereInput
  }

  export type FormTravelOrderNullableScalarRelationFilter = {
    is?: formTravelOrderWhereInput | null
    isNot?: formTravelOrderWhereInput | null
  }

  export type FormTransmittalMemoNullableScalarRelationFilter = {
    is?: formTransmittalMemoWhereInput | null
    isNot?: formTransmittalMemoWhereInput | null
  }

  export type FormProposedBudgetListRelationFilter = {
    every?: formProposedBudgetWhereInput
    some?: formProposedBudgetWhereInput
    none?: formProposedBudgetWhereInput
  }

  export type FormDisburseNullableScalarRelationFilter = {
    is?: formDisburseWhereInput | null
    isNot?: formDisburseWhereInput | null
  }

  export type CountSheetNullableScalarRelationFilter = {
    is?: CountSheetWhereInput | null
    isNot?: CountSheetWhereInput | null
  }

  export type ApprovalTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formProposedBudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainRequestCountOrderByAggregateInput = {
    id?: SortOrder
    referenceCode?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
  }

  export type MainRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceCode?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestMinOrderByAggregateInput = {
    id?: SortOrder
    referenceCode?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainRequestSumOrderByAggregateInput = {
    id?: SortOrder
    requestTypeId?: SortOrder
    requestById?: SortOrder
    requestFromId?: SortOrder
  }

  export type EnumStatusesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesWithAggregatesFilter<$PrismaModel> | $Enums.Statuses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusesFilter<$PrismaModel>
    _max?: NestedEnumStatusesFilter<$PrismaModel>
  }

  export type MainRequestNullableScalarRelationFilter = {
    is?: MainRequestWhereInput | null
    isNot?: MainRequestWhereInput | null
  }

  export type FormFundTransferCountOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferAvgOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
  }

  export type FormFundTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferMinOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
    requestContent?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FormFundTransferSumOrderByAggregateInput = {
    id?: SortOrder
    mainRequestID?: SortOrder
    requestToId?: SortOrder
  }

  export type ApprovalTableCountOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableAvgOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
  }

  export type ApprovalTableMaxOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableMinOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    notedBy?: SortOrder
    checkedBy?: SortOrder
    checkedBy2?: SortOrder
    recomApproval?: SortOrder
    recomApproval2?: SortOrder
    approveBy?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ApprovalTableSumOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
  }

  export type ApprovalTableNullableScalarRelationFilter = {
    is?: ApprovalTableWhereInput | null
    isNot?: ApprovalTableWhereInput | null
  }

  export type RequestLogsCountOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    approverId?: SortOrder
  }

  export type RequestLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsMinOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    checkerType?: SortOrder
    approverId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestLogsSumOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    approverId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type formTravelOrderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    departure_date?: SortOrder
    current_date?: SortOrder
    destination?: SortOrder
    purpose_of_travel?: SortOrder
    items?: SortOrder
    total_amount?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTravelOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTravelOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    departure_date?: SortOrder
    current_date?: SortOrder
    destination?: SortOrder
    purpose_of_travel?: SortOrder
    total_amount?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTravelOrderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    departure_date?: SortOrder
    current_date?: SortOrder
    destination?: SortOrder
    purpose_of_travel?: SortOrder
    total_amount?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTravelOrderSumOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    mainFormId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type MainRequestScalarRelationFilter = {
    is?: MainRequestWhereInput
    isNot?: MainRequestWhereInput
  }

  export type formProposedBudgetCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    total_expenses?: SortOrder
    variance?: SortOrder
    proposed_budget?: SortOrder
    remarks?: SortOrder
    expense_type?: SortOrder
    month_of?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formProposedBudgetAvgOrderByAggregateInput = {
    id?: SortOrder
    budget?: SortOrder
    total_expenses?: SortOrder
    variance?: SortOrder
    proposed_budget?: SortOrder
    mainFormId?: SortOrder
  }

  export type formProposedBudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    total_expenses?: SortOrder
    variance?: SortOrder
    proposed_budget?: SortOrder
    remarks?: SortOrder
    expense_type?: SortOrder
    month_of?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formProposedBudgetMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    total_expenses?: SortOrder
    variance?: SortOrder
    proposed_budget?: SortOrder
    remarks?: SortOrder
    expense_type?: SortOrder
    month_of?: SortOrder
    createdAt?: SortOrder
    mainFormId?: SortOrder
  }

  export type formProposedBudgetSumOrderByAggregateInput = {
    id?: SortOrder
    budget?: SortOrder
    total_expenses?: SortOrder
    variance?: SortOrder
    proposed_budget?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTransmittalMemoCountOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    description?: SortOrder
    note?: SortOrder
    items?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTransmittalMemoAvgOrderByAggregateInput = {
    id?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTransmittalMemoMaxOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    description?: SortOrder
    note?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTransmittalMemoMinOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    description?: SortOrder
    note?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formTransmittalMemoSumOrderByAggregateInput = {
    id?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formDisburseCountOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    items?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formDisburseAvgOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formDisburseMaxOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formDisburseMinOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    note?: SortOrder
    total_amount?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type formDisburseSumOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    to_id?: SortOrder
    mainFormId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CashFundListRelationFilter = {
    every?: CashFundWhereInput
    some?: CashFundWhereInput
    none?: CashFundWhereInput
  }

  export type TravelFundListRelationFilter = {
    every?: TravelFundWhereInput
    some?: TravelFundWhereInput
    none?: TravelFundWhereInput
  }

  export type CashFundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TravelFundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountSheetCountOrderByAggregateInput = {
    id?: SortOrder
    fundType?: SortOrder
    mainFormId?: SortOrder
    office?: SortOrder
    dateCount?: SortOrder
    fundName?: SortOrder
    fundAmount?: SortOrder
    reference?: SortOrder
    cashDemo?: SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrder
  }

  export type CountSheetAvgOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    fundAmount?: SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrder
  }

  export type CountSheetMaxOrderByAggregateInput = {
    id?: SortOrder
    fundType?: SortOrder
    mainFormId?: SortOrder
    office?: SortOrder
    dateCount?: SortOrder
    fundName?: SortOrder
    fundAmount?: SortOrder
    reference?: SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrder
  }

  export type CountSheetMinOrderByAggregateInput = {
    id?: SortOrder
    fundType?: SortOrder
    mainFormId?: SortOrder
    office?: SortOrder
    dateCount?: SortOrder
    fundName?: SortOrder
    fundAmount?: SortOrder
    reference?: SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrder
  }

  export type CountSheetSumOrderByAggregateInput = {
    id?: SortOrder
    mainFormId?: SortOrder
    fundAmount?: SortOrder
    repFund?: SortOrder
    totalFund?: SortOrder
    cashShort?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CashFundCountOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    payee?: SortOrder
    remarks?: SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrder
    billFee?: SortOrder
    telFee?: SortOrder
    dueMh?: SortOrder
  }

  export type CashFundAvgOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrder
    billFee?: SortOrder
    telFee?: SortOrder
    dueMh?: SortOrder
  }

  export type CashFundMaxOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    payee?: SortOrder
    remarks?: SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrder
    billFee?: SortOrder
    telFee?: SortOrder
    dueMh?: SortOrder
  }

  export type CashFundMinOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    payee?: SortOrder
    remarks?: SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrder
    billFee?: SortOrder
    telFee?: SortOrder
    dueMh?: SortOrder
  }

  export type CashFundSumOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    fundAmount?: SortOrder
    miscExp?: SortOrder
    billFee?: SortOrder
    telFee?: SortOrder
    dueMh?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TravelFundCountOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    tagsField?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    travelling?: SortOrder
    fuel?: SortOrder
    repair?: SortOrder
    litigation?: SortOrder
    totalFee?: SortOrder
    kilometer?: SortOrder
    remarks?: SortOrder
  }

  export type TravelFundAvgOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    fuel?: SortOrder
    litigation?: SortOrder
    totalFee?: SortOrder
  }

  export type TravelFundMaxOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    travelling?: SortOrder
    fuel?: SortOrder
    litigation?: SortOrder
    totalFee?: SortOrder
    kilometer?: SortOrder
    remarks?: SortOrder
  }

  export type TravelFundMinOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reqDate?: SortOrder
    travelling?: SortOrder
    fuel?: SortOrder
    litigation?: SortOrder
    totalFee?: SortOrder
    kilometer?: SortOrder
    remarks?: SortOrder
  }

  export type TravelFundSumOrderByAggregateInput = {
    id?: SortOrder
    countId?: SortOrder
    fuel?: SortOrder
    litigation?: SortOrder
    totalFee?: SortOrder
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type RequestTypeCreateNestedManyWithoutNotedByInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutCheckedBy2Input = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutRecomApprovalInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutRecomApproval2Input = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeCreateNestedManyWithoutApproveByInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type FormFundTransferCreateNestedManyWithoutRequestToInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
  }

  export type formTransmittalMemoCreateNestedManyWithoutRequestToInput = {
    create?: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput> | formTransmittalMemoCreateWithoutRequestToInput[] | formTransmittalMemoUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutRequestToInput | formTransmittalMemoCreateOrConnectWithoutRequestToInput[]
    createMany?: formTransmittalMemoCreateManyRequestToInputEnvelope
    connect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
  }

  export type formDisburseCreateNestedManyWithoutRequestToInput = {
    create?: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput> | formDisburseCreateWithoutRequestToInput[] | formDisburseUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formDisburseCreateOrConnectWithoutRequestToInput | formDisburseCreateOrConnectWithoutRequestToInput[]
    createMany?: formDisburseCreateManyRequestToInputEnvelope
    connect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
  }

  export type RequestLogsCreateNestedManyWithoutApproverInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type MainRequestCreateNestedManyWithoutRequestByInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutNotedByInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type RequestTypeUncheckedCreateNestedManyWithoutApproveByInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
  }

  export type FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
  }

  export type formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput = {
    create?: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput> | formTransmittalMemoCreateWithoutRequestToInput[] | formTransmittalMemoUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutRequestToInput | formTransmittalMemoCreateOrConnectWithoutRequestToInput[]
    createMany?: formTransmittalMemoCreateManyRequestToInputEnvelope
    connect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
  }

  export type formDisburseUncheckedCreateNestedManyWithoutRequestToInput = {
    create?: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput> | formDisburseCreateWithoutRequestToInput[] | formDisburseUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formDisburseCreateOrConnectWithoutRequestToInput | formDisburseCreateOrConnectWithoutRequestToInput[]
    createMany?: formDisburseCreateManyRequestToInputEnvelope
    connect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
  }

  export type RequestLogsUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestByInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type RequestTypeUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutNotedByInput | RequestTypeUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutNotedByInput | RequestTypeUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutNotedByInput | RequestTypeUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput | RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput | RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedByInput | RequestTypeUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutCheckedBy2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input | RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutRecomApprovalNestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput | RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutRecomApproval2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input | RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUpdateManyWithoutApproveByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutApproveByInput | RequestTypeUpsertWithWhereUniqueWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutApproveByInput | RequestTypeUpdateWithWhereUniqueWithoutApproveByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutApproveByInput | RequestTypeUpdateManyWithWhereWithoutApproveByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type FormFundTransferUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    upsert?: FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput | FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    set?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    disconnect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    delete?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    update?: FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput | FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: FormFundTransferUpdateManyWithWhereWithoutRequestToInput | FormFundTransferUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
  }

  export type formTransmittalMemoUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput> | formTransmittalMemoCreateWithoutRequestToInput[] | formTransmittalMemoUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutRequestToInput | formTransmittalMemoCreateOrConnectWithoutRequestToInput[]
    upsert?: formTransmittalMemoUpsertWithWhereUniqueWithoutRequestToInput | formTransmittalMemoUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: formTransmittalMemoCreateManyRequestToInputEnvelope
    set?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    disconnect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    delete?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    connect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    update?: formTransmittalMemoUpdateWithWhereUniqueWithoutRequestToInput | formTransmittalMemoUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: formTransmittalMemoUpdateManyWithWhereWithoutRequestToInput | formTransmittalMemoUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: formTransmittalMemoScalarWhereInput | formTransmittalMemoScalarWhereInput[]
  }

  export type formDisburseUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput> | formDisburseCreateWithoutRequestToInput[] | formDisburseUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formDisburseCreateOrConnectWithoutRequestToInput | formDisburseCreateOrConnectWithoutRequestToInput[]
    upsert?: formDisburseUpsertWithWhereUniqueWithoutRequestToInput | formDisburseUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: formDisburseCreateManyRequestToInputEnvelope
    set?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    disconnect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    delete?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    connect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    update?: formDisburseUpdateWithWhereUniqueWithoutRequestToInput | formDisburseUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: formDisburseUpdateManyWithWhereWithoutRequestToInput | formDisburseUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: formDisburseScalarWhereInput | formDisburseScalarWhereInput[]
  }

  export type RequestLogsUpdateManyWithoutApproverNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApproverInput | RequestLogsUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApproverInput | RequestLogsUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApproverInput | RequestLogsUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type MainRequestUpdateManyWithoutRequestByNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestByInput | MainRequestUpsertWithWhereUniqueWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestByInput | MainRequestUpdateWithWhereUniqueWithoutRequestByInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestByInput | MainRequestUpdateManyWithWhereWithoutRequestByInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput> | RequestTypeCreateWithoutNotedByInput[] | RequestTypeUncheckedCreateWithoutNotedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutNotedByInput | RequestTypeCreateOrConnectWithoutNotedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutNotedByInput | RequestTypeUpsertWithWhereUniqueWithoutNotedByInput[]
    createMany?: RequestTypeCreateManyNotedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutNotedByInput | RequestTypeUpdateWithWhereUniqueWithoutNotedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutNotedByInput | RequestTypeUpdateManyWithWhereWithoutNotedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput> | RequestTypeCreateWithoutCheckedByInput[] | RequestTypeUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedByInput | RequestTypeCreateOrConnectWithoutCheckedByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput | RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RequestTypeCreateManyCheckedByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput | RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedByInput | RequestTypeUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input> | RequestTypeCreateWithoutCheckedBy2Input[] | RequestTypeUncheckedCreateWithoutCheckedBy2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutCheckedBy2Input | RequestTypeCreateOrConnectWithoutCheckedBy2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input[]
    createMany?: RequestTypeCreateManyCheckedBy2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input | RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input | RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput> | RequestTypeCreateWithoutRecomApprovalInput[] | RequestTypeUncheckedCreateWithoutRecomApprovalInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApprovalInput | RequestTypeCreateOrConnectWithoutRecomApprovalInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput[]
    createMany?: RequestTypeCreateManyRecomApprovalInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput | RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput | RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput = {
    create?: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input> | RequestTypeCreateWithoutRecomApproval2Input[] | RequestTypeUncheckedCreateWithoutRecomApproval2Input[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutRecomApproval2Input | RequestTypeCreateOrConnectWithoutRecomApproval2Input[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input[]
    createMany?: RequestTypeCreateManyRecomApproval2InputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input | RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input | RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput = {
    create?: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput> | RequestTypeCreateWithoutApproveByInput[] | RequestTypeUncheckedCreateWithoutApproveByInput[]
    connectOrCreate?: RequestTypeCreateOrConnectWithoutApproveByInput | RequestTypeCreateOrConnectWithoutApproveByInput[]
    upsert?: RequestTypeUpsertWithWhereUniqueWithoutApproveByInput | RequestTypeUpsertWithWhereUniqueWithoutApproveByInput[]
    createMany?: RequestTypeCreateManyApproveByInputEnvelope
    set?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    disconnect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    delete?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    connect?: RequestTypeWhereUniqueInput | RequestTypeWhereUniqueInput[]
    update?: RequestTypeUpdateWithWhereUniqueWithoutApproveByInput | RequestTypeUpdateWithWhereUniqueWithoutApproveByInput[]
    updateMany?: RequestTypeUpdateManyWithWhereWithoutApproveByInput | RequestTypeUpdateManyWithWhereWithoutApproveByInput[]
    deleteMany?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
  }

  export type FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput> | FormFundTransferCreateWithoutRequestToInput[] | FormFundTransferUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutRequestToInput | FormFundTransferCreateOrConnectWithoutRequestToInput[]
    upsert?: FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput | FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: FormFundTransferCreateManyRequestToInputEnvelope
    set?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    disconnect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    delete?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    connect?: FormFundTransferWhereUniqueInput | FormFundTransferWhereUniqueInput[]
    update?: FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput | FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: FormFundTransferUpdateManyWithWhereWithoutRequestToInput | FormFundTransferUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
  }

  export type formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput> | formTransmittalMemoCreateWithoutRequestToInput[] | formTransmittalMemoUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutRequestToInput | formTransmittalMemoCreateOrConnectWithoutRequestToInput[]
    upsert?: formTransmittalMemoUpsertWithWhereUniqueWithoutRequestToInput | formTransmittalMemoUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: formTransmittalMemoCreateManyRequestToInputEnvelope
    set?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    disconnect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    delete?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    connect?: formTransmittalMemoWhereUniqueInput | formTransmittalMemoWhereUniqueInput[]
    update?: formTransmittalMemoUpdateWithWhereUniqueWithoutRequestToInput | formTransmittalMemoUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: formTransmittalMemoUpdateManyWithWhereWithoutRequestToInput | formTransmittalMemoUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: formTransmittalMemoScalarWhereInput | formTransmittalMemoScalarWhereInput[]
  }

  export type formDisburseUncheckedUpdateManyWithoutRequestToNestedInput = {
    create?: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput> | formDisburseCreateWithoutRequestToInput[] | formDisburseUncheckedCreateWithoutRequestToInput[]
    connectOrCreate?: formDisburseCreateOrConnectWithoutRequestToInput | formDisburseCreateOrConnectWithoutRequestToInput[]
    upsert?: formDisburseUpsertWithWhereUniqueWithoutRequestToInput | formDisburseUpsertWithWhereUniqueWithoutRequestToInput[]
    createMany?: formDisburseCreateManyRequestToInputEnvelope
    set?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    disconnect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    delete?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    connect?: formDisburseWhereUniqueInput | formDisburseWhereUniqueInput[]
    update?: formDisburseUpdateWithWhereUniqueWithoutRequestToInput | formDisburseUpdateWithWhereUniqueWithoutRequestToInput[]
    updateMany?: formDisburseUpdateManyWithWhereWithoutRequestToInput | formDisburseUpdateManyWithWhereWithoutRequestToInput[]
    deleteMany?: formDisburseScalarWhereInput | formDisburseScalarWhereInput[]
  }

  export type RequestLogsUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput> | RequestLogsCreateWithoutApproverInput[] | RequestLogsUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApproverInput | RequestLogsCreateOrConnectWithoutApproverInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApproverInput | RequestLogsUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: RequestLogsCreateManyApproverInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApproverInput | RequestLogsUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApproverInput | RequestLogsUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestByNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput> | MainRequestCreateWithoutRequestByInput[] | MainRequestUncheckedCreateWithoutRequestByInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestByInput | MainRequestCreateOrConnectWithoutRequestByInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestByInput | MainRequestUpsertWithWhereUniqueWithoutRequestByInput[]
    createMany?: MainRequestCreateManyRequestByInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestByInput | MainRequestUpdateWithWhereUniqueWithoutRequestByInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestByInput | MainRequestUpdateManyWithWhereWithoutRequestByInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MainRequestCreateNestedManyWithoutRequestFromInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestFromInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MainRequestUpdateManyWithoutRequestFromNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestFromInput | MainRequestUpsertWithWhereUniqueWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestFromInput | MainRequestUpdateWithWhereUniqueWithoutRequestFromInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestFromInput | MainRequestUpdateManyWithWhereWithoutRequestFromInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput> | MainRequestCreateWithoutRequestFromInput[] | MainRequestUncheckedCreateWithoutRequestFromInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestFromInput | MainRequestCreateOrConnectWithoutRequestFromInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestFromInput | MainRequestUpsertWithWhereUniqueWithoutRequestFromInput[]
    createMany?: MainRequestCreateManyRequestFromInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestFromInput | MainRequestUpdateWithWhereUniqueWithoutRequestFromInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestFromInput | MainRequestUpdateManyWithWhereWithoutRequestFromInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotedByForTypesInput = {
    create?: XOR<UserCreateWithoutNotedByForTypesInput, UserUncheckedCreateWithoutNotedByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotedByForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCheckedByForTypesInput = {
    create?: XOR<UserCreateWithoutCheckedByForTypesInput, UserUncheckedCreateWithoutCheckedByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckedByForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCheckedBy2ForTypesInput = {
    create?: XOR<UserCreateWithoutCheckedBy2ForTypesInput, UserUncheckedCreateWithoutCheckedBy2ForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckedBy2ForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecomApprovalForTypesInput = {
    create?: XOR<UserCreateWithoutRecomApprovalForTypesInput, UserUncheckedCreateWithoutRecomApprovalForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecomApprovalForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecomApproval2ForTypesInput = {
    create?: XOR<UserCreateWithoutRecomApproval2ForTypesInput, UserUncheckedCreateWithoutRecomApproval2ForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecomApproval2ForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApproveByForTypesInput = {
    create?: XOR<UserCreateWithoutApproveByForTypesInput, UserUncheckedCreateWithoutApproveByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproveByForTypesInput
    connect?: UserWhereUniqueInput
  }

  export type MainRequestCreateNestedManyWithoutRequestTypeInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutNotedByForTypesNestedInput = {
    create?: XOR<UserCreateWithoutNotedByForTypesInput, UserUncheckedCreateWithoutNotedByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotedByForTypesInput
    upsert?: UserUpsertWithoutNotedByForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotedByForTypesInput, UserUpdateWithoutNotedByForTypesInput>, UserUncheckedUpdateWithoutNotedByForTypesInput>
  }

  export type UserUpdateOneWithoutCheckedByForTypesNestedInput = {
    create?: XOR<UserCreateWithoutCheckedByForTypesInput, UserUncheckedCreateWithoutCheckedByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckedByForTypesInput
    upsert?: UserUpsertWithoutCheckedByForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckedByForTypesInput, UserUpdateWithoutCheckedByForTypesInput>, UserUncheckedUpdateWithoutCheckedByForTypesInput>
  }

  export type UserUpdateOneWithoutCheckedBy2ForTypesNestedInput = {
    create?: XOR<UserCreateWithoutCheckedBy2ForTypesInput, UserUncheckedCreateWithoutCheckedBy2ForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckedBy2ForTypesInput
    upsert?: UserUpsertWithoutCheckedBy2ForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckedBy2ForTypesInput, UserUpdateWithoutCheckedBy2ForTypesInput>, UserUncheckedUpdateWithoutCheckedBy2ForTypesInput>
  }

  export type UserUpdateOneWithoutRecomApprovalForTypesNestedInput = {
    create?: XOR<UserCreateWithoutRecomApprovalForTypesInput, UserUncheckedCreateWithoutRecomApprovalForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecomApprovalForTypesInput
    upsert?: UserUpsertWithoutRecomApprovalForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecomApprovalForTypesInput, UserUpdateWithoutRecomApprovalForTypesInput>, UserUncheckedUpdateWithoutRecomApprovalForTypesInput>
  }

  export type UserUpdateOneWithoutRecomApproval2ForTypesNestedInput = {
    create?: XOR<UserCreateWithoutRecomApproval2ForTypesInput, UserUncheckedCreateWithoutRecomApproval2ForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecomApproval2ForTypesInput
    upsert?: UserUpsertWithoutRecomApproval2ForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecomApproval2ForTypesInput, UserUpdateWithoutRecomApproval2ForTypesInput>, UserUncheckedUpdateWithoutRecomApproval2ForTypesInput>
  }

  export type UserUpdateOneWithoutApproveByForTypesNestedInput = {
    create?: XOR<UserCreateWithoutApproveByForTypesInput, UserUncheckedCreateWithoutApproveByForTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproveByForTypesInput
    upsert?: UserUpsertWithoutApproveByForTypesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApproveByForTypesInput, UserUpdateWithoutApproveByForTypesInput>, UserUncheckedUpdateWithoutApproveByForTypesInput>
  }

  export type MainRequestUpdateManyWithoutRequestTypeNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput | MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput | MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestTypeInput | MainRequestUpdateManyWithWhereWithoutRequestTypeInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput = {
    create?: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput> | MainRequestCreateWithoutRequestTypeInput[] | MainRequestUncheckedCreateWithoutRequestTypeInput[]
    connectOrCreate?: MainRequestCreateOrConnectWithoutRequestTypeInput | MainRequestCreateOrConnectWithoutRequestTypeInput[]
    upsert?: MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput | MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput[]
    createMany?: MainRequestCreateManyRequestTypeInputEnvelope
    set?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    disconnect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    delete?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    connect?: MainRequestWhereUniqueInput | MainRequestWhereUniqueInput[]
    update?: MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput | MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput[]
    updateMany?: MainRequestUpdateManyWithWhereWithoutRequestTypeInput | MainRequestUpdateManyWithWhereWithoutRequestTypeInput[]
    deleteMany?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
  }

  export type RequestTypeCreateNestedOneWithoutMainRequestsInput = {
    create?: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    connectOrCreate?: RequestTypeCreateOrConnectWithoutMainRequestsInput
    connect?: RequestTypeWhereUniqueInput
  }

  export type FormFundTransferCreateNestedOneWithoutMainRequestInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    connect?: FormFundTransferWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMainFormInput = {
    create?: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: UserCreateOrConnectWithoutMainFormInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutMainInput = {
    create?: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMainInput
    connect?: BranchWhereUniqueInput
  }

  export type ApprovalTableCreateNestedManyWithoutMainRequestInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
  }

  export type formTravelOrderCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTravelOrderCreateOrConnectWithoutMainFormInput
    connect?: formTravelOrderWhereUniqueInput
  }

  export type formTransmittalMemoCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutMainFormInput
    connect?: formTransmittalMemoWhereUniqueInput
  }

  export type formProposedBudgetCreateNestedManyWithoutMainFormInput = {
    create?: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput> | formProposedBudgetCreateWithoutMainFormInput[] | formProposedBudgetUncheckedCreateWithoutMainFormInput[]
    connectOrCreate?: formProposedBudgetCreateOrConnectWithoutMainFormInput | formProposedBudgetCreateOrConnectWithoutMainFormInput[]
    createMany?: formProposedBudgetCreateManyMainFormInputEnvelope
    connect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
  }

  export type formDisburseCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formDisburseCreateOrConnectWithoutMainFormInput
    connect?: formDisburseWhereUniqueInput
  }

  export type CountSheetCreateNestedOneWithoutMaincountSheetInput = {
    create?: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutMaincountSheetInput
    connect?: CountSheetWhereUniqueInput
  }

  export type FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    connect?: FormFundTransferWhereUniqueInput
  }

  export type ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
  }

  export type formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTravelOrderCreateOrConnectWithoutMainFormInput
    connect?: formTravelOrderWhereUniqueInput
  }

  export type formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutMainFormInput
    connect?: formTransmittalMemoWhereUniqueInput
  }

  export type formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput = {
    create?: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput> | formProposedBudgetCreateWithoutMainFormInput[] | formProposedBudgetUncheckedCreateWithoutMainFormInput[]
    connectOrCreate?: formProposedBudgetCreateOrConnectWithoutMainFormInput | formProposedBudgetCreateOrConnectWithoutMainFormInput[]
    createMany?: formProposedBudgetCreateManyMainFormInputEnvelope
    connect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
  }

  export type formDisburseUncheckedCreateNestedOneWithoutMainFormInput = {
    create?: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formDisburseCreateOrConnectWithoutMainFormInput
    connect?: formDisburseWhereUniqueInput
  }

  export type CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput = {
    create?: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutMaincountSheetInput
    connect?: CountSheetWhereUniqueInput
  }

  export type EnumStatusesFieldUpdateOperationsInput = {
    set?: $Enums.Statuses
  }

  export type RequestTypeUpdateOneWithoutMainRequestsNestedInput = {
    create?: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    connectOrCreate?: RequestTypeCreateOrConnectWithoutMainRequestsInput
    upsert?: RequestTypeUpsertWithoutMainRequestsInput
    disconnect?: RequestTypeWhereInput | boolean
    delete?: RequestTypeWhereInput | boolean
    connect?: RequestTypeWhereUniqueInput
    update?: XOR<XOR<RequestTypeUpdateToOneWithWhereWithoutMainRequestsInput, RequestTypeUpdateWithoutMainRequestsInput>, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
  }

  export type FormFundTransferUpdateOneWithoutMainRequestNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    upsert?: FormFundTransferUpsertWithoutMainRequestInput
    disconnect?: FormFundTransferWhereInput | boolean
    delete?: FormFundTransferWhereInput | boolean
    connect?: FormFundTransferWhereUniqueInput
    update?: XOR<XOR<FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput, FormFundTransferUpdateWithoutMainRequestInput>, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type UserUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: UserCreateOrConnectWithoutMainFormInput
    upsert?: UserUpsertWithoutMainFormInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMainFormInput, UserUpdateWithoutMainFormInput>, UserUncheckedUpdateWithoutMainFormInput>
  }

  export type BranchUpdateOneWithoutMainNestedInput = {
    create?: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMainInput
    upsert?: BranchUpsertWithoutMainInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutMainInput, BranchUpdateWithoutMainInput>, BranchUncheckedUpdateWithoutMainInput>
  }

  export type ApprovalTableUpdateManyWithoutMainRequestNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    upsert?: ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    set?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    disconnect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    delete?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    update?: ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput[]
    updateMany?: ApprovalTableUpdateManyWithWhereWithoutMainRequestInput | ApprovalTableUpdateManyWithWhereWithoutMainRequestInput[]
    deleteMany?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
  }

  export type formTravelOrderUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTravelOrderCreateOrConnectWithoutMainFormInput
    upsert?: formTravelOrderUpsertWithoutMainFormInput
    disconnect?: formTravelOrderWhereInput | boolean
    delete?: formTravelOrderWhereInput | boolean
    connect?: formTravelOrderWhereUniqueInput
    update?: XOR<XOR<formTravelOrderUpdateToOneWithWhereWithoutMainFormInput, formTravelOrderUpdateWithoutMainFormInput>, formTravelOrderUncheckedUpdateWithoutMainFormInput>
  }

  export type formTransmittalMemoUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutMainFormInput
    upsert?: formTransmittalMemoUpsertWithoutMainFormInput
    disconnect?: formTransmittalMemoWhereInput | boolean
    delete?: formTransmittalMemoWhereInput | boolean
    connect?: formTransmittalMemoWhereUniqueInput
    update?: XOR<XOR<formTransmittalMemoUpdateToOneWithWhereWithoutMainFormInput, formTransmittalMemoUpdateWithoutMainFormInput>, formTransmittalMemoUncheckedUpdateWithoutMainFormInput>
  }

  export type formProposedBudgetUpdateManyWithoutMainFormNestedInput = {
    create?: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput> | formProposedBudgetCreateWithoutMainFormInput[] | formProposedBudgetUncheckedCreateWithoutMainFormInput[]
    connectOrCreate?: formProposedBudgetCreateOrConnectWithoutMainFormInput | formProposedBudgetCreateOrConnectWithoutMainFormInput[]
    upsert?: formProposedBudgetUpsertWithWhereUniqueWithoutMainFormInput | formProposedBudgetUpsertWithWhereUniqueWithoutMainFormInput[]
    createMany?: formProposedBudgetCreateManyMainFormInputEnvelope
    set?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    disconnect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    delete?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    connect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    update?: formProposedBudgetUpdateWithWhereUniqueWithoutMainFormInput | formProposedBudgetUpdateWithWhereUniqueWithoutMainFormInput[]
    updateMany?: formProposedBudgetUpdateManyWithWhereWithoutMainFormInput | formProposedBudgetUpdateManyWithWhereWithoutMainFormInput[]
    deleteMany?: formProposedBudgetScalarWhereInput | formProposedBudgetScalarWhereInput[]
  }

  export type formDisburseUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formDisburseCreateOrConnectWithoutMainFormInput
    upsert?: formDisburseUpsertWithoutMainFormInput
    disconnect?: formDisburseWhereInput | boolean
    delete?: formDisburseWhereInput | boolean
    connect?: formDisburseWhereUniqueInput
    update?: XOR<XOR<formDisburseUpdateToOneWithWhereWithoutMainFormInput, formDisburseUpdateWithoutMainFormInput>, formDisburseUncheckedUpdateWithoutMainFormInput>
  }

  export type CountSheetUpdateOneWithoutMaincountSheetNestedInput = {
    create?: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutMaincountSheetInput
    upsert?: CountSheetUpsertWithoutMaincountSheetInput
    disconnect?: CountSheetWhereInput | boolean
    delete?: CountSheetWhereInput | boolean
    connect?: CountSheetWhereUniqueInput
    update?: XOR<XOR<CountSheetUpdateToOneWithWhereWithoutMaincountSheetInput, CountSheetUpdateWithoutMaincountSheetInput>, CountSheetUncheckedUpdateWithoutMaincountSheetInput>
  }

  export type FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput = {
    create?: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    connectOrCreate?: FormFundTransferCreateOrConnectWithoutMainRequestInput
    upsert?: FormFundTransferUpsertWithoutMainRequestInput
    disconnect?: FormFundTransferWhereInput | boolean
    delete?: FormFundTransferWhereInput | boolean
    connect?: FormFundTransferWhereUniqueInput
    update?: XOR<XOR<FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput, FormFundTransferUpdateWithoutMainRequestInput>, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput> | ApprovalTableCreateWithoutMainRequestInput[] | ApprovalTableUncheckedCreateWithoutMainRequestInput[]
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutMainRequestInput | ApprovalTableCreateOrConnectWithoutMainRequestInput[]
    upsert?: ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput[]
    createMany?: ApprovalTableCreateManyMainRequestInputEnvelope
    set?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    disconnect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    delete?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    connect?: ApprovalTableWhereUniqueInput | ApprovalTableWhereUniqueInput[]
    update?: ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput | ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput[]
    updateMany?: ApprovalTableUpdateManyWithWhereWithoutMainRequestInput | ApprovalTableUpdateManyWithWhereWithoutMainRequestInput[]
    deleteMany?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
  }

  export type formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTravelOrderCreateOrConnectWithoutMainFormInput
    upsert?: formTravelOrderUpsertWithoutMainFormInput
    disconnect?: formTravelOrderWhereInput | boolean
    delete?: formTravelOrderWhereInput | boolean
    connect?: formTravelOrderWhereUniqueInput
    update?: XOR<XOR<formTravelOrderUpdateToOneWithWhereWithoutMainFormInput, formTravelOrderUpdateWithoutMainFormInput>, formTravelOrderUncheckedUpdateWithoutMainFormInput>
  }

  export type formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formTransmittalMemoCreateOrConnectWithoutMainFormInput
    upsert?: formTransmittalMemoUpsertWithoutMainFormInput
    disconnect?: formTransmittalMemoWhereInput | boolean
    delete?: formTransmittalMemoWhereInput | boolean
    connect?: formTransmittalMemoWhereUniqueInput
    update?: XOR<XOR<formTransmittalMemoUpdateToOneWithWhereWithoutMainFormInput, formTransmittalMemoUpdateWithoutMainFormInput>, formTransmittalMemoUncheckedUpdateWithoutMainFormInput>
  }

  export type formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput = {
    create?: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput> | formProposedBudgetCreateWithoutMainFormInput[] | formProposedBudgetUncheckedCreateWithoutMainFormInput[]
    connectOrCreate?: formProposedBudgetCreateOrConnectWithoutMainFormInput | formProposedBudgetCreateOrConnectWithoutMainFormInput[]
    upsert?: formProposedBudgetUpsertWithWhereUniqueWithoutMainFormInput | formProposedBudgetUpsertWithWhereUniqueWithoutMainFormInput[]
    createMany?: formProposedBudgetCreateManyMainFormInputEnvelope
    set?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    disconnect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    delete?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    connect?: formProposedBudgetWhereUniqueInput | formProposedBudgetWhereUniqueInput[]
    update?: formProposedBudgetUpdateWithWhereUniqueWithoutMainFormInput | formProposedBudgetUpdateWithWhereUniqueWithoutMainFormInput[]
    updateMany?: formProposedBudgetUpdateManyWithWhereWithoutMainFormInput | formProposedBudgetUpdateManyWithWhereWithoutMainFormInput[]
    deleteMany?: formProposedBudgetScalarWhereInput | formProposedBudgetScalarWhereInput[]
  }

  export type formDisburseUncheckedUpdateOneWithoutMainFormNestedInput = {
    create?: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
    connectOrCreate?: formDisburseCreateOrConnectWithoutMainFormInput
    upsert?: formDisburseUpsertWithoutMainFormInput
    disconnect?: formDisburseWhereInput | boolean
    delete?: formDisburseWhereInput | boolean
    connect?: formDisburseWhereUniqueInput
    update?: XOR<XOR<formDisburseUpdateToOneWithWhereWithoutMainFormInput, formDisburseUpdateWithoutMainFormInput>, formDisburseUncheckedUpdateWithoutMainFormInput>
  }

  export type CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput = {
    create?: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutMaincountSheetInput
    upsert?: CountSheetUpsertWithoutMaincountSheetInput
    disconnect?: CountSheetWhereInput | boolean
    delete?: CountSheetWhereInput | boolean
    connect?: CountSheetWhereUniqueInput
    update?: XOR<XOR<CountSheetUpdateToOneWithWhereWithoutMaincountSheetInput, CountSheetUpdateWithoutMaincountSheetInput>, CountSheetUncheckedUpdateWithoutMaincountSheetInput>
  }

  export type MainRequestCreateNestedOneWithoutFundTransferInput = {
    create?: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutFundTransferInput
    connect?: MainRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFormRequestFundToInput = {
    create?: XOR<UserCreateWithoutFormRequestFundToInput, UserUncheckedCreateWithoutFormRequestFundToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestFundToInput
    connect?: UserWhereUniqueInput
  }

  export type MainRequestUpdateOneWithoutFundTransferNestedInput = {
    create?: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutFundTransferInput
    upsert?: MainRequestUpsertWithoutFundTransferInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutFundTransferInput, MainRequestUpdateWithoutFundTransferInput>, MainRequestUncheckedUpdateWithoutFundTransferInput>
  }

  export type UserUpdateOneWithoutFormRequestFundToNestedInput = {
    create?: XOR<UserCreateWithoutFormRequestFundToInput, UserUncheckedCreateWithoutFormRequestFundToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestFundToInput
    upsert?: UserUpsertWithoutFormRequestFundToInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormRequestFundToInput, UserUpdateWithoutFormRequestFundToInput>, UserUncheckedUpdateWithoutFormRequestFundToInput>
  }

  export type MainRequestCreateNestedOneWithoutApprovalInput = {
    create?: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutApprovalInput
    connect?: MainRequestWhereUniqueInput
  }

  export type RequestLogsCreateNestedManyWithoutApprovalInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type RequestLogsUncheckedCreateNestedManyWithoutApprovalInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
  }

  export type MainRequestUpdateOneWithoutApprovalNestedInput = {
    create?: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutApprovalInput
    upsert?: MainRequestUpsertWithoutApprovalInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutApprovalInput, MainRequestUpdateWithoutApprovalInput>, MainRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type RequestLogsUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApprovalInput | RequestLogsUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApprovalInput | RequestLogsUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApprovalInput | RequestLogsUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput> | RequestLogsCreateWithoutApprovalInput[] | RequestLogsUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: RequestLogsCreateOrConnectWithoutApprovalInput | RequestLogsCreateOrConnectWithoutApprovalInput[]
    upsert?: RequestLogsUpsertWithWhereUniqueWithoutApprovalInput | RequestLogsUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: RequestLogsCreateManyApprovalInputEnvelope
    set?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    disconnect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    delete?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    connect?: RequestLogsWhereUniqueInput | RequestLogsWhereUniqueInput[]
    update?: RequestLogsUpdateWithWhereUniqueWithoutApprovalInput | RequestLogsUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: RequestLogsUpdateManyWithWhereWithoutApprovalInput | RequestLogsUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
  }

  export type ApprovalTableCreateNestedOneWithoutRequestLogsInput = {
    create?: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutRequestLogsInput
    connect?: ApprovalTableWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestLogsInput = {
    create?: XOR<UserCreateWithoutRequestLogsInput, UserUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ApprovalTableUpdateOneWithoutRequestLogsNestedInput = {
    create?: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: ApprovalTableCreateOrConnectWithoutRequestLogsInput
    upsert?: ApprovalTableUpsertWithoutRequestLogsInput
    disconnect?: ApprovalTableWhereInput | boolean
    delete?: ApprovalTableWhereInput | boolean
    connect?: ApprovalTableWhereUniqueInput
    update?: XOR<XOR<ApprovalTableUpdateToOneWithWhereWithoutRequestLogsInput, ApprovalTableUpdateWithoutRequestLogsInput>, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
  }

  export type UserUpdateOneWithoutRequestLogsNestedInput = {
    create?: XOR<UserCreateWithoutRequestLogsInput, UserUncheckedCreateWithoutRequestLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestLogsInput
    upsert?: UserUpsertWithoutRequestLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestLogsInput, UserUpdateWithoutRequestLogsInput>, UserUncheckedUpdateWithoutRequestLogsInput>
  }

  export type MainRequestCreateNestedOneWithoutTravelOrderInput = {
    create?: XOR<MainRequestCreateWithoutTravelOrderInput, MainRequestUncheckedCreateWithoutTravelOrderInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutTravelOrderInput
    connect?: MainRequestWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MainRequestUpdateOneWithoutTravelOrderNestedInput = {
    create?: XOR<MainRequestCreateWithoutTravelOrderInput, MainRequestUncheckedCreateWithoutTravelOrderInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutTravelOrderInput
    upsert?: MainRequestUpsertWithoutTravelOrderInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutTravelOrderInput, MainRequestUpdateWithoutTravelOrderInput>, MainRequestUncheckedUpdateWithoutTravelOrderInput>
  }

  export type MainRequestCreateNestedOneWithoutProposedBudgetInput = {
    create?: XOR<MainRequestCreateWithoutProposedBudgetInput, MainRequestUncheckedCreateWithoutProposedBudgetInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutProposedBudgetInput
    connect?: MainRequestWhereUniqueInput
  }

  export type MainRequestUpdateOneRequiredWithoutProposedBudgetNestedInput = {
    create?: XOR<MainRequestCreateWithoutProposedBudgetInput, MainRequestUncheckedCreateWithoutProposedBudgetInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutProposedBudgetInput
    upsert?: MainRequestUpsertWithoutProposedBudgetInput
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutProposedBudgetInput, MainRequestUpdateWithoutProposedBudgetInput>, MainRequestUncheckedUpdateWithoutProposedBudgetInput>
  }

  export type UserCreateNestedOneWithoutFormRequestTransmittalToInput = {
    create?: XOR<UserCreateWithoutFormRequestTransmittalToInput, UserUncheckedCreateWithoutFormRequestTransmittalToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestTransmittalToInput
    connect?: UserWhereUniqueInput
  }

  export type MainRequestCreateNestedOneWithoutTransmittalMemoInput = {
    create?: XOR<MainRequestCreateWithoutTransmittalMemoInput, MainRequestUncheckedCreateWithoutTransmittalMemoInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutTransmittalMemoInput
    connect?: MainRequestWhereUniqueInput
  }

  export type UserUpdateOneWithoutFormRequestTransmittalToNestedInput = {
    create?: XOR<UserCreateWithoutFormRequestTransmittalToInput, UserUncheckedCreateWithoutFormRequestTransmittalToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestTransmittalToInput
    upsert?: UserUpsertWithoutFormRequestTransmittalToInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormRequestTransmittalToInput, UserUpdateWithoutFormRequestTransmittalToInput>, UserUncheckedUpdateWithoutFormRequestTransmittalToInput>
  }

  export type MainRequestUpdateOneWithoutTransmittalMemoNestedInput = {
    create?: XOR<MainRequestCreateWithoutTransmittalMemoInput, MainRequestUncheckedCreateWithoutTransmittalMemoInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutTransmittalMemoInput
    upsert?: MainRequestUpsertWithoutTransmittalMemoInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutTransmittalMemoInput, MainRequestUpdateWithoutTransmittalMemoInput>, MainRequestUncheckedUpdateWithoutTransmittalMemoInput>
  }

  export type UserCreateNestedOneWithoutFormRequestDisburseToInput = {
    create?: XOR<UserCreateWithoutFormRequestDisburseToInput, UserUncheckedCreateWithoutFormRequestDisburseToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestDisburseToInput
    connect?: UserWhereUniqueInput
  }

  export type MainRequestCreateNestedOneWithoutDisburseInput = {
    create?: XOR<MainRequestCreateWithoutDisburseInput, MainRequestUncheckedCreateWithoutDisburseInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutDisburseInput
    connect?: MainRequestWhereUniqueInput
  }

  export type UserUpdateOneWithoutFormRequestDisburseToNestedInput = {
    create?: XOR<UserCreateWithoutFormRequestDisburseToInput, UserUncheckedCreateWithoutFormRequestDisburseToInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormRequestDisburseToInput
    upsert?: UserUpsertWithoutFormRequestDisburseToInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormRequestDisburseToInput, UserUpdateWithoutFormRequestDisburseToInput>, UserUncheckedUpdateWithoutFormRequestDisburseToInput>
  }

  export type MainRequestUpdateOneWithoutDisburseNestedInput = {
    create?: XOR<MainRequestCreateWithoutDisburseInput, MainRequestUncheckedCreateWithoutDisburseInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutDisburseInput
    upsert?: MainRequestUpsertWithoutDisburseInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutDisburseInput, MainRequestUpdateWithoutDisburseInput>, MainRequestUncheckedUpdateWithoutDisburseInput>
  }

  export type MainRequestCreateNestedOneWithoutCountSheetInput = {
    create?: XOR<MainRequestCreateWithoutCountSheetInput, MainRequestUncheckedCreateWithoutCountSheetInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutCountSheetInput
    connect?: MainRequestWhereUniqueInput
  }

  export type CashFundCreateNestedManyWithoutCashSheetInput = {
    create?: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput> | CashFundCreateWithoutCashSheetInput[] | CashFundUncheckedCreateWithoutCashSheetInput[]
    connectOrCreate?: CashFundCreateOrConnectWithoutCashSheetInput | CashFundCreateOrConnectWithoutCashSheetInput[]
    createMany?: CashFundCreateManyCashSheetInputEnvelope
    connect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
  }

  export type TravelFundCreateNestedManyWithoutTravelSheetInput = {
    create?: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput> | TravelFundCreateWithoutTravelSheetInput[] | TravelFundUncheckedCreateWithoutTravelSheetInput[]
    connectOrCreate?: TravelFundCreateOrConnectWithoutTravelSheetInput | TravelFundCreateOrConnectWithoutTravelSheetInput[]
    createMany?: TravelFundCreateManyTravelSheetInputEnvelope
    connect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
  }

  export type CashFundUncheckedCreateNestedManyWithoutCashSheetInput = {
    create?: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput> | CashFundCreateWithoutCashSheetInput[] | CashFundUncheckedCreateWithoutCashSheetInput[]
    connectOrCreate?: CashFundCreateOrConnectWithoutCashSheetInput | CashFundCreateOrConnectWithoutCashSheetInput[]
    createMany?: CashFundCreateManyCashSheetInputEnvelope
    connect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
  }

  export type TravelFundUncheckedCreateNestedManyWithoutTravelSheetInput = {
    create?: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput> | TravelFundCreateWithoutTravelSheetInput[] | TravelFundUncheckedCreateWithoutTravelSheetInput[]
    connectOrCreate?: TravelFundCreateOrConnectWithoutTravelSheetInput | TravelFundCreateOrConnectWithoutTravelSheetInput[]
    createMany?: TravelFundCreateManyTravelSheetInputEnvelope
    connect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MainRequestUpdateOneWithoutCountSheetNestedInput = {
    create?: XOR<MainRequestCreateWithoutCountSheetInput, MainRequestUncheckedCreateWithoutCountSheetInput>
    connectOrCreate?: MainRequestCreateOrConnectWithoutCountSheetInput
    upsert?: MainRequestUpsertWithoutCountSheetInput
    disconnect?: MainRequestWhereInput | boolean
    delete?: MainRequestWhereInput | boolean
    connect?: MainRequestWhereUniqueInput
    update?: XOR<XOR<MainRequestUpdateToOneWithWhereWithoutCountSheetInput, MainRequestUpdateWithoutCountSheetInput>, MainRequestUncheckedUpdateWithoutCountSheetInput>
  }

  export type CashFundUpdateManyWithoutCashSheetNestedInput = {
    create?: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput> | CashFundCreateWithoutCashSheetInput[] | CashFundUncheckedCreateWithoutCashSheetInput[]
    connectOrCreate?: CashFundCreateOrConnectWithoutCashSheetInput | CashFundCreateOrConnectWithoutCashSheetInput[]
    upsert?: CashFundUpsertWithWhereUniqueWithoutCashSheetInput | CashFundUpsertWithWhereUniqueWithoutCashSheetInput[]
    createMany?: CashFundCreateManyCashSheetInputEnvelope
    set?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    disconnect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    delete?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    connect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    update?: CashFundUpdateWithWhereUniqueWithoutCashSheetInput | CashFundUpdateWithWhereUniqueWithoutCashSheetInput[]
    updateMany?: CashFundUpdateManyWithWhereWithoutCashSheetInput | CashFundUpdateManyWithWhereWithoutCashSheetInput[]
    deleteMany?: CashFundScalarWhereInput | CashFundScalarWhereInput[]
  }

  export type TravelFundUpdateManyWithoutTravelSheetNestedInput = {
    create?: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput> | TravelFundCreateWithoutTravelSheetInput[] | TravelFundUncheckedCreateWithoutTravelSheetInput[]
    connectOrCreate?: TravelFundCreateOrConnectWithoutTravelSheetInput | TravelFundCreateOrConnectWithoutTravelSheetInput[]
    upsert?: TravelFundUpsertWithWhereUniqueWithoutTravelSheetInput | TravelFundUpsertWithWhereUniqueWithoutTravelSheetInput[]
    createMany?: TravelFundCreateManyTravelSheetInputEnvelope
    set?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    disconnect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    delete?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    connect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    update?: TravelFundUpdateWithWhereUniqueWithoutTravelSheetInput | TravelFundUpdateWithWhereUniqueWithoutTravelSheetInput[]
    updateMany?: TravelFundUpdateManyWithWhereWithoutTravelSheetInput | TravelFundUpdateManyWithWhereWithoutTravelSheetInput[]
    deleteMany?: TravelFundScalarWhereInput | TravelFundScalarWhereInput[]
  }

  export type CashFundUncheckedUpdateManyWithoutCashSheetNestedInput = {
    create?: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput> | CashFundCreateWithoutCashSheetInput[] | CashFundUncheckedCreateWithoutCashSheetInput[]
    connectOrCreate?: CashFundCreateOrConnectWithoutCashSheetInput | CashFundCreateOrConnectWithoutCashSheetInput[]
    upsert?: CashFundUpsertWithWhereUniqueWithoutCashSheetInput | CashFundUpsertWithWhereUniqueWithoutCashSheetInput[]
    createMany?: CashFundCreateManyCashSheetInputEnvelope
    set?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    disconnect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    delete?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    connect?: CashFundWhereUniqueInput | CashFundWhereUniqueInput[]
    update?: CashFundUpdateWithWhereUniqueWithoutCashSheetInput | CashFundUpdateWithWhereUniqueWithoutCashSheetInput[]
    updateMany?: CashFundUpdateManyWithWhereWithoutCashSheetInput | CashFundUpdateManyWithWhereWithoutCashSheetInput[]
    deleteMany?: CashFundScalarWhereInput | CashFundScalarWhereInput[]
  }

  export type TravelFundUncheckedUpdateManyWithoutTravelSheetNestedInput = {
    create?: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput> | TravelFundCreateWithoutTravelSheetInput[] | TravelFundUncheckedCreateWithoutTravelSheetInput[]
    connectOrCreate?: TravelFundCreateOrConnectWithoutTravelSheetInput | TravelFundCreateOrConnectWithoutTravelSheetInput[]
    upsert?: TravelFundUpsertWithWhereUniqueWithoutTravelSheetInput | TravelFundUpsertWithWhereUniqueWithoutTravelSheetInput[]
    createMany?: TravelFundCreateManyTravelSheetInputEnvelope
    set?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    disconnect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    delete?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    connect?: TravelFundWhereUniqueInput | TravelFundWhereUniqueInput[]
    update?: TravelFundUpdateWithWhereUniqueWithoutTravelSheetInput | TravelFundUpdateWithWhereUniqueWithoutTravelSheetInput[]
    updateMany?: TravelFundUpdateManyWithWhereWithoutTravelSheetInput | TravelFundUpdateManyWithWhereWithoutTravelSheetInput[]
    deleteMany?: TravelFundScalarWhereInput | TravelFundScalarWhereInput[]
  }

  export type CountSheetCreateNestedOneWithoutCashCountSheetInput = {
    create?: XOR<CountSheetCreateWithoutCashCountSheetInput, CountSheetUncheckedCreateWithoutCashCountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutCashCountSheetInput
    connect?: CountSheetWhereUniqueInput
  }

  export type CountSheetUpdateOneWithoutCashCountSheetNestedInput = {
    create?: XOR<CountSheetCreateWithoutCashCountSheetInput, CountSheetUncheckedCreateWithoutCashCountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutCashCountSheetInput
    upsert?: CountSheetUpsertWithoutCashCountSheetInput
    disconnect?: CountSheetWhereInput | boolean
    delete?: CountSheetWhereInput | boolean
    connect?: CountSheetWhereUniqueInput
    update?: XOR<XOR<CountSheetUpdateToOneWithWhereWithoutCashCountSheetInput, CountSheetUpdateWithoutCashCountSheetInput>, CountSheetUncheckedUpdateWithoutCashCountSheetInput>
  }

  export type TravelFundCreatetagsFieldInput = {
    set: string[]
  }

  export type TravelFundCreaterepairInput = {
    set: string[]
  }

  export type CountSheetCreateNestedOneWithoutTravelCountSheetInput = {
    create?: XOR<CountSheetCreateWithoutTravelCountSheetInput, CountSheetUncheckedCreateWithoutTravelCountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutTravelCountSheetInput
    connect?: CountSheetWhereUniqueInput
  }

  export type TravelFundUpdatetagsFieldInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TravelFundUpdaterepairInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CountSheetUpdateOneWithoutTravelCountSheetNestedInput = {
    create?: XOR<CountSheetCreateWithoutTravelCountSheetInput, CountSheetUncheckedCreateWithoutTravelCountSheetInput>
    connectOrCreate?: CountSheetCreateOrConnectWithoutTravelCountSheetInput
    upsert?: CountSheetUpsertWithoutTravelCountSheetInput
    disconnect?: CountSheetWhereInput | boolean
    delete?: CountSheetWhereInput | boolean
    connect?: CountSheetWhereUniqueInput
    update?: XOR<XOR<CountSheetUpdateToOneWithWhereWithoutTravelCountSheetInput, CountSheetUpdateWithoutTravelCountSheetInput>, CountSheetUncheckedUpdateWithoutTravelCountSheetInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesFilter<$PrismaModel> | $Enums.Statuses
  }

  export type NestedEnumStatusesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Statuses | EnumStatusesFieldRefInput<$PrismaModel>
    in?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Statuses[] | ListEnumStatusesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusesWithAggregatesFilter<$PrismaModel> | $Enums.Statuses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusesFilter<$PrismaModel>
    _max?: NestedEnumStatusesFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BranchCreateWithoutUsersInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    main?: MainRequestCreateNestedManyWithoutRequestFromInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    main?: MainRequestUncheckedCreateNestedManyWithoutRequestFromInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type RequestTypeCreateWithoutNotedByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutNotedByInput = {
    id?: number
    requestName: string
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput>
  }

  export type RequestTypeCreateManyNotedByInputEnvelope = {
    data: RequestTypeCreateManyNotedByInput | RequestTypeCreateManyNotedByInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutCheckedByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutCheckedByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput>
  }

  export type RequestTypeCreateManyCheckedByInputEnvelope = {
    data: RequestTypeCreateManyCheckedByInput | RequestTypeCreateManyCheckedByInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutCheckedBy2Input = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutCheckedBy2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input>
  }

  export type RequestTypeCreateManyCheckedBy2InputEnvelope = {
    data: RequestTypeCreateManyCheckedBy2Input | RequestTypeCreateManyCheckedBy2Input[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutRecomApprovalInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutRecomApprovalInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput>
  }

  export type RequestTypeCreateManyRecomApprovalInputEnvelope = {
    data: RequestTypeCreateManyRecomApprovalInput | RequestTypeCreateManyRecomApprovalInput[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutRecomApproval2Input = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutRecomApproval2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input>
  }

  export type RequestTypeCreateManyRecomApproval2InputEnvelope = {
    data: RequestTypeCreateManyRecomApproval2Input | RequestTypeCreateManyRecomApproval2Input[]
    skipDuplicates?: boolean
  }

  export type RequestTypeCreateWithoutApproveByInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    mainRequests?: MainRequestCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeUncheckedCreateWithoutApproveByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequests?: MainRequestUncheckedCreateNestedManyWithoutRequestTypeInput
  }

  export type RequestTypeCreateOrConnectWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput>
  }

  export type RequestTypeCreateManyApproveByInputEnvelope = {
    data: RequestTypeCreateManyApproveByInput | RequestTypeCreateManyApproveByInput[]
    skipDuplicates?: boolean
  }

  export type FormFundTransferCreateWithoutRequestToInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutFundTransferInput
  }

  export type FormFundTransferUncheckedCreateWithoutRequestToInput = {
    id?: number
    mainRequestID?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateOrConnectWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    create: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput>
  }

  export type FormFundTransferCreateManyRequestToInputEnvelope = {
    data: FormFundTransferCreateManyRequestToInput | FormFundTransferCreateManyRequestToInput[]
    skipDuplicates?: boolean
  }

  export type formTransmittalMemoCreateWithoutRequestToInput = {
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainForm?: MainRequestCreateNestedOneWithoutTransmittalMemoInput
  }

  export type formTransmittalMemoUncheckedCreateWithoutRequestToInput = {
    id?: number
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId: number
  }

  export type formTransmittalMemoCreateOrConnectWithoutRequestToInput = {
    where: formTransmittalMemoWhereUniqueInput
    create: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput>
  }

  export type formTransmittalMemoCreateManyRequestToInputEnvelope = {
    data: formTransmittalMemoCreateManyRequestToInput | formTransmittalMemoCreateManyRequestToInput[]
    skipDuplicates?: boolean
  }

  export type formDisburseCreateWithoutRequestToInput = {
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainForm?: MainRequestCreateNestedOneWithoutDisburseInput
  }

  export type formDisburseUncheckedCreateWithoutRequestToInput = {
    id?: number
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId: number
  }

  export type formDisburseCreateOrConnectWithoutRequestToInput = {
    where: formDisburseWhereUniqueInput
    create: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput>
  }

  export type formDisburseCreateManyRequestToInputEnvelope = {
    data: formDisburseCreateManyRequestToInput | formDisburseCreateManyRequestToInput[]
    skipDuplicates?: boolean
  }

  export type RequestLogsCreateWithoutApproverInput = {
    checkerType: string
    action: string
    createdAt?: Date | string
    approval?: ApprovalTableCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateWithoutApproverInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    action: string
    createdAt?: Date | string
  }

  export type RequestLogsCreateOrConnectWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    create: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput>
  }

  export type RequestLogsCreateManyApproverInputEnvelope = {
    data: RequestLogsCreateManyApproverInput | RequestLogsCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestCreateWithoutRequestByInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutRequestByInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput>
  }

  export type MainRequestCreateManyRequestByInputEnvelope = {
    data: MainRequestCreateManyRequestByInput | MainRequestCreateManyRequestByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    main?: MainRequestUpdateManyWithoutRequestFromNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    main?: MainRequestUncheckedUpdateManyWithoutRequestFromNestedInput
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutNotedByInput, RequestTypeUncheckedUpdateWithoutNotedByInput>
    create: XOR<RequestTypeCreateWithoutNotedByInput, RequestTypeUncheckedCreateWithoutNotedByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutNotedByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutNotedByInput, RequestTypeUncheckedUpdateWithoutNotedByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutNotedByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutNotedByInput>
  }

  export type RequestTypeScalarWhereInput = {
    AND?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
    OR?: RequestTypeScalarWhereInput[]
    NOT?: RequestTypeScalarWhereInput | RequestTypeScalarWhereInput[]
    id?: IntFilter<"RequestType"> | number
    requestName?: StringFilter<"RequestType"> | string
    notedById?: IntNullableFilter<"RequestType"> | number | null
    checkedById?: IntNullableFilter<"RequestType"> | number | null
    checkedBy2Id?: IntNullableFilter<"RequestType"> | number | null
    recomApprovalId?: IntNullableFilter<"RequestType"> | number | null
    recomApproval2Id?: IntNullableFilter<"RequestType"> | number | null
    approveById?: IntNullableFilter<"RequestType"> | number | null
    createdAt?: DateTimeFilter<"RequestType"> | Date | string
    updateAt?: DateTimeFilter<"RequestType"> | Date | string
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutCheckedByInput, RequestTypeUncheckedUpdateWithoutCheckedByInput>
    create: XOR<RequestTypeCreateWithoutCheckedByInput, RequestTypeUncheckedCreateWithoutCheckedByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutCheckedByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutCheckedByInput, RequestTypeUncheckedUpdateWithoutCheckedByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutCheckedByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutCheckedByInput>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutCheckedBy2Input, RequestTypeUncheckedUpdateWithoutCheckedBy2Input>
    create: XOR<RequestTypeCreateWithoutCheckedBy2Input, RequestTypeUncheckedCreateWithoutCheckedBy2Input>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutCheckedBy2Input = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutCheckedBy2Input, RequestTypeUncheckedUpdateWithoutCheckedBy2Input>
  }

  export type RequestTypeUpdateManyWithWhereWithoutCheckedBy2Input = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutCheckedBy2Input>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutRecomApprovalInput, RequestTypeUncheckedUpdateWithoutRecomApprovalInput>
    create: XOR<RequestTypeCreateWithoutRecomApprovalInput, RequestTypeUncheckedCreateWithoutRecomApprovalInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutRecomApprovalInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutRecomApprovalInput, RequestTypeUncheckedUpdateWithoutRecomApprovalInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutRecomApprovalInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutRecomApprovalInput>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutRecomApproval2Input, RequestTypeUncheckedUpdateWithoutRecomApproval2Input>
    create: XOR<RequestTypeCreateWithoutRecomApproval2Input, RequestTypeUncheckedCreateWithoutRecomApproval2Input>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutRecomApproval2Input = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutRecomApproval2Input, RequestTypeUncheckedUpdateWithoutRecomApproval2Input>
  }

  export type RequestTypeUpdateManyWithWhereWithoutRecomApproval2Input = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutRecomApproval2Input>
  }

  export type RequestTypeUpsertWithWhereUniqueWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    update: XOR<RequestTypeUpdateWithoutApproveByInput, RequestTypeUncheckedUpdateWithoutApproveByInput>
    create: XOR<RequestTypeCreateWithoutApproveByInput, RequestTypeUncheckedCreateWithoutApproveByInput>
  }

  export type RequestTypeUpdateWithWhereUniqueWithoutApproveByInput = {
    where: RequestTypeWhereUniqueInput
    data: XOR<RequestTypeUpdateWithoutApproveByInput, RequestTypeUncheckedUpdateWithoutApproveByInput>
  }

  export type RequestTypeUpdateManyWithWhereWithoutApproveByInput = {
    where: RequestTypeScalarWhereInput
    data: XOR<RequestTypeUpdateManyMutationInput, RequestTypeUncheckedUpdateManyWithoutApproveByInput>
  }

  export type FormFundTransferUpsertWithWhereUniqueWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    update: XOR<FormFundTransferUpdateWithoutRequestToInput, FormFundTransferUncheckedUpdateWithoutRequestToInput>
    create: XOR<FormFundTransferCreateWithoutRequestToInput, FormFundTransferUncheckedCreateWithoutRequestToInput>
  }

  export type FormFundTransferUpdateWithWhereUniqueWithoutRequestToInput = {
    where: FormFundTransferWhereUniqueInput
    data: XOR<FormFundTransferUpdateWithoutRequestToInput, FormFundTransferUncheckedUpdateWithoutRequestToInput>
  }

  export type FormFundTransferUpdateManyWithWhereWithoutRequestToInput = {
    where: FormFundTransferScalarWhereInput
    data: XOR<FormFundTransferUpdateManyMutationInput, FormFundTransferUncheckedUpdateManyWithoutRequestToInput>
  }

  export type FormFundTransferScalarWhereInput = {
    AND?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
    OR?: FormFundTransferScalarWhereInput[]
    NOT?: FormFundTransferScalarWhereInput | FormFundTransferScalarWhereInput[]
    id?: IntFilter<"FormFundTransfer"> | number
    mainRequestID?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestToId?: IntNullableFilter<"FormFundTransfer"> | number | null
    requestContent?: StringFilter<"FormFundTransfer"> | string
    createdAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
    updateAt?: DateTimeFilter<"FormFundTransfer"> | Date | string
  }

  export type formTransmittalMemoUpsertWithWhereUniqueWithoutRequestToInput = {
    where: formTransmittalMemoWhereUniqueInput
    update: XOR<formTransmittalMemoUpdateWithoutRequestToInput, formTransmittalMemoUncheckedUpdateWithoutRequestToInput>
    create: XOR<formTransmittalMemoCreateWithoutRequestToInput, formTransmittalMemoUncheckedCreateWithoutRequestToInput>
  }

  export type formTransmittalMemoUpdateWithWhereUniqueWithoutRequestToInput = {
    where: formTransmittalMemoWhereUniqueInput
    data: XOR<formTransmittalMemoUpdateWithoutRequestToInput, formTransmittalMemoUncheckedUpdateWithoutRequestToInput>
  }

  export type formTransmittalMemoUpdateManyWithWhereWithoutRequestToInput = {
    where: formTransmittalMemoScalarWhereInput
    data: XOR<formTransmittalMemoUpdateManyMutationInput, formTransmittalMemoUncheckedUpdateManyWithoutRequestToInput>
  }

  export type formTransmittalMemoScalarWhereInput = {
    AND?: formTransmittalMemoScalarWhereInput | formTransmittalMemoScalarWhereInput[]
    OR?: formTransmittalMemoScalarWhereInput[]
    NOT?: formTransmittalMemoScalarWhereInput | formTransmittalMemoScalarWhereInput[]
    id?: IntFilter<"formTransmittalMemo"> | number
    from?: StringNullableFilter<"formTransmittalMemo"> | string | null
    date?: DateTimeFilter<"formTransmittalMemo"> | Date | string
    description?: StringNullableFilter<"formTransmittalMemo"> | string | null
    note?: StringNullableFilter<"formTransmittalMemo"> | string | null
    items?: JsonNullableFilter<"formTransmittalMemo">
    to_id?: IntNullableFilter<"formTransmittalMemo"> | number | null
    mainFormId?: IntFilter<"formTransmittalMemo"> | number
  }

  export type formDisburseUpsertWithWhereUniqueWithoutRequestToInput = {
    where: formDisburseWhereUniqueInput
    update: XOR<formDisburseUpdateWithoutRequestToInput, formDisburseUncheckedUpdateWithoutRequestToInput>
    create: XOR<formDisburseCreateWithoutRequestToInput, formDisburseUncheckedCreateWithoutRequestToInput>
  }

  export type formDisburseUpdateWithWhereUniqueWithoutRequestToInput = {
    where: formDisburseWhereUniqueInput
    data: XOR<formDisburseUpdateWithoutRequestToInput, formDisburseUncheckedUpdateWithoutRequestToInput>
  }

  export type formDisburseUpdateManyWithWhereWithoutRequestToInput = {
    where: formDisburseScalarWhereInput
    data: XOR<formDisburseUpdateManyMutationInput, formDisburseUncheckedUpdateManyWithoutRequestToInput>
  }

  export type formDisburseScalarWhereInput = {
    AND?: formDisburseScalarWhereInput | formDisburseScalarWhereInput[]
    OR?: formDisburseScalarWhereInput[]
    NOT?: formDisburseScalarWhereInput | formDisburseScalarWhereInput[]
    id?: IntFilter<"formDisburse"> | number
    from?: StringNullableFilter<"formDisburse"> | string | null
    date?: DateTimeFilter<"formDisburse"> | Date | string
    subject?: StringNullableFilter<"formDisburse"> | string | null
    description?: StringNullableFilter<"formDisburse"> | string | null
    note?: StringNullableFilter<"formDisburse"> | string | null
    total_amount?: DecimalNullableFilter<"formDisburse"> | Decimal | DecimalJsLike | number | string | null
    items?: JsonNullableFilter<"formDisburse">
    to_id?: IntNullableFilter<"formDisburse"> | number | null
    mainFormId?: IntFilter<"formDisburse"> | number
  }

  export type RequestLogsUpsertWithWhereUniqueWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    update: XOR<RequestLogsUpdateWithoutApproverInput, RequestLogsUncheckedUpdateWithoutApproverInput>
    create: XOR<RequestLogsCreateWithoutApproverInput, RequestLogsUncheckedCreateWithoutApproverInput>
  }

  export type RequestLogsUpdateWithWhereUniqueWithoutApproverInput = {
    where: RequestLogsWhereUniqueInput
    data: XOR<RequestLogsUpdateWithoutApproverInput, RequestLogsUncheckedUpdateWithoutApproverInput>
  }

  export type RequestLogsUpdateManyWithWhereWithoutApproverInput = {
    where: RequestLogsScalarWhereInput
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyWithoutApproverInput>
  }

  export type RequestLogsScalarWhereInput = {
    AND?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
    OR?: RequestLogsScalarWhereInput[]
    NOT?: RequestLogsScalarWhereInput | RequestLogsScalarWhereInput[]
    id?: IntFilter<"RequestLogs"> | number
    approvalId?: IntNullableFilter<"RequestLogs"> | number | null
    checkerType?: StringFilter<"RequestLogs"> | string
    approverId?: IntNullableFilter<"RequestLogs"> | number | null
    action?: StringFilter<"RequestLogs"> | string
    createdAt?: DateTimeFilter<"RequestLogs"> | Date | string
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestByInput, MainRequestUncheckedUpdateWithoutRequestByInput>
    create: XOR<MainRequestCreateWithoutRequestByInput, MainRequestUncheckedCreateWithoutRequestByInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestByInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestByInput, MainRequestUncheckedUpdateWithoutRequestByInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestByInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestByInput>
  }

  export type MainRequestScalarWhereInput = {
    AND?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
    OR?: MainRequestScalarWhereInput[]
    NOT?: MainRequestScalarWhereInput | MainRequestScalarWhereInput[]
    id?: IntFilter<"MainRequest"> | number
    referenceCode?: StringFilter<"MainRequest"> | string
    requestTypeId?: IntNullableFilter<"MainRequest"> | number | null
    requestById?: IntNullableFilter<"MainRequest"> | number | null
    requestFromId?: IntNullableFilter<"MainRequest"> | number | null
    status?: EnumStatusesFilter<"MainRequest"> | $Enums.Statuses
    requestDate?: DateTimeFilter<"MainRequest"> | Date | string
    remarks?: StringNullableFilter<"MainRequest"> | string | null
    createdAt?: DateTimeFilter<"MainRequest"> | Date | string
    updateAt?: DateTimeFilter<"MainRequest"> | Date | string
  }

  export type UserCreateWithoutBranchInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestCreateWithoutRequestFromInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutRequestFromInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput>
  }

  export type MainRequestCreateManyRequestFromInputEnvelope = {
    data: MainRequestCreateManyRequestFromInput | MainRequestCreateManyRequestFromInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    branchId?: IntNullableFilter<"User"> | number | null
    signatureUrl?: StringNullableFilter<"User"> | string | null
    position?: StringNullableFilter<"User"> | string | null
    initial?: StringNullableFilter<"User"> | string | null
    approver?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestFromInput, MainRequestUncheckedUpdateWithoutRequestFromInput>
    create: XOR<MainRequestCreateWithoutRequestFromInput, MainRequestUncheckedCreateWithoutRequestFromInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestFromInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestFromInput, MainRequestUncheckedUpdateWithoutRequestFromInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestFromInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestFromInput>
  }

  export type UserCreateWithoutNotedByForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutNotedByForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutNotedByForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotedByForTypesInput, UserUncheckedCreateWithoutNotedByForTypesInput>
  }

  export type UserCreateWithoutCheckedByForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutCheckedByForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutCheckedByForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckedByForTypesInput, UserUncheckedCreateWithoutCheckedByForTypesInput>
  }

  export type UserCreateWithoutCheckedBy2ForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutCheckedBy2ForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutCheckedBy2ForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckedBy2ForTypesInput, UserUncheckedCreateWithoutCheckedBy2ForTypesInput>
  }

  export type UserCreateWithoutRecomApprovalForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutRecomApprovalForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutRecomApprovalForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecomApprovalForTypesInput, UserUncheckedCreateWithoutRecomApprovalForTypesInput>
  }

  export type UserCreateWithoutRecomApproval2ForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutRecomApproval2ForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutRecomApproval2ForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecomApproval2ForTypesInput, UserUncheckedCreateWithoutRecomApproval2ForTypesInput>
  }

  export type UserCreateWithoutApproveByForTypesInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutApproveByForTypesInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutApproveByForTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApproveByForTypesInput, UserUncheckedCreateWithoutApproveByForTypesInput>
  }

  export type MainRequestCreateWithoutRequestTypeInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutRequestTypeInput = {
    id?: number
    referenceCode: string
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput>
  }

  export type MainRequestCreateManyRequestTypeInputEnvelope = {
    data: MainRequestCreateManyRequestTypeInput | MainRequestCreateManyRequestTypeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotedByForTypesInput = {
    update: XOR<UserUpdateWithoutNotedByForTypesInput, UserUncheckedUpdateWithoutNotedByForTypesInput>
    create: XOR<UserCreateWithoutNotedByForTypesInput, UserUncheckedCreateWithoutNotedByForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotedByForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotedByForTypesInput, UserUncheckedUpdateWithoutNotedByForTypesInput>
  }

  export type UserUpdateWithoutNotedByForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotedByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUpsertWithoutCheckedByForTypesInput = {
    update: XOR<UserUpdateWithoutCheckedByForTypesInput, UserUncheckedUpdateWithoutCheckedByForTypesInput>
    create: XOR<UserCreateWithoutCheckedByForTypesInput, UserUncheckedCreateWithoutCheckedByForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckedByForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckedByForTypesInput, UserUncheckedUpdateWithoutCheckedByForTypesInput>
  }

  export type UserUpdateWithoutCheckedByForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckedByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUpsertWithoutCheckedBy2ForTypesInput = {
    update: XOR<UserUpdateWithoutCheckedBy2ForTypesInput, UserUncheckedUpdateWithoutCheckedBy2ForTypesInput>
    create: XOR<UserCreateWithoutCheckedBy2ForTypesInput, UserUncheckedCreateWithoutCheckedBy2ForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckedBy2ForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckedBy2ForTypesInput, UserUncheckedUpdateWithoutCheckedBy2ForTypesInput>
  }

  export type UserUpdateWithoutCheckedBy2ForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckedBy2ForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUpsertWithoutRecomApprovalForTypesInput = {
    update: XOR<UserUpdateWithoutRecomApprovalForTypesInput, UserUncheckedUpdateWithoutRecomApprovalForTypesInput>
    create: XOR<UserCreateWithoutRecomApprovalForTypesInput, UserUncheckedCreateWithoutRecomApprovalForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecomApprovalForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecomApprovalForTypesInput, UserUncheckedUpdateWithoutRecomApprovalForTypesInput>
  }

  export type UserUpdateWithoutRecomApprovalForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecomApprovalForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUpsertWithoutRecomApproval2ForTypesInput = {
    update: XOR<UserUpdateWithoutRecomApproval2ForTypesInput, UserUncheckedUpdateWithoutRecomApproval2ForTypesInput>
    create: XOR<UserCreateWithoutRecomApproval2ForTypesInput, UserUncheckedCreateWithoutRecomApproval2ForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecomApproval2ForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecomApproval2ForTypesInput, UserUncheckedUpdateWithoutRecomApproval2ForTypesInput>
  }

  export type UserUpdateWithoutRecomApproval2ForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecomApproval2ForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUpsertWithoutApproveByForTypesInput = {
    update: XOR<UserUpdateWithoutApproveByForTypesInput, UserUncheckedUpdateWithoutApproveByForTypesInput>
    create: XOR<UserCreateWithoutApproveByForTypesInput, UserUncheckedCreateWithoutApproveByForTypesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApproveByForTypesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApproveByForTypesInput, UserUncheckedUpdateWithoutApproveByForTypesInput>
  }

  export type UserUpdateWithoutApproveByForTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutApproveByForTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type MainRequestUpsertWithWhereUniqueWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    update: XOR<MainRequestUpdateWithoutRequestTypeInput, MainRequestUncheckedUpdateWithoutRequestTypeInput>
    create: XOR<MainRequestCreateWithoutRequestTypeInput, MainRequestUncheckedCreateWithoutRequestTypeInput>
  }

  export type MainRequestUpdateWithWhereUniqueWithoutRequestTypeInput = {
    where: MainRequestWhereUniqueInput
    data: XOR<MainRequestUpdateWithoutRequestTypeInput, MainRequestUncheckedUpdateWithoutRequestTypeInput>
  }

  export type MainRequestUpdateManyWithWhereWithoutRequestTypeInput = {
    where: MainRequestScalarWhereInput
    data: XOR<MainRequestUpdateManyMutationInput, MainRequestUncheckedUpdateManyWithoutRequestTypeInput>
  }

  export type RequestTypeCreateWithoutMainRequestsInput = {
    requestName: string
    createdAt?: Date | string
    updateAt?: Date | string
    notedBy?: UserCreateNestedOneWithoutNotedByForTypesInput
    checkedBy?: UserCreateNestedOneWithoutCheckedByForTypesInput
    checkedBy2?: UserCreateNestedOneWithoutCheckedBy2ForTypesInput
    recomApproval?: UserCreateNestedOneWithoutRecomApprovalForTypesInput
    recomApproval2?: UserCreateNestedOneWithoutRecomApproval2ForTypesInput
    approveBy?: UserCreateNestedOneWithoutApproveByForTypesInput
  }

  export type RequestTypeUncheckedCreateWithoutMainRequestsInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateOrConnectWithoutMainRequestsInput = {
    where: RequestTypeWhereUniqueInput
    create: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
  }

  export type FormFundTransferCreateWithoutMainRequestInput = {
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
    requestTo?: UserCreateNestedOneWithoutFormRequestFundToInput
  }

  export type FormFundTransferUncheckedCreateWithoutMainRequestInput = {
    id?: number
    requestToId?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateOrConnectWithoutMainRequestInput = {
    where: FormFundTransferWhereUniqueInput
    create: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
  }

  export type UserCreateWithoutMainFormInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutMainFormInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutMainFormInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
  }

  export type BranchCreateWithoutMainInput = {
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutMainInput = {
    id?: number
    branchCode: string
    branchName: string
    bom: string
    faa: string
    telephone: string
    address: string
    companyName: string
    createdAt?: Date | string
    updateAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutMainInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
  }

  export type ApprovalTableCreateWithoutMainRequestInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateWithoutMainRequestInput = {
    id?: number
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalTableCreateOrConnectWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    create: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput>
  }

  export type ApprovalTableCreateManyMainRequestInputEnvelope = {
    data: ApprovalTableCreateManyMainRequestInput | ApprovalTableCreateManyMainRequestInput[]
    skipDuplicates?: boolean
  }

  export type formTravelOrderCreateWithoutMainFormInput = {
    name?: string | null
    position?: string | null
    departure_date: Date | string
    current_date: Date | string
    destination?: string | null
    purpose_of_travel?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type formTravelOrderUncheckedCreateWithoutMainFormInput = {
    id?: number
    name?: string | null
    position?: string | null
    departure_date: Date | string
    current_date: Date | string
    destination?: string | null
    purpose_of_travel?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type formTravelOrderCreateOrConnectWithoutMainFormInput = {
    where: formTravelOrderWhereUniqueInput
    create: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
  }

  export type formTransmittalMemoCreateWithoutMainFormInput = {
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserCreateNestedOneWithoutFormRequestTransmittalToInput
  }

  export type formTransmittalMemoUncheckedCreateWithoutMainFormInput = {
    id?: number
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
  }

  export type formTransmittalMemoCreateOrConnectWithoutMainFormInput = {
    where: formTransmittalMemoWhereUniqueInput
    create: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
  }

  export type formProposedBudgetCreateWithoutMainFormInput = {
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
  }

  export type formProposedBudgetUncheckedCreateWithoutMainFormInput = {
    id?: number
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
  }

  export type formProposedBudgetCreateOrConnectWithoutMainFormInput = {
    where: formProposedBudgetWhereUniqueInput
    create: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput>
  }

  export type formProposedBudgetCreateManyMainFormInputEnvelope = {
    data: formProposedBudgetCreateManyMainFormInput | formProposedBudgetCreateManyMainFormInput[]
    skipDuplicates?: boolean
  }

  export type formDisburseCreateWithoutMainFormInput = {
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserCreateNestedOneWithoutFormRequestDisburseToInput
  }

  export type formDisburseUncheckedCreateWithoutMainFormInput = {
    id?: number
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: number | null
  }

  export type formDisburseCreateOrConnectWithoutMainFormInput = {
    where: formDisburseWhereUniqueInput
    create: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
  }

  export type CountSheetCreateWithoutMaincountSheetInput = {
    fundType: string
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundCreateNestedManyWithoutCashSheetInput
    TravelCountSheet?: TravelFundCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetUncheckedCreateWithoutMaincountSheetInput = {
    id?: number
    fundType: string
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedCreateNestedManyWithoutCashSheetInput
    TravelCountSheet?: TravelFundUncheckedCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetCreateOrConnectWithoutMaincountSheetInput = {
    where: CountSheetWhereUniqueInput
    create: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
  }

  export type RequestTypeUpsertWithoutMainRequestsInput = {
    update: XOR<RequestTypeUpdateWithoutMainRequestsInput, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
    create: XOR<RequestTypeCreateWithoutMainRequestsInput, RequestTypeUncheckedCreateWithoutMainRequestsInput>
    where?: RequestTypeWhereInput
  }

  export type RequestTypeUpdateToOneWithWhereWithoutMainRequestsInput = {
    where?: RequestTypeWhereInput
    data: XOR<RequestTypeUpdateWithoutMainRequestsInput, RequestTypeUncheckedUpdateWithoutMainRequestsInput>
  }

  export type RequestTypeUpdateWithoutMainRequestsInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutMainRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUpsertWithoutMainRequestInput = {
    update: XOR<FormFundTransferUpdateWithoutMainRequestInput, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
    create: XOR<FormFundTransferCreateWithoutMainRequestInput, FormFundTransferUncheckedCreateWithoutMainRequestInput>
    where?: FormFundTransferWhereInput
  }

  export type FormFundTransferUpdateToOneWithWhereWithoutMainRequestInput = {
    where?: FormFundTransferWhereInput
    data: XOR<FormFundTransferUpdateWithoutMainRequestInput, FormFundTransferUncheckedUpdateWithoutMainRequestInput>
  }

  export type FormFundTransferUpdateWithoutMainRequestInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestTo?: UserUpdateOneWithoutFormRequestFundToNestedInput
  }

  export type FormFundTransferUncheckedUpdateWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestToId?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMainFormInput = {
    update: XOR<UserUpdateWithoutMainFormInput, UserUncheckedUpdateWithoutMainFormInput>
    create: XOR<UserCreateWithoutMainFormInput, UserUncheckedCreateWithoutMainFormInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMainFormInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMainFormInput, UserUncheckedUpdateWithoutMainFormInput>
  }

  export type UserUpdateWithoutMainFormInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type BranchUpsertWithoutMainInput = {
    update: XOR<BranchUpdateWithoutMainInput, BranchUncheckedUpdateWithoutMainInput>
    create: XOR<BranchCreateWithoutMainInput, BranchUncheckedCreateWithoutMainInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutMainInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutMainInput, BranchUncheckedUpdateWithoutMainInput>
  }

  export type BranchUpdateWithoutMainInput = {
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutMainInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchCode?: StringFieldUpdateOperationsInput | string
    branchName?: StringFieldUpdateOperationsInput | string
    bom?: StringFieldUpdateOperationsInput | string
    faa?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ApprovalTableUpsertWithWhereUniqueWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    update: XOR<ApprovalTableUpdateWithoutMainRequestInput, ApprovalTableUncheckedUpdateWithoutMainRequestInput>
    create: XOR<ApprovalTableCreateWithoutMainRequestInput, ApprovalTableUncheckedCreateWithoutMainRequestInput>
  }

  export type ApprovalTableUpdateWithWhereUniqueWithoutMainRequestInput = {
    where: ApprovalTableWhereUniqueInput
    data: XOR<ApprovalTableUpdateWithoutMainRequestInput, ApprovalTableUncheckedUpdateWithoutMainRequestInput>
  }

  export type ApprovalTableUpdateManyWithWhereWithoutMainRequestInput = {
    where: ApprovalTableScalarWhereInput
    data: XOR<ApprovalTableUpdateManyMutationInput, ApprovalTableUncheckedUpdateManyWithoutMainRequestInput>
  }

  export type ApprovalTableScalarWhereInput = {
    AND?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
    OR?: ApprovalTableScalarWhereInput[]
    NOT?: ApprovalTableScalarWhereInput | ApprovalTableScalarWhereInput[]
    id?: IntFilter<"ApprovalTable"> | number
    mainFormId?: IntNullableFilter<"ApprovalTable"> | number | null
    notedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    checkedBy2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    recomApproval2?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    approveBy?: EnumStatusesFilter<"ApprovalTable"> | $Enums.Statuses
    createdAt?: DateTimeFilter<"ApprovalTable"> | Date | string
    updateAt?: DateTimeFilter<"ApprovalTable"> | Date | string
  }

  export type formTravelOrderUpsertWithoutMainFormInput = {
    update: XOR<formTravelOrderUpdateWithoutMainFormInput, formTravelOrderUncheckedUpdateWithoutMainFormInput>
    create: XOR<formTravelOrderCreateWithoutMainFormInput, formTravelOrderUncheckedCreateWithoutMainFormInput>
    where?: formTravelOrderWhereInput
  }

  export type formTravelOrderUpdateToOneWithWhereWithoutMainFormInput = {
    where?: formTravelOrderWhereInput
    data: XOR<formTravelOrderUpdateWithoutMainFormInput, formTravelOrderUncheckedUpdateWithoutMainFormInput>
  }

  export type formTravelOrderUpdateWithoutMainFormInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formTravelOrderUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_date?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    purpose_of_travel?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formTransmittalMemoUpsertWithoutMainFormInput = {
    update: XOR<formTransmittalMemoUpdateWithoutMainFormInput, formTransmittalMemoUncheckedUpdateWithoutMainFormInput>
    create: XOR<formTransmittalMemoCreateWithoutMainFormInput, formTransmittalMemoUncheckedCreateWithoutMainFormInput>
    where?: formTransmittalMemoWhereInput
  }

  export type formTransmittalMemoUpdateToOneWithWhereWithoutMainFormInput = {
    where?: formTransmittalMemoWhereInput
    data: XOR<formTransmittalMemoUpdateWithoutMainFormInput, formTransmittalMemoUncheckedUpdateWithoutMainFormInput>
  }

  export type formTransmittalMemoUpdateWithoutMainFormInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserUpdateOneWithoutFormRequestTransmittalToNestedInput
  }

  export type formTransmittalMemoUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formProposedBudgetUpsertWithWhereUniqueWithoutMainFormInput = {
    where: formProposedBudgetWhereUniqueInput
    update: XOR<formProposedBudgetUpdateWithoutMainFormInput, formProposedBudgetUncheckedUpdateWithoutMainFormInput>
    create: XOR<formProposedBudgetCreateWithoutMainFormInput, formProposedBudgetUncheckedCreateWithoutMainFormInput>
  }

  export type formProposedBudgetUpdateWithWhereUniqueWithoutMainFormInput = {
    where: formProposedBudgetWhereUniqueInput
    data: XOR<formProposedBudgetUpdateWithoutMainFormInput, formProposedBudgetUncheckedUpdateWithoutMainFormInput>
  }

  export type formProposedBudgetUpdateManyWithWhereWithoutMainFormInput = {
    where: formProposedBudgetScalarWhereInput
    data: XOR<formProposedBudgetUpdateManyMutationInput, formProposedBudgetUncheckedUpdateManyWithoutMainFormInput>
  }

  export type formProposedBudgetScalarWhereInput = {
    AND?: formProposedBudgetScalarWhereInput | formProposedBudgetScalarWhereInput[]
    OR?: formProposedBudgetScalarWhereInput[]
    NOT?: formProposedBudgetScalarWhereInput | formProposedBudgetScalarWhereInput[]
    id?: IntFilter<"formProposedBudget"> | number
    description?: StringNullableFilter<"formProposedBudget"> | string | null
    budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    total_expenses?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    variance?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: DecimalNullableFilter<"formProposedBudget"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"formProposedBudget"> | string | null
    expense_type?: StringNullableFilter<"formProposedBudget"> | string | null
    month_of?: StringNullableFilter<"formProposedBudget"> | string | null
    createdAt?: DateTimeFilter<"formProposedBudget"> | Date | string
    mainFormId?: IntFilter<"formProposedBudget"> | number
  }

  export type formDisburseUpsertWithoutMainFormInput = {
    update: XOR<formDisburseUpdateWithoutMainFormInput, formDisburseUncheckedUpdateWithoutMainFormInput>
    create: XOR<formDisburseCreateWithoutMainFormInput, formDisburseUncheckedCreateWithoutMainFormInput>
    where?: formDisburseWhereInput
  }

  export type formDisburseUpdateToOneWithWhereWithoutMainFormInput = {
    where?: formDisburseWhereInput
    data: XOR<formDisburseUpdateWithoutMainFormInput, formDisburseUncheckedUpdateWithoutMainFormInput>
  }

  export type formDisburseUpdateWithoutMainFormInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    requestTo?: UserUpdateOneWithoutFormRequestDisburseToNestedInput
  }

  export type formDisburseUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    to_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountSheetUpsertWithoutMaincountSheetInput = {
    update: XOR<CountSheetUpdateWithoutMaincountSheetInput, CountSheetUncheckedUpdateWithoutMaincountSheetInput>
    create: XOR<CountSheetCreateWithoutMaincountSheetInput, CountSheetUncheckedCreateWithoutMaincountSheetInput>
    where?: CountSheetWhereInput
  }

  export type CountSheetUpdateToOneWithWhereWithoutMaincountSheetInput = {
    where?: CountSheetWhereInput
    data: XOR<CountSheetUpdateWithoutMaincountSheetInput, CountSheetUncheckedUpdateWithoutMaincountSheetInput>
  }

  export type CountSheetUpdateWithoutMaincountSheetInput = {
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUpdateManyWithoutCashSheetNestedInput
    TravelCountSheet?: TravelFundUpdateManyWithoutTravelSheetNestedInput
  }

  export type CountSheetUncheckedUpdateWithoutMaincountSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedUpdateManyWithoutCashSheetNestedInput
    TravelCountSheet?: TravelFundUncheckedUpdateManyWithoutTravelSheetNestedInput
  }

  export type MainRequestCreateWithoutFundTransferInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutFundTransferInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutFundTransferInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
  }

  export type UserCreateWithoutFormRequestFundToInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutFormRequestFundToInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutFormRequestFundToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormRequestFundToInput, UserUncheckedCreateWithoutFormRequestFundToInput>
  }

  export type MainRequestUpsertWithoutFundTransferInput = {
    update: XOR<MainRequestUpdateWithoutFundTransferInput, MainRequestUncheckedUpdateWithoutFundTransferInput>
    create: XOR<MainRequestCreateWithoutFundTransferInput, MainRequestUncheckedCreateWithoutFundTransferInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutFundTransferInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutFundTransferInput, MainRequestUncheckedUpdateWithoutFundTransferInput>
  }

  export type MainRequestUpdateWithoutFundTransferInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutFundTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type UserUpsertWithoutFormRequestFundToInput = {
    update: XOR<UserUpdateWithoutFormRequestFundToInput, UserUncheckedUpdateWithoutFormRequestFundToInput>
    create: XOR<UserCreateWithoutFormRequestFundToInput, UserUncheckedCreateWithoutFormRequestFundToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormRequestFundToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormRequestFundToInput, UserUncheckedUpdateWithoutFormRequestFundToInput>
  }

  export type UserUpdateWithoutFormRequestFundToInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutFormRequestFundToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type MainRequestCreateWithoutApprovalInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutApprovalInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutApprovalInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsCreateWithoutApprovalInput = {
    checkerType: string
    action: string
    createdAt?: Date | string
    approver?: UserCreateNestedOneWithoutRequestLogsInput
  }

  export type RequestLogsUncheckedCreateWithoutApprovalInput = {
    id?: number
    checkerType: string
    approverId?: number | null
    action: string
    createdAt?: Date | string
  }

  export type RequestLogsCreateOrConnectWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    create: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsCreateManyApprovalInputEnvelope = {
    data: RequestLogsCreateManyApprovalInput | RequestLogsCreateManyApprovalInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestUpsertWithoutApprovalInput = {
    update: XOR<MainRequestUpdateWithoutApprovalInput, MainRequestUncheckedUpdateWithoutApprovalInput>
    create: XOR<MainRequestCreateWithoutApprovalInput, MainRequestUncheckedCreateWithoutApprovalInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutApprovalInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutApprovalInput, MainRequestUncheckedUpdateWithoutApprovalInput>
  }

  export type MainRequestUpdateWithoutApprovalInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type RequestLogsUpsertWithWhereUniqueWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    update: XOR<RequestLogsUpdateWithoutApprovalInput, RequestLogsUncheckedUpdateWithoutApprovalInput>
    create: XOR<RequestLogsCreateWithoutApprovalInput, RequestLogsUncheckedCreateWithoutApprovalInput>
  }

  export type RequestLogsUpdateWithWhereUniqueWithoutApprovalInput = {
    where: RequestLogsWhereUniqueInput
    data: XOR<RequestLogsUpdateWithoutApprovalInput, RequestLogsUncheckedUpdateWithoutApprovalInput>
  }

  export type RequestLogsUpdateManyWithWhereWithoutApprovalInput = {
    where: RequestLogsScalarWhereInput
    data: XOR<RequestLogsUpdateManyMutationInput, RequestLogsUncheckedUpdateManyWithoutApprovalInput>
  }

  export type ApprovalTableCreateWithoutRequestLogsInput = {
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
    mainRequest?: MainRequestCreateNestedOneWithoutApprovalInput
  }

  export type ApprovalTableUncheckedCreateWithoutRequestLogsInput = {
    id?: number
    mainFormId?: number | null
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovalTableCreateOrConnectWithoutRequestLogsInput = {
    where: ApprovalTableWhereUniqueInput
    create: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
  }

  export type UserCreateWithoutRequestLogsInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutRequestLogsInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutRequestLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestLogsInput, UserUncheckedCreateWithoutRequestLogsInput>
  }

  export type ApprovalTableUpsertWithoutRequestLogsInput = {
    update: XOR<ApprovalTableUpdateWithoutRequestLogsInput, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
    create: XOR<ApprovalTableCreateWithoutRequestLogsInput, ApprovalTableUncheckedCreateWithoutRequestLogsInput>
    where?: ApprovalTableWhereInput
  }

  export type ApprovalTableUpdateToOneWithWhereWithoutRequestLogsInput = {
    where?: ApprovalTableWhereInput
    data: XOR<ApprovalTableUpdateWithoutRequestLogsInput, ApprovalTableUncheckedUpdateWithoutRequestLogsInput>
  }

  export type ApprovalTableUpdateWithoutRequestLogsInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateWithoutRequestLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRequestLogsInput = {
    update: XOR<UserUpdateWithoutRequestLogsInput, UserUncheckedUpdateWithoutRequestLogsInput>
    create: XOR<UserCreateWithoutRequestLogsInput, UserUncheckedCreateWithoutRequestLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestLogsInput, UserUncheckedUpdateWithoutRequestLogsInput>
  }

  export type UserUpdateWithoutRequestLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type MainRequestCreateWithoutTravelOrderInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutTravelOrderInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutTravelOrderInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutTravelOrderInput, MainRequestUncheckedCreateWithoutTravelOrderInput>
  }

  export type MainRequestUpsertWithoutTravelOrderInput = {
    update: XOR<MainRequestUpdateWithoutTravelOrderInput, MainRequestUncheckedUpdateWithoutTravelOrderInput>
    create: XOR<MainRequestCreateWithoutTravelOrderInput, MainRequestUncheckedCreateWithoutTravelOrderInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutTravelOrderInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutTravelOrderInput, MainRequestUncheckedUpdateWithoutTravelOrderInput>
  }

  export type MainRequestUpdateWithoutTravelOrderInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutTravelOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestCreateWithoutProposedBudgetInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutProposedBudgetInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutProposedBudgetInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutProposedBudgetInput, MainRequestUncheckedCreateWithoutProposedBudgetInput>
  }

  export type MainRequestUpsertWithoutProposedBudgetInput = {
    update: XOR<MainRequestUpdateWithoutProposedBudgetInput, MainRequestUncheckedUpdateWithoutProposedBudgetInput>
    create: XOR<MainRequestCreateWithoutProposedBudgetInput, MainRequestUncheckedCreateWithoutProposedBudgetInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutProposedBudgetInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutProposedBudgetInput, MainRequestUncheckedUpdateWithoutProposedBudgetInput>
  }

  export type MainRequestUpdateWithoutProposedBudgetInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutProposedBudgetInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type UserCreateWithoutFormRequestTransmittalToInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutFormRequestTransmittalToInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestDisburseTo?: formDisburseUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutFormRequestTransmittalToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormRequestTransmittalToInput, UserUncheckedCreateWithoutFormRequestTransmittalToInput>
  }

  export type MainRequestCreateWithoutTransmittalMemoInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutTransmittalMemoInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutTransmittalMemoInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutTransmittalMemoInput, MainRequestUncheckedCreateWithoutTransmittalMemoInput>
  }

  export type UserUpsertWithoutFormRequestTransmittalToInput = {
    update: XOR<UserUpdateWithoutFormRequestTransmittalToInput, UserUncheckedUpdateWithoutFormRequestTransmittalToInput>
    create: XOR<UserCreateWithoutFormRequestTransmittalToInput, UserUncheckedCreateWithoutFormRequestTransmittalToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormRequestTransmittalToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormRequestTransmittalToInput, UserUncheckedUpdateWithoutFormRequestTransmittalToInput>
  }

  export type UserUpdateWithoutFormRequestTransmittalToInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutFormRequestTransmittalToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type MainRequestUpsertWithoutTransmittalMemoInput = {
    update: XOR<MainRequestUpdateWithoutTransmittalMemoInput, MainRequestUncheckedUpdateWithoutTransmittalMemoInput>
    create: XOR<MainRequestCreateWithoutTransmittalMemoInput, MainRequestUncheckedCreateWithoutTransmittalMemoInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutTransmittalMemoInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutTransmittalMemoInput, MainRequestUncheckedUpdateWithoutTransmittalMemoInput>
  }

  export type MainRequestUpdateWithoutTransmittalMemoInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutTransmittalMemoInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type UserCreateWithoutFormRequestDisburseToInput = {
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    notedByForTypes?: RequestTypeCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestCreateNestedManyWithoutRequestByInput
  }

  export type UserUncheckedCreateWithoutFormRequestDisburseToInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    branchId?: number | null
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
    notedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutNotedByInput
    checkedByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedByInput
    checkedBy2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutCheckedBy2Input
    recomApprovalForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApprovalInput
    recomApproval2ForTypes?: RequestTypeUncheckedCreateNestedManyWithoutRecomApproval2Input
    approveByForTypes?: RequestTypeUncheckedCreateNestedManyWithoutApproveByInput
    formRequestFundTo?: FormFundTransferUncheckedCreateNestedManyWithoutRequestToInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedCreateNestedManyWithoutRequestToInput
    requestLogs?: RequestLogsUncheckedCreateNestedManyWithoutApproverInput
    mainForm?: MainRequestUncheckedCreateNestedManyWithoutRequestByInput
  }

  export type UserCreateOrConnectWithoutFormRequestDisburseToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormRequestDisburseToInput, UserUncheckedCreateWithoutFormRequestDisburseToInput>
  }

  export type MainRequestCreateWithoutDisburseInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    countSheet?: CountSheetCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestUncheckedCreateWithoutDisburseInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    countSheet?: CountSheetUncheckedCreateNestedOneWithoutMaincountSheetInput
  }

  export type MainRequestCreateOrConnectWithoutDisburseInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutDisburseInput, MainRequestUncheckedCreateWithoutDisburseInput>
  }

  export type UserUpsertWithoutFormRequestDisburseToInput = {
    update: XOR<UserUpdateWithoutFormRequestDisburseToInput, UserUncheckedUpdateWithoutFormRequestDisburseToInput>
    create: XOR<UserCreateWithoutFormRequestDisburseToInput, UserUncheckedCreateWithoutFormRequestDisburseToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormRequestDisburseToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormRequestDisburseToInput, UserUncheckedUpdateWithoutFormRequestDisburseToInput>
  }

  export type UserUpdateWithoutFormRequestDisburseToInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutFormRequestDisburseToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type MainRequestUpsertWithoutDisburseInput = {
    update: XOR<MainRequestUpdateWithoutDisburseInput, MainRequestUncheckedUpdateWithoutDisburseInput>
    create: XOR<MainRequestCreateWithoutDisburseInput, MainRequestUncheckedCreateWithoutDisburseInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutDisburseInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutDisburseInput, MainRequestUncheckedUpdateWithoutDisburseInput>
  }

  export type MainRequestUpdateWithoutDisburseInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutDisburseInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestCreateWithoutCountSheetInput = {
    referenceCode: string
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    requestType?: RequestTypeCreateNestedOneWithoutMainRequestsInput
    fundTransfer?: FormFundTransferCreateNestedOneWithoutMainRequestInput
    requestBy?: UserCreateNestedOneWithoutMainFormInput
    requestFrom?: BranchCreateNestedOneWithoutMainInput
    approval?: ApprovalTableCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseCreateNestedOneWithoutMainFormInput
  }

  export type MainRequestUncheckedCreateWithoutCountSheetInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
    fundTransfer?: FormFundTransferUncheckedCreateNestedOneWithoutMainRequestInput
    approval?: ApprovalTableUncheckedCreateNestedManyWithoutMainRequestInput
    travelOrder?: formTravelOrderUncheckedCreateNestedOneWithoutMainFormInput
    transmittalMemo?: formTransmittalMemoUncheckedCreateNestedOneWithoutMainFormInput
    proposedBudget?: formProposedBudgetUncheckedCreateNestedManyWithoutMainFormInput
    disburse?: formDisburseUncheckedCreateNestedOneWithoutMainFormInput
  }

  export type MainRequestCreateOrConnectWithoutCountSheetInput = {
    where: MainRequestWhereUniqueInput
    create: XOR<MainRequestCreateWithoutCountSheetInput, MainRequestUncheckedCreateWithoutCountSheetInput>
  }

  export type CashFundCreateWithoutCashSheetInput = {
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUncheckedCreateWithoutCashSheetInput = {
    id?: number
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundCreateOrConnectWithoutCashSheetInput = {
    where: CashFundWhereUniqueInput
    create: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput>
  }

  export type CashFundCreateManyCashSheetInputEnvelope = {
    data: CashFundCreateManyCashSheetInput | CashFundCreateManyCashSheetInput[]
    skipDuplicates?: boolean
  }

  export type TravelFundCreateWithoutTravelSheetInput = {
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
  }

  export type TravelFundUncheckedCreateWithoutTravelSheetInput = {
    id?: number
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
  }

  export type TravelFundCreateOrConnectWithoutTravelSheetInput = {
    where: TravelFundWhereUniqueInput
    create: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput>
  }

  export type TravelFundCreateManyTravelSheetInputEnvelope = {
    data: TravelFundCreateManyTravelSheetInput | TravelFundCreateManyTravelSheetInput[]
    skipDuplicates?: boolean
  }

  export type MainRequestUpsertWithoutCountSheetInput = {
    update: XOR<MainRequestUpdateWithoutCountSheetInput, MainRequestUncheckedUpdateWithoutCountSheetInput>
    create: XOR<MainRequestCreateWithoutCountSheetInput, MainRequestUncheckedCreateWithoutCountSheetInput>
    where?: MainRequestWhereInput
  }

  export type MainRequestUpdateToOneWithWhereWithoutCountSheetInput = {
    where?: MainRequestWhereInput
    data: XOR<MainRequestUpdateWithoutCountSheetInput, MainRequestUncheckedUpdateWithoutCountSheetInput>
  }

  export type MainRequestUpdateWithoutCountSheetInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutCountSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
  }

  export type CashFundUpsertWithWhereUniqueWithoutCashSheetInput = {
    where: CashFundWhereUniqueInput
    update: XOR<CashFundUpdateWithoutCashSheetInput, CashFundUncheckedUpdateWithoutCashSheetInput>
    create: XOR<CashFundCreateWithoutCashSheetInput, CashFundUncheckedCreateWithoutCashSheetInput>
  }

  export type CashFundUpdateWithWhereUniqueWithoutCashSheetInput = {
    where: CashFundWhereUniqueInput
    data: XOR<CashFundUpdateWithoutCashSheetInput, CashFundUncheckedUpdateWithoutCashSheetInput>
  }

  export type CashFundUpdateManyWithWhereWithoutCashSheetInput = {
    where: CashFundScalarWhereInput
    data: XOR<CashFundUpdateManyMutationInput, CashFundUncheckedUpdateManyWithoutCashSheetInput>
  }

  export type CashFundScalarWhereInput = {
    AND?: CashFundScalarWhereInput | CashFundScalarWhereInput[]
    OR?: CashFundScalarWhereInput[]
    NOT?: CashFundScalarWhereInput | CashFundScalarWhereInput[]
    id?: IntFilter<"CashFund"> | number
    countId?: IntNullableFilter<"CashFund"> | number | null
    startDate?: DateTimeFilter<"CashFund"> | Date | string
    endDate?: DateTimeFilter<"CashFund"> | Date | string
    reqDate?: DateTimeFilter<"CashFund"> | Date | string
    payee?: StringFilter<"CashFund"> | string
    remarks?: StringNullableFilter<"CashFund"> | string | null
    fundAmount?: DecimalFilter<"CashFund"> | Decimal | DecimalJsLike | number | string
    miscExp?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    billFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    telFee?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
    dueMh?: DecimalNullableFilter<"CashFund"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TravelFundUpsertWithWhereUniqueWithoutTravelSheetInput = {
    where: TravelFundWhereUniqueInput
    update: XOR<TravelFundUpdateWithoutTravelSheetInput, TravelFundUncheckedUpdateWithoutTravelSheetInput>
    create: XOR<TravelFundCreateWithoutTravelSheetInput, TravelFundUncheckedCreateWithoutTravelSheetInput>
  }

  export type TravelFundUpdateWithWhereUniqueWithoutTravelSheetInput = {
    where: TravelFundWhereUniqueInput
    data: XOR<TravelFundUpdateWithoutTravelSheetInput, TravelFundUncheckedUpdateWithoutTravelSheetInput>
  }

  export type TravelFundUpdateManyWithWhereWithoutTravelSheetInput = {
    where: TravelFundScalarWhereInput
    data: XOR<TravelFundUpdateManyMutationInput, TravelFundUncheckedUpdateManyWithoutTravelSheetInput>
  }

  export type TravelFundScalarWhereInput = {
    AND?: TravelFundScalarWhereInput | TravelFundScalarWhereInput[]
    OR?: TravelFundScalarWhereInput[]
    NOT?: TravelFundScalarWhereInput | TravelFundScalarWhereInput[]
    id?: IntFilter<"TravelFund"> | number
    countId?: IntNullableFilter<"TravelFund"> | number | null
    tagsField?: StringNullableListFilter<"TravelFund">
    startDate?: DateTimeFilter<"TravelFund"> | Date | string
    endDate?: DateTimeFilter<"TravelFund"> | Date | string
    reqDate?: DateTimeFilter<"TravelFund"> | Date | string
    travelling?: StringNullableFilter<"TravelFund"> | string | null
    fuel?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    repair?: StringNullableListFilter<"TravelFund">
    litigation?: DecimalNullableFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFilter<"TravelFund"> | Decimal | DecimalJsLike | number | string
    kilometer?: StringNullableFilter<"TravelFund"> | string | null
    remarks?: StringNullableFilter<"TravelFund"> | string | null
  }

  export type CountSheetCreateWithoutCashCountSheetInput = {
    fundType: string
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestCreateNestedOneWithoutCountSheetInput
    TravelCountSheet?: TravelFundCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetUncheckedCreateWithoutCashCountSheetInput = {
    id?: number
    fundType: string
    mainFormId?: number | null
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    TravelCountSheet?: TravelFundUncheckedCreateNestedManyWithoutTravelSheetInput
  }

  export type CountSheetCreateOrConnectWithoutCashCountSheetInput = {
    where: CountSheetWhereUniqueInput
    create: XOR<CountSheetCreateWithoutCashCountSheetInput, CountSheetUncheckedCreateWithoutCashCountSheetInput>
  }

  export type CountSheetUpsertWithoutCashCountSheetInput = {
    update: XOR<CountSheetUpdateWithoutCashCountSheetInput, CountSheetUncheckedUpdateWithoutCashCountSheetInput>
    create: XOR<CountSheetCreateWithoutCashCountSheetInput, CountSheetUncheckedCreateWithoutCashCountSheetInput>
    where?: CountSheetWhereInput
  }

  export type CountSheetUpdateToOneWithWhereWithoutCashCountSheetInput = {
    where?: CountSheetWhereInput
    data: XOR<CountSheetUpdateWithoutCashCountSheetInput, CountSheetUncheckedUpdateWithoutCashCountSheetInput>
  }

  export type CountSheetUpdateWithoutCashCountSheetInput = {
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestUpdateOneWithoutCountSheetNestedInput
    TravelCountSheet?: TravelFundUpdateManyWithoutTravelSheetNestedInput
  }

  export type CountSheetUncheckedUpdateWithoutCashCountSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundType?: StringFieldUpdateOperationsInput | string
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    TravelCountSheet?: TravelFundUncheckedUpdateManyWithoutTravelSheetNestedInput
  }

  export type CountSheetCreateWithoutTravelCountSheetInput = {
    fundType: string
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestCreateNestedOneWithoutCountSheetInput
    CashCountSheet?: CashFundCreateNestedManyWithoutCashSheetInput
  }

  export type CountSheetUncheckedCreateWithoutTravelCountSheetInput = {
    id?: number
    fundType: string
    mainFormId?: number | null
    office: string
    dateCount: Date | string
    fundName: string
    fundAmount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund: Decimal | DecimalJsLike | number | string
    totalFund: Decimal | DecimalJsLike | number | string
    cashShort?: Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedCreateNestedManyWithoutCashSheetInput
  }

  export type CountSheetCreateOrConnectWithoutTravelCountSheetInput = {
    where: CountSheetWhereUniqueInput
    create: XOR<CountSheetCreateWithoutTravelCountSheetInput, CountSheetUncheckedCreateWithoutTravelCountSheetInput>
  }

  export type CountSheetUpsertWithoutTravelCountSheetInput = {
    update: XOR<CountSheetUpdateWithoutTravelCountSheetInput, CountSheetUncheckedUpdateWithoutTravelCountSheetInput>
    create: XOR<CountSheetCreateWithoutTravelCountSheetInput, CountSheetUncheckedCreateWithoutTravelCountSheetInput>
    where?: CountSheetWhereInput
  }

  export type CountSheetUpdateToOneWithWhereWithoutTravelCountSheetInput = {
    where?: CountSheetWhereInput
    data: XOR<CountSheetUpdateWithoutTravelCountSheetInput, CountSheetUncheckedUpdateWithoutTravelCountSheetInput>
  }

  export type CountSheetUpdateWithoutTravelCountSheetInput = {
    fundType?: StringFieldUpdateOperationsInput | string
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    MaincountSheet?: MainRequestUpdateOneWithoutCountSheetNestedInput
    CashCountSheet?: CashFundUpdateManyWithoutCashSheetNestedInput
  }

  export type CountSheetUncheckedUpdateWithoutTravelCountSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    fundType?: StringFieldUpdateOperationsInput | string
    mainFormId?: NullableIntFieldUpdateOperationsInput | number | null
    office?: StringFieldUpdateOperationsInput | string
    dateCount?: DateTimeFieldUpdateOperationsInput | Date | string
    fundName?: StringFieldUpdateOperationsInput | string
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashDemo?: NullableJsonNullValueInput | InputJsonValue
    repFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalFund?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashShort?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CashCountSheet?: CashFundUncheckedUpdateManyWithoutCashSheetNestedInput
  }

  export type RequestTypeCreateManyNotedByInput = {
    id?: number
    requestName: string
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyCheckedByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyCheckedBy2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyRecomApprovalInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApproval2Id?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyRecomApproval2Input = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    approveById?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeCreateManyApproveByInput = {
    id?: number
    requestName: string
    notedById?: number | null
    checkedById?: number | null
    checkedBy2Id?: number | null
    recomApprovalId?: number | null
    recomApproval2Id?: number | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FormFundTransferCreateManyRequestToInput = {
    id?: number
    mainRequestID?: number | null
    requestContent: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type formTransmittalMemoCreateManyRequestToInput = {
    id?: number
    from?: string | null
    date: Date | string
    description?: string | null
    note?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId: number
  }

  export type formDisburseCreateManyRequestToInput = {
    id?: number
    from?: string | null
    date: Date | string
    subject?: string | null
    description?: string | null
    note?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId: number
  }

  export type RequestLogsCreateManyApproverInput = {
    id?: number
    approvalId?: number | null
    checkerType: string
    action: string
    createdAt?: Date | string
  }

  export type MainRequestCreateManyRequestByInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type RequestTypeUpdateWithoutNotedByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutNotedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutNotedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutCheckedByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutCheckedBy2Input = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutCheckedBy2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutCheckedBy2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutRecomApprovalInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutRecomApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutRecomApproval2Input = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    approveBy?: UserUpdateOneWithoutApproveByForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutRecomApproval2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutRecomApproval2Input = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    approveById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestTypeUpdateWithoutApproveByInput = {
    requestName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedBy?: UserUpdateOneWithoutNotedByForTypesNestedInput
    checkedBy?: UserUpdateOneWithoutCheckedByForTypesNestedInput
    checkedBy2?: UserUpdateOneWithoutCheckedBy2ForTypesNestedInput
    recomApproval?: UserUpdateOneWithoutRecomApprovalForTypesNestedInput
    recomApproval2?: UserUpdateOneWithoutRecomApproval2ForTypesNestedInput
    mainRequests?: MainRequestUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateWithoutApproveByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequests?: MainRequestUncheckedUpdateManyWithoutRequestTypeNestedInput
  }

  export type RequestTypeUncheckedUpdateManyWithoutApproveByInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestName?: StringFieldUpdateOperationsInput | string
    notedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedById?: NullableIntFieldUpdateOperationsInput | number | null
    checkedBy2Id?: NullableIntFieldUpdateOperationsInput | number | null
    recomApprovalId?: NullableIntFieldUpdateOperationsInput | number | null
    recomApproval2Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUpdateWithoutRequestToInput = {
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mainRequest?: MainRequestUpdateOneWithoutFundTransferNestedInput
  }

  export type FormFundTransferUncheckedUpdateWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormFundTransferUncheckedUpdateManyWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    mainRequestID?: NullableIntFieldUpdateOperationsInput | number | null
    requestContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formTransmittalMemoUpdateWithoutRequestToInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainForm?: MainRequestUpdateOneWithoutTransmittalMemoNestedInput
  }

  export type formTransmittalMemoUncheckedUpdateWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formTransmittalMemoUncheckedUpdateManyWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formDisburseUpdateWithoutRequestToInput = {
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainForm?: MainRequestUpdateOneWithoutDisburseNestedInput
  }

  export type formDisburseUncheckedUpdateWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type formDisburseUncheckedUpdateManyWithoutRequestToInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    mainFormId?: IntFieldUpdateOperationsInput | number
  }

  export type RequestLogsUpdateWithoutApproverInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalTableUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvalId?: NullableIntFieldUpdateOperationsInput | number | null
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUpdateWithoutRequestByInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestByInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestByInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: number
    name: string
    email: string
    username: string
    password: string
    role?: $Enums.Role
    signatureUrl?: string | null
    position?: string | null
    initial?: string | null
    approver?: boolean
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestCreateManyRequestFromInput = {
    id?: number
    referenceCode: string
    requestTypeId?: number | null
    requestById?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notedByForTypes?: RequestTypeUncheckedUpdateManyWithoutNotedByNestedInput
    checkedByForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedByNestedInput
    checkedBy2ForTypes?: RequestTypeUncheckedUpdateManyWithoutCheckedBy2NestedInput
    recomApprovalForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApprovalNestedInput
    recomApproval2ForTypes?: RequestTypeUncheckedUpdateManyWithoutRecomApproval2NestedInput
    approveByForTypes?: RequestTypeUncheckedUpdateManyWithoutApproveByNestedInput
    formRequestFundTo?: FormFundTransferUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestTransmittalTo?: formTransmittalMemoUncheckedUpdateManyWithoutRequestToNestedInput
    formRequestDisburseTo?: formDisburseUncheckedUpdateManyWithoutRequestToNestedInput
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApproverNestedInput
    mainForm?: MainRequestUncheckedUpdateManyWithoutRequestByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    initial?: NullableStringFieldUpdateOperationsInput | string | null
    approver?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestUpdateWithoutRequestFromInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestType?: RequestTypeUpdateOneWithoutMainRequestsNestedInput
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainRequestCreateManyRequestTypeInput = {
    id?: number
    referenceCode: string
    requestById?: number | null
    requestFromId?: number | null
    status?: $Enums.Statuses
    requestDate: Date | string
    remarks?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MainRequestUpdateWithoutRequestTypeInput = {
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUpdateOneWithoutMainRequestNestedInput
    requestBy?: UserUpdateOneWithoutMainFormNestedInput
    requestFrom?: BranchUpdateOneWithoutMainNestedInput
    approval?: ApprovalTableUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateWithoutRequestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundTransfer?: FormFundTransferUncheckedUpdateOneWithoutMainRequestNestedInput
    approval?: ApprovalTableUncheckedUpdateManyWithoutMainRequestNestedInput
    travelOrder?: formTravelOrderUncheckedUpdateOneWithoutMainFormNestedInput
    transmittalMemo?: formTransmittalMemoUncheckedUpdateOneWithoutMainFormNestedInput
    proposedBudget?: formProposedBudgetUncheckedUpdateManyWithoutMainFormNestedInput
    disburse?: formDisburseUncheckedUpdateOneWithoutMainFormNestedInput
    countSheet?: CountSheetUncheckedUpdateOneWithoutMaincountSheetNestedInput
  }

  export type MainRequestUncheckedUpdateManyWithoutRequestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceCode?: StringFieldUpdateOperationsInput | string
    requestById?: NullableIntFieldUpdateOperationsInput | number | null
    requestFromId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTableCreateManyMainRequestInput = {
    id?: number
    notedBy?: $Enums.Statuses
    checkedBy?: $Enums.Statuses
    checkedBy2?: $Enums.Statuses
    recomApproval?: $Enums.Statuses
    recomApproval2?: $Enums.Statuses
    approveBy?: $Enums.Statuses
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type formProposedBudgetCreateManyMainFormInput = {
    id?: number
    description?: string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    total_expenses?: Decimal | DecimalJsLike | number | string | null
    variance?: Decimal | DecimalJsLike | number | string | null
    proposed_budget?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    expense_type?: string | null
    month_of?: string | null
    createdAt?: Date | string
  }

  export type ApprovalTableUpdateWithoutMainRequestInput = {
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestLogs?: RequestLogsUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalTableUncheckedUpdateManyWithoutMainRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    notedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    checkedBy2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    recomApproval2?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    approveBy?: EnumStatusesFieldUpdateOperationsInput | $Enums.Statuses
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formProposedBudgetUpdateWithoutMainFormInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formProposedBudgetUncheckedUpdateWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formProposedBudgetUncheckedUpdateManyWithoutMainFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposed_budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    expense_type?: NullableStringFieldUpdateOperationsInput | string | null
    month_of?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsCreateManyApprovalInput = {
    id?: number
    checkerType: string
    approverId?: number | null
    action: string
    createdAt?: Date | string
  }

  export type RequestLogsUpdateWithoutApprovalInput = {
    checkerType?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutRequestLogsNestedInput
  }

  export type RequestLogsUncheckedUpdateWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestLogsUncheckedUpdateManyWithoutApprovalInput = {
    id?: IntFieldUpdateOperationsInput | number
    checkerType?: StringFieldUpdateOperationsInput | string
    approverId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFundCreateManyCashSheetInput = {
    id?: number
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    payee: string
    remarks?: string | null
    fundAmount: Decimal | DecimalJsLike | number | string
    miscExp?: Decimal | DecimalJsLike | number | string | null
    billFee?: Decimal | DecimalJsLike | number | string | null
    telFee?: Decimal | DecimalJsLike | number | string | null
    dueMh?: Decimal | DecimalJsLike | number | string | null
  }

  export type TravelFundCreateManyTravelSheetInput = {
    id?: number
    tagsField?: TravelFundCreatetagsFieldInput | string[]
    startDate: Date | string
    endDate: Date | string
    reqDate: Date | string
    travelling?: string | null
    fuel?: Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundCreaterepairInput | string[]
    litigation?: Decimal | DecimalJsLike | number | string | null
    totalFee: Decimal | DecimalJsLike | number | string
    kilometer?: string | null
    remarks?: string | null
  }

  export type CashFundUpdateWithoutCashSheetInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUncheckedUpdateWithoutCashSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CashFundUncheckedUpdateManyWithoutCashSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payee?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    fundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    miscExp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    telFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueMh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TravelFundUpdateWithoutTravelSheetInput = {
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TravelFundUncheckedUpdateWithoutTravelSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TravelFundUncheckedUpdateManyWithoutTravelSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagsField?: TravelFundUpdatetagsFieldInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqDate?: DateTimeFieldUpdateOperationsInput | Date | string
    travelling?: NullableStringFieldUpdateOperationsInput | string | null
    fuel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    repair?: TravelFundUpdaterepairInput | string[]
    litigation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kilometer?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}